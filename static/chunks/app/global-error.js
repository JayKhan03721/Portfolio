/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/global-error"],{

/***/ "(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cnbeha%5CDesktop%5CPortfolio%5Capp%5Cglobal-error.jsx&server=false!":
/*!************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cnbeha%5CDesktop%5CPortfolio%5Capp%5Cglobal-error.jsx&server=false! ***!
  \************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/global-error.jsx */ \"(app-pages-browser)/./app/global-error.jsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9QyUzQSU1Q1VzZXJzJTVDbmJlaGElNUNEZXNrdG9wJTVDUG9ydGZvbGlvJTVDYXBwJTVDZ2xvYmFsLWVycm9yLmpzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZDliZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXG5iZWhhXFxcXERlc2t0b3BcXFxcUG9ydGZvbGlvXFxcXGFwcFxcXFxnbG9iYWwtZXJyb3IuanN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cnbeha%5CDesktop%5CPortfolio%5Capp%5Cglobal-error.jsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/error.js":
/*!*************************************!*\
  !*** ../node_modules/next/error.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/pages/_error */ \"(app-pages-browser)/../node_modules/next/dist/pages/_error.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnSUFBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Vycm9yLmpzPzcwMDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcGFnZXMvX2Vycm9yJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/global-error.jsx":
/*!******************************!*\
  !*** ./app/global-error.jsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GlobalError; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _sentry_nextjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/nextjs */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/exports.js\");\n/* harmony import */ var next_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/error */ \"(app-pages-browser)/../node_modules/next/error.js\");\n/* harmony import */ var next_error__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_error__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction GlobalError(param) {\n    let { error } = param;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        _sentry_nextjs__WEBPACK_IMPORTED_MODULE_3__.captureException(error);\n    }, [\n        error\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_error__WEBPACK_IMPORTED_MODULE_1___default()), {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\nbeha\\\\Desktop\\\\Portfolio\\\\app\\\\global-error.jsx\",\n                lineNumber: 15,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\nbeha\\\\Desktop\\\\Portfolio\\\\app\\\\global-error.jsx\",\n            lineNumber: 14,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\nbeha\\\\Desktop\\\\Portfolio\\\\app\\\\global-error.jsx\",\n        lineNumber: 13,\n        columnNumber: 5\n    }, this);\n}\n_s(GlobalError, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = GlobalError;\nvar _c;\n$RefreshReg$(_c, \"GlobalError\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWwtZXJyb3IuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUV5QztBQUNWO0FBQ0c7QUFFbkIsU0FBU0csWUFBWSxLQUFTO1FBQVQsRUFBRUMsS0FBSyxFQUFFLEdBQVQ7O0lBQ2xDRixnREFBU0EsQ0FBQztRQUNSRiw0REFBdUIsQ0FBQ0k7SUFDMUIsR0FBRztRQUFDQTtLQUFNO0lBRVYscUJBQ0UsOERBQUNFO2tCQUNDLDRFQUFDQztzQkFDQyw0RUFBQ04sbURBQUtBOzs7Ozs7Ozs7Ozs7Ozs7QUFJZDtHQVp3QkU7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbC1lcnJvci5qc3g/YjkzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gXCJAc2VudHJ5L25leHRqc1wiO1xuaW1wb3J0IEVycm9yIGZyb20gXCJuZXh0L2Vycm9yXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR2xvYmFsRXJyb3IoeyBlcnJvciB9KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oZXJyb3IpO1xuICB9LCBbZXJyb3JdKTtcblxuICByZXR1cm4gKFxuICAgIDxodG1sPlxuICAgICAgPGJvZHk+XG4gICAgICAgIDxFcnJvciAvPlxuICAgICAgPC9ib2R5PlxuICAgIDwvaHRtbD5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJTZW50cnkiLCJFcnJvciIsInVzZUVmZmVjdCIsIkdsb2JhbEVycm9yIiwiZXJyb3IiLCJjYXB0dXJlRXhjZXB0aW9uIiwiaHRtbCIsImJvZHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/global-error.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/pages/_error.js":
/*!*************************************************!*\
  !*** ../node_modules/next/dist/pages/_error.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Error;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js\"));\nconst statusCodes = {\n    400: \"Bad Request\",\n    404: \"This page could not be found\",\n    405: \"Method Not Allowed\",\n    500: \"Internal Server Error\"\n};\nfunction _getInitialProps(param) {\n    let { res, err } = param;\n    const statusCode = res && res.statusCode ? res.statusCode : err ? err.statusCode : 404;\n    return {\n        statusCode\n    };\n}\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        lineHeight: \"48px\"\n    },\n    h1: {\n        display: \"inline-block\",\n        margin: \"0 20px 0 0\",\n        paddingRight: 23,\n        fontSize: 24,\n        fontWeight: 500,\n        verticalAlign: \"top\"\n    },\n    h2: {\n        fontSize: 14,\n        fontWeight: 400,\n        lineHeight: \"28px\"\n    },\n    wrap: {\n        display: \"inline-block\"\n    }\n};\nclass Error extends _react.default.Component {\n    render() {\n        const { statusCode, withDarkMode = true } = this.props;\n        const title = this.props.title || statusCodes[statusCode] || \"An unexpected error has occurred\";\n        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n            style: styles.error,\n            children: [\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"title\", {\n                        children: statusCode ? statusCode + \": \" + title : \"Application error: a client-side exception has occurred\"\n                    })\n                }),\n                /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n                    style: styles.desc,\n                    children: [\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"style\", {\n                            dangerouslySetInnerHTML: {\n                                /* CSS minified from\n                body { margin: 0; color: #000; background: #fff; }\n                .next-error-h1 {\n                  border-right: 1px solid rgba(0, 0, 0, .3);\n                }\n\n                ${\n                  withDarkMode\n                    ? `@media (prefers-color-scheme: dark) {\n                  body { color: #fff; background: #000; }\n                  .next-error-h1 {\n                    border-right: 1px solid rgba(255, 255, 255, .3);\n                  }\n                }`\n                    : ''\n                }\n               */ __html: \"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}\" + (withDarkMode ? \"@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\" : \"\")\n                            }\n                        }),\n                        statusCode ? /*#__PURE__*/ (0, _jsxruntime.jsx)(\"h1\", {\n                            className: \"next-error-h1\",\n                            style: styles.h1,\n                            children: statusCode\n                        }) : null,\n                        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n                            style: styles.wrap,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"h2\", {\n                                style: styles.h2,\n                                children: [\n                                    this.props.title || statusCode ? title : /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n                                        children: \"Application error: a client-side exception has occurred (see the browser console for more information)\"\n                                    }),\n                                    \".\"\n                                ]\n                            })\n                        })\n                    ]\n                })\n            ]\n        });\n    }\n}\nError.displayName = \"ErrorPage\";\nError.getInitialProps = _getInitialProps;\nError.origGetInitialProps = _getInitialProps;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=_error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxpSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsc0dBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsb0ZBQU87QUFDdkUsTUFBTUksUUFBUSxXQUFXLEdBQUdMLHlCQUF5QkksQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDbkYsTUFBTUssY0FBYztJQUNoQixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFDQSxTQUFTQyxpQkFBaUJDLEtBQUs7SUFDM0IsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRSxHQUFHRjtJQUNuQixNQUFNRyxhQUFhRixPQUFPQSxJQUFJRSxVQUFVLEdBQUdGLElBQUlFLFVBQVUsR0FBR0QsTUFBTUEsSUFBSUMsVUFBVSxHQUFHO0lBQ25GLE9BQU87UUFDSEE7SUFDSjtBQUNKO0FBQ0EsTUFBTUMsU0FBUztJQUNYQyxPQUFPO1FBQ0gsMEZBQTBGO1FBQzFGQyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDcEI7SUFDQUMsTUFBTTtRQUNGQyxZQUFZO0lBQ2hCO0lBQ0FDLElBQUk7UUFDQU4sU0FBUztRQUNUTyxRQUFRO1FBQ1JDLGNBQWM7UUFDZEMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGVBQWU7SUFDbkI7SUFDQUMsSUFBSTtRQUNBSCxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkwsWUFBWTtJQUNoQjtJQUNBUSxNQUFNO1FBQ0ZiLFNBQVM7SUFDYjtBQUNKO0FBQ0EsTUFBTWxCLGNBQWNJLE9BQU80QixPQUFPLENBQUNDLFNBQVM7SUFDeENDLFNBQVM7UUFDTCxNQUFNLEVBQUV0QixVQUFVLEVBQUV1QixlQUFlLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQ0MsS0FBSztRQUN0RCxNQUFNQyxRQUFRLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxLQUFLLElBQUk5QixXQUFXLENBQUNLLFdBQVcsSUFBSTtRQUM3RCxPQUFxQixXQUFILEdBQUksSUFBR1QsWUFBWW1DLElBQUksRUFBRSxPQUFPO1lBQzlDQyxPQUFPMUIsT0FBT0MsS0FBSztZQUNuQjBCLFVBQVU7Z0JBQ04sV0FBVyxHQUFJLElBQUdyQyxZQUFZc0MsR0FBRyxFQUFFbkMsTUFBTTBCLE9BQU8sRUFBRTtvQkFDOUNRLFVBQXdCLFdBQUgsR0FBSSxJQUFHckMsWUFBWXNDLEdBQUcsRUFBRSxTQUFTO3dCQUNsREQsVUFBVTVCLGFBQWFBLGFBQWEsT0FBT3lCLFFBQVE7b0JBQ3ZEO2dCQUNKO2dCQUNBLFdBQVcsR0FBSSxJQUFHbEMsWUFBWW1DLElBQUksRUFBRSxPQUFPO29CQUN2Q0MsT0FBTzFCLE9BQU9TLElBQUk7b0JBQ2xCa0IsVUFBVTt3QkFDTixXQUFXLEdBQUksSUFBR3JDLFlBQVlzQyxHQUFHLEVBQUUsU0FBUzs0QkFDeENDLHlCQUF5QjtnQ0FDckI7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFnQmpCLEdBQUdDLFFBQVEsbUdBQW9HUixDQUFBQSxlQUFlLG9JQUFvSSxFQUFDOzRCQUN0UDt3QkFDSjt3QkFDQXZCLGFBQTJCLFdBQUgsR0FBSSxJQUFHVCxZQUFZc0MsR0FBRyxFQUFFLE1BQU07NEJBQ2xERyxXQUFXOzRCQUNYTCxPQUFPMUIsT0FBT1csRUFBRTs0QkFDaEJnQixVQUFVNUI7d0JBQ2QsS0FBSzt3QkFDTCxXQUFXLEdBQUksSUFBR1QsWUFBWXNDLEdBQUcsRUFBRSxPQUFPOzRCQUN0Q0YsT0FBTzFCLE9BQU9rQixJQUFJOzRCQUNsQlMsVUFBd0IsV0FBSCxHQUFJLElBQUdyQyxZQUFZbUMsSUFBSSxFQUFFLE1BQU07Z0NBQ2hEQyxPQUFPMUIsT0FBT2lCLEVBQUU7Z0NBQ2hCVSxVQUFVO29DQUNOLElBQUksQ0FBQ0osS0FBSyxDQUFDQyxLQUFLLElBQUl6QixhQUFheUIsUUFBc0IsV0FBSCxHQUFJLElBQUdsQyxZQUFZc0MsR0FBRyxFQUFFdEMsWUFBWTBDLFFBQVEsRUFBRTt3Q0FDOUZMLFVBQVU7b0NBQ2Q7b0NBQ0E7aUNBQ0g7NEJBQ0w7d0JBQ0o7cUJBQ0g7Z0JBQ0w7YUFDSDtRQUNMO0lBQ0o7QUFDSjtBQUNBeEMsTUFBTThDLFdBQVcsR0FBRztBQUNwQjlDLE1BQU0rQyxlQUFlLEdBQUd2QztBQUN4QlIsTUFBTWdELG1CQUFtQixHQUFHeEM7QUFFNUIsSUFBSSxDQUFDLE9BQU9aLFFBQVFvQyxPQUFPLEtBQUssY0FBZSxPQUFPcEMsUUFBUW9DLE9BQU8sS0FBSyxZQUFZcEMsUUFBUW9DLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BDLFFBQVFvQyxPQUFPLENBQUNpQixVQUFVLEtBQUssYUFBYTtJQUNyS3ZELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUW9DLE9BQU8sRUFBRSxjQUFjO1FBQUVuQyxPQUFPO0lBQUs7SUFDbkVILE9BQU93RCxNQUFNLENBQUN0RCxRQUFRb0MsT0FBTyxFQUFFcEM7SUFDL0J1RCxPQUFPdkQsT0FBTyxHQUFHQSxRQUFRb0MsT0FBTztBQUNsQyxFQUVBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9wYWdlcy9fZXJyb3IuanM/MDQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2hlYWQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xuY29uc3Qgc3RhdHVzQ29kZXMgPSB7XG4gICAgNDAwOiBcIkJhZCBSZXF1ZXN0XCIsXG4gICAgNDA0OiBcIlRoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmRcIixcbiAgICA0MDU6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG59O1xuZnVuY3Rpb24gX2dldEluaXRpYWxQcm9wcyhwYXJhbSkge1xuICAgIGxldCB7IHJlcywgZXJyIH0gPSBwYXJhbTtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzICYmIHJlcy5zdGF0dXNDb2RlID8gcmVzLnN0YXR1c0NvZGUgOiBlcnIgPyBlcnIuc3RhdHVzQ29kZSA6IDQwNDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlXG4gICAgfTtcbn1cbmNvbnN0IHN0eWxlcyA9IHtcbiAgICBlcnJvcjoge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL21vZGVybi1ub3JtYWxpemUvYmxvYi9tYWluL21vZGVybi1ub3JtYWxpemUuY3NzI0wzOC1MNTJcbiAgICAgICAgZm9udEZhbWlseTogJ3N5c3RlbS11aSxcIlNlZ29lIFVJXCIsUm9ib3RvLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmLFwiQXBwbGUgQ29sb3IgRW1vamlcIixcIlNlZ29lIFVJIEVtb2ppXCInLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIGRlc2M6IHtcbiAgICAgICAgbGluZUhlaWdodDogXCI0OHB4XCJcbiAgICB9LFxuICAgIGgxOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIDIwcHggMCAwXCIsXG4gICAgICAgIHBhZGRpbmdSaWdodDogMjMsXG4gICAgICAgIGZvbnRTaXplOiAyNCxcbiAgICAgICAgZm9udFdlaWdodDogNTAwLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiXG4gICAgfSxcbiAgICBoMjoge1xuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgbGluZUhlaWdodDogXCIyOHB4XCJcbiAgICB9LFxuICAgIHdyYXA6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgIH1cbn07XG5jbGFzcyBFcnJvciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUsIHdpdGhEYXJrTW9kZSA9IHRydWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5wcm9wcy50aXRsZSB8fCBzdGF0dXNDb2Rlc1tzdGF0dXNDb2RlXSB8fCBcIkFuIHVuZXhwZWN0ZWQgZXJyb3IgaGFzIG9jY3VycmVkXCI7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcImRpdlwiLCB7XG4gICAgICAgICAgICBzdHlsZTogc3R5bGVzLmVycm9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9oZWFkLmRlZmF1bHQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJ0aXRsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogc3RhdHVzQ29kZSA/IHN0YXR1c0NvZGUgKyBcIjogXCIgKyB0aXRsZSA6IFwiQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZFwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVzLmRlc2MsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwic3R5bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENTUyBtaW5pZmllZCBmcm9tXG4gICAgICAgICAgICAgICAgYm9keSB7IG1hcmdpbjogMDsgY29sb3I6ICMwMDA7IGJhY2tncm91bmQ6ICNmZmY7IH1cbiAgICAgICAgICAgICAgICAubmV4dC1lcnJvci1oMSB7XG4gICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIC4zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgd2l0aERhcmtNb2RlXG4gICAgICAgICAgICAgICAgICAgID8gYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcbiAgICAgICAgICAgICAgICAgIGJvZHkgeyBjb2xvcjogI2ZmZjsgYmFja2dyb3VuZDogIzAwMDsgfVxuICAgICAgICAgICAgICAgICAgLm5leHQtZXJyb3ItaDEge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgKi8gX19odG1sOiBcImJvZHl7Y29sb3I6IzAwMDtiYWNrZ3JvdW5kOiNmZmY7bWFyZ2luOjB9Lm5leHQtZXJyb3ItaDF7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDAsMCwwLC4zKX1cIiArICh3aXRoRGFya01vZGUgPyBcIkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ZGFyayl7Ym9keXtjb2xvcjojZmZmO2JhY2tncm91bmQ6IzAwMH0ubmV4dC1lcnJvci1oMXtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsLjMpfX1cIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImgxXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibmV4dC1lcnJvci1oMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZXMuaDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHN0YXR1c0NvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZXMud3JhcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoXCJoMlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZXMuaDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnRpdGxlIHx8IHN0YXR1c0NvZGUgPyB0aXRsZSA6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkIChzZWUgdGhlIGJyb3dzZXIgY29uc29sZSBmb3IgbW9yZSBpbmZvcm1hdGlvbilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG59XG5FcnJvci5kaXNwbGF5TmFtZSA9IFwiRXJyb3JQYWdlXCI7XG5FcnJvci5nZXRJbml0aWFsUHJvcHMgPSBfZ2V0SW5pdGlhbFByb3BzO1xuRXJyb3Iub3JpZ0dldEluaXRpYWxQcm9wcyA9IF9nZXRJbml0aWFsUHJvcHM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9lcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiRXJyb3IiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX2hlYWQiLCJzdGF0dXNDb2RlcyIsIl9nZXRJbml0aWFsUHJvcHMiLCJwYXJhbSIsInJlcyIsImVyciIsInN0YXR1c0NvZGUiLCJzdHlsZXMiLCJlcnJvciIsImZvbnRGYW1pbHkiLCJoZWlnaHQiLCJ0ZXh0QWxpZ24iLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImRlc2MiLCJsaW5lSGVpZ2h0IiwiaDEiLCJtYXJnaW4iLCJwYWRkaW5nUmlnaHQiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJ2ZXJ0aWNhbEFsaWduIiwiaDIiLCJ3cmFwIiwiZGVmYXVsdCIsIkNvbXBvbmVudCIsInJlbmRlciIsIndpdGhEYXJrTW9kZSIsInByb3BzIiwidGl0bGUiLCJqc3hzIiwic3R5bGUiLCJjaGlsZHJlbiIsImpzeCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiY2xhc3NOYW1lIiwiRnJhZ21lbnQiLCJkaXNwbGF5TmFtZSIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/pages/_error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsaUlBQXlDO0FBQ2xGLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsb0ZBQU87QUFDdkUsTUFBTUYsa0JBQWtCRyxPQUFPRSxPQUFPLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGdCQUFnQlEsV0FBVyxHQUFHO0FBQ2xDLEVBRUEsc0RBQXNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/NGFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFtcFN0YXRlQ29udGV4dFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQW1wU3RhdGVDb250ZXh0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IEFtcFN0YXRlQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQW1wU3RhdGVDb250ZXh0XCI7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJBbXBTdGF0ZUNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsImRlZmF1bHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js":
/*!********************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/amp-mode.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILCtDQUE4QztJQUMxQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLFlBQVlDLEtBQUs7SUFDdEIsSUFBSSxFQUFFQyxXQUFXLEtBQUssRUFBRUMsU0FBUyxLQUFLLEVBQUVDLFdBQVcsS0FBSyxFQUFFLEdBQUdILFVBQVUsS0FBSyxJQUFJLENBQUMsSUFBSUE7SUFDckYsT0FBT0MsWUFBWUMsVUFBVUM7QUFDakMsRUFFQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcz81N2E0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJbkFtcE1vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5BbXBNb2RlO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gaXNJbkFtcE1vZGUocGFyYW0pIHtcbiAgICBsZXQgeyBhbXBGaXJzdCA9IGZhbHNlLCBoeWJyaWQgPSBmYWxzZSwgaGFzUXVlcnkgPSBmYWxzZSB9ID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW07XG4gICAgcmV0dXJuIGFtcEZpcnN0IHx8IGh5YnJpZCAmJiBoYXNRdWVyeTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1wLW1vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImlzSW5BbXBNb2RlIiwicGFyYW0iLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js":
/*!****************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/head.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    defaultHead: function() {\n        return defaultHead;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGFBQWE7UUFDVCxPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPTztJQUNYO0FBQ0o7QUFDQSxNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGlJQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLG1JQUEwQztBQUNwRixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxzR0FBbUI7QUFDL0MsTUFBTUcsU0FBUyxXQUFXLEdBQUdGLDBCQUEwQkcsQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxvRkFBTztBQUN4RSxNQUFNSyxjQUFjLFdBQVcsR0FBR04seUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLDhGQUFlO0FBQ3BGLE1BQU1NLDJCQUEyQk4sbUJBQU9BLENBQUMsNEhBQThCO0FBQ3ZFLE1BQU1PLG1DQUFtQ1AsbUJBQU9BLENBQUMsOElBQXVDO0FBQ3hGLE1BQU1RLFdBQVdSLG1CQUFPQSxDQUFDLHdGQUFZO0FBQ3JDLE1BQU1TLFlBQVlULG1CQUFPQSxDQUFDLHNHQUFtQjtBQUM3QyxTQUFTVixZQUFZb0IsU0FBUztJQUMxQixJQUFJQSxjQUFjLEtBQUssR0FBR0EsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO1FBQ1QsV0FBVyxHQUFJLElBQUdULFlBQVlVLEdBQUcsRUFBRSxRQUFRO1lBQ3ZDQyxTQUFTO1FBQ2I7S0FDSDtJQUNELElBQUksQ0FBQ0gsV0FBVztRQUNaQyxLQUFLRyxJQUFJLENBQWUsV0FBSCxHQUFJLElBQUdaLFlBQVlVLEdBQUcsRUFBRSxRQUFRO1lBQ2pEakIsTUFBTTtZQUNOb0IsU0FBUztRQUNiO0lBQ0o7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsU0FBU0ssaUJBQWlCQyxJQUFJLEVBQUVDLEtBQUs7SUFDakMsOEZBQThGO0lBQzlGLElBQUksT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsVUFBVTtRQUN4RCxPQUFPRDtJQUNYO0lBQ0Esa0NBQWtDO0lBQ2xDLElBQUlDLE1BQU1DLElBQUksS0FBS2hCLE9BQU9aLE9BQU8sQ0FBQzZCLFFBQVEsRUFBRTtRQUN4QyxPQUFPSCxLQUFLSSxNQUFNLENBQ2xCbEIsT0FBT1osT0FBTyxDQUFDK0IsUUFBUSxDQUFDQyxPQUFPLENBQUNMLE1BQU1NLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQzVELENBQUNDLGNBQWNDO1lBQ1gsSUFBSSxPQUFPQSxrQkFBa0IsWUFBWSxPQUFPQSxrQkFBa0IsVUFBVTtnQkFDeEUsT0FBT0Q7WUFDWDtZQUNBLE9BQU9BLGFBQWFOLE1BQU0sQ0FBQ087UUFDL0IsR0FBRyxFQUFFO0lBQ1Q7SUFDQSxPQUFPWCxLQUFLSSxNQUFNLENBQUNIO0FBQ3ZCO0FBQ0EsTUFBTVcsWUFBWTtJQUNkO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDs7OztBQUlBLEdBQUcsU0FBU0M7SUFDUixNQUFNQyxPQUFPLElBQUlDO0lBQ2pCLE1BQU1DLE9BQU8sSUFBSUQ7SUFDakIsTUFBTUUsWUFBWSxJQUFJRjtJQUN0QixNQUFNRyxpQkFBaUIsQ0FBQztJQUN4QixPQUFPLENBQUNDO1FBQ0osSUFBSUMsV0FBVztRQUNmLElBQUlDLFNBQVM7UUFDYixJQUFJRixFQUFFRyxHQUFHLElBQUksT0FBT0gsRUFBRUcsR0FBRyxLQUFLLFlBQVlILEVBQUVHLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLE9BQU8sR0FBRztZQUM5REYsU0FBUztZQUNULE1BQU1DLE1BQU1ILEVBQUVHLEdBQUcsQ0FBQ0UsS0FBSyxDQUFDTCxFQUFFRyxHQUFHLENBQUNDLE9BQU8sQ0FBQyxPQUFPO1lBQzdDLElBQUlULEtBQUtXLEdBQUcsQ0FBQ0gsTUFBTTtnQkFDZkYsV0FBVztZQUNmLE9BQU87Z0JBQ0hOLEtBQUtZLEdBQUcsQ0FBQ0o7WUFDYjtRQUNKO1FBQ0Esd0NBQXdDO1FBQ3hDLE9BQU9ILEVBQUVqQixJQUFJO1lBQ1QsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsSUFBSWMsS0FBS1MsR0FBRyxDQUFDTixFQUFFakIsSUFBSSxHQUFHO29CQUNsQmtCLFdBQVc7Z0JBQ2YsT0FBTztvQkFDSEosS0FBS1UsR0FBRyxDQUFDUCxFQUFFakIsSUFBSTtnQkFDbkI7Z0JBQ0E7WUFDSixLQUFLO2dCQUNELElBQUksSUFBSXlCLElBQUksR0FBR0MsTUFBTWhCLFVBQVVpQixNQUFNLEVBQUVGLElBQUlDLEtBQUtELElBQUk7b0JBQ2hELE1BQU1HLFdBQVdsQixTQUFTLENBQUNlLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1IsRUFBRVosS0FBSyxDQUFDd0IsY0FBYyxDQUFDRCxXQUFXO29CQUN2QyxJQUFJQSxhQUFhLFdBQVc7d0JBQ3hCLElBQUliLFVBQVVRLEdBQUcsQ0FBQ0ssV0FBVzs0QkFDekJWLFdBQVc7d0JBQ2YsT0FBTzs0QkFDSEgsVUFBVVMsR0FBRyxDQUFDSTt3QkFDbEI7b0JBQ0osT0FBTzt3QkFDSCxNQUFNRSxXQUFXYixFQUFFWixLQUFLLENBQUN1QixTQUFTO3dCQUNsQyxNQUFNRyxhQUFhZixjQUFjLENBQUNZLFNBQVMsSUFBSSxJQUFJZjt3QkFDbkQsSUFBSSxDQUFDZSxhQUFhLFVBQVUsQ0FBQ1QsTUFBSyxLQUFNWSxXQUFXUixHQUFHLENBQUNPLFdBQVc7NEJBQzlEWixXQUFXO3dCQUNmLE9BQU87NEJBQ0hhLFdBQVdQLEdBQUcsQ0FBQ007NEJBQ2ZkLGNBQWMsQ0FBQ1ksU0FBUyxHQUFHRzt3QkFDL0I7b0JBQ0o7Z0JBQ0o7Z0JBQ0E7UUFDUjtRQUNBLE9BQU9iO0lBQ1g7QUFDSjtBQUNBOzs7Q0FHQyxHQUFHLFNBQVNjLGlCQUFpQkMsb0JBQW9CLEVBQUU1QixLQUFLO0lBQ3JELE1BQU0sRUFBRWQsU0FBUyxFQUFFLEdBQUdjO0lBQ3RCLE9BQU80QixxQkFBcUIxQixNQUFNLENBQUNWLGtCQUFrQixFQUFFLEVBQUVxQyxPQUFPLEdBQUdoQyxNQUFNLENBQUMvQixZQUFZb0IsV0FBVzJDLE9BQU8sSUFBSUMsTUFBTSxDQUFDeEIsVUFBVXVCLE9BQU8sR0FBR0UsR0FBRyxDQUFDLENBQUNDLEdBQUdaO1FBQzNJLE1BQU1MLE1BQU1pQixFQUFFakIsR0FBRyxJQUFJSztRQUNyQixJQUFJYSxLQUF5Ri9DLEVBQUUsRUFlOUY7UUFDRCxJQUFJK0MsSUFBc0MsRUFBRTtZQUN4Qyx5REFBeUQ7WUFDekQsSUFBSUQsRUFBRXJDLElBQUksS0FBSyxZQUFZcUMsRUFBRWhDLEtBQUssQ0FBQyxPQUFPLEtBQUssdUJBQXVCO2dCQUNsRSxNQUFNMEMsYUFBYVYsRUFBRWhDLEtBQUssQ0FBQyxNQUFNLEdBQUcsNEJBQTRCZ0MsRUFBRWhDLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTTtnQkFDdEYsSUFBR2YsVUFBVTBELFFBQVEsRUFBRSxtREFBbURELGFBQWE7WUFDNUYsT0FBTyxJQUFJVixFQUFFckMsSUFBSSxLQUFLLFVBQVVxQyxFQUFFaEMsS0FBSyxDQUFDLE1BQU0sS0FBSyxjQUFjO2dCQUM1RCxJQUFHZixVQUFVMEQsUUFBUSxFQUFFLHdGQUF3RlgsRUFBRWhDLEtBQUssQ0FBQyxPQUFPLEdBQUc7WUFDdEk7UUFDSjtRQUNBLE9BQU8sV0FBVyxHQUFHckIsT0FBT1osT0FBTyxDQUFDMEUsWUFBWSxDQUFDVCxHQUFHO1lBQ2hEakI7UUFDSjtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FBRyxTQUFTNkIsS0FBS0MsS0FBSztJQUNuQixJQUFJLEVBQUU1QyxRQUFRLEVBQUUsR0FBRzRDO0lBQ25CLE1BQU1DLFdBQVcsQ0FBQyxHQUFHbkUsT0FBT29FLFVBQVUsRUFBRWpFLHlCQUF5QmtFLGVBQWU7SUFDaEYsTUFBTUMsY0FBYyxDQUFDLEdBQUd0RSxPQUFPb0UsVUFBVSxFQUFFaEUsaUNBQWlDbUUsa0JBQWtCO0lBQzlGLE9BQXFCLFdBQUgsR0FBSSxJQUFHeEUsWUFBWVUsR0FBRyxFQUFFUCxZQUFZZCxPQUFPLEVBQUU7UUFDM0RvRix5QkFBeUJ4QjtRQUN6QnNCLGFBQWFBO1FBQ2IvRCxXQUFXLENBQUMsR0FBR0YsU0FBU29FLFdBQVcsRUFBRU47UUFDckM3QyxVQUFVQTtJQUNkO0FBQ0o7S0FWYTJDO0FBV2IsTUFBTXRFLFdBQVdzRTtBQUVqQixJQUFJLENBQUMsT0FBT2pGLFFBQVFJLE9BQU8sS0FBSyxjQUFlLE9BQU9KLFFBQVFJLE9BQU8sS0FBSyxZQUFZSixRQUFRSSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9KLFFBQVFJLE9BQU8sQ0FBQ3NGLFVBQVUsS0FBSyxhQUFhO0lBQ3JLNUYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSSxPQUFPLEVBQUUsY0FBYztRQUFFSCxPQUFPO0lBQUs7SUFDbkVILE9BQU82RixNQUFNLENBQUMzRixRQUFRSSxPQUFPLEVBQUVKO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFJLE9BQU87QUFDbEMsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzP2Y5ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdEhlYWQ6IG51bGwsXG4gICAgZGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBkZWZhdWx0SGVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SGVhZDtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3NpZGVlZmZlY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3NpZGUtZWZmZWN0XCIpKTtcbmNvbnN0IF9hbXBjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9hbXBtb2RlID0gcmVxdWlyZShcIi4vYW1wLW1vZGVcIik7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi91dGlscy93YXJuLW9uY2VcIik7XG5mdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUpIHtcbiAgICBpZiAoaW5BbXBNb2RlID09PSB2b2lkIDApIGluQW1wTW9kZSA9IGZhbHNlO1xuICAgIGNvbnN0IGhlYWQgPSBbXG4gICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICAgICAgICB9KVxuICAgIF07XG4gICAgaWYgKCFpbkFtcE1vZGUpIHtcbiAgICAgICAgaGVhZC5wdXNoKC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIG5hbWU6IFwidmlld3BvcnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoXCJcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZDtcbn1cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQobGlzdCwgY2hpbGQpIHtcbiAgICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdCgvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgICAoZnJhZ21lbnRMaXN0LCBmcmFnbWVudENoaWxkKT0+e1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcmFnbWVudENoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBmcmFnbWVudENoaWxkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpO1xuICAgICAgICB9LCBbXSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpO1xufVxuY29uc3QgTUVUQVRZUEVTID0gW1xuICAgIFwibmFtZVwiLFxuICAgIFwiaHR0cEVxdWl2XCIsXG4gICAgXCJjaGFyU2V0XCIsXG4gICAgXCJpdGVtUHJvcFwiXG5dO1xuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovIGZ1bmN0aW9uIHVuaXF1ZSgpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgbWV0YVR5cGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFDYXRlZ29yaWVzID0ge307XG4gICAgcmV0dXJuIChoKT0+e1xuICAgICAgICBsZXQgaXNVbmlxdWUgPSB0cnVlO1xuICAgICAgICBsZXQgaGFzS2V5ID0gZmFsc2U7XG4gICAgICAgIGlmIChoLmtleSAmJiB0eXBlb2YgaC5rZXkgIT09IFwibnVtYmVyXCIgJiYgaC5rZXkuaW5kZXhPZihcIiRcIikgPiAwKSB7XG4gICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZihcIiRcIikgKyAxKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgICAgIHN3aXRjaChoLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5hZGQoaC50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDAsIGxlbiA9IE1FVEFUWVBFUy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGF0eXBlID0gTUVUQVRZUEVTW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGF0eXBlID09PSBcImNoYXJTZXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVR5cGVzLmFkZChtZXRhdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSB8fCBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1ldGF0eXBlICE9PSBcIm5hbWVcIiB8fCAhaGFzS2V5KSAmJiBjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNVbmlxdWU7XG4gICAgfTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovIGZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoaGVhZENoaWxkcmVuRWxlbWVudHMsIHByb3BzKSB7XG4gICAgY29uc3QgeyBpbkFtcE1vZGUgfSA9IHByb3BzO1xuICAgIHJldHVybiBoZWFkQ2hpbGRyZW5FbGVtZW50cy5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pLnJldmVyc2UoKS5jb25jYXQoZGVmYXVsdEhlYWQoaW5BbXBNb2RlKS5yZXZlcnNlKCkpLmZpbHRlcih1bmlxdWUoKSkucmV2ZXJzZSgpLm1hcCgoYywgaSk9PntcbiAgICAgICAgY29uc3Qga2V5ID0gYy5rZXkgfHwgaTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmICFpbkFtcE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09IFwibGlua1wiICYmIGMucHJvcHNbXCJocmVmXCJdICYmIC8vIFRPRE8ocHJhdGVla2JoQCk6IFJlcGxhY2UgdGhpcyB3aXRoIGNvbnN0IGZyb20gYGNvbnN0YW50c2Agd2hlbiB0aGUgdHJlZSBzaGFraW5nIHdvcmtzLlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3NcIixcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vdXNlLnR5cGVraXQubmV0L1wiXG4gICAgICAgICAgICBdLnNvbWUoKHVybCk9PmMucHJvcHNbXCJocmVmXCJdLnN0YXJ0c1dpdGgodXJsKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5wcm9wcyB8fCB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJkYXRhLWhyZWZcIl0gPSBuZXdQcm9wc1tcImhyZWZcIl07XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJocmVmXCJdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGF0dHJpYnV0ZSB0byBtYWtlIGl0IGVhc3kgdG8gaWRlbnRpZnkgb3B0aW1pemVkIHRhZ3NcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImRhdGEtb3B0aW1pemVkLWZvbnRzXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoYywgbmV3UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICAvLyBvbWl0IEpTT04tTEQgc3RydWN0dXJlZCBkYXRhIHNuaXBwZXRzIGZyb20gdGhlIHdhcm5pbmdcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09IFwic2NyaXB0XCIgJiYgYy5wcm9wc1tcInR5cGVcIl0gIT09IFwiYXBwbGljYXRpb24vbGQranNvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjTWVzc2FnZSA9IGMucHJvcHNbXCJzcmNcIl0gPyAnPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJyArIGMucHJvcHNbXCJzcmNcIl0gKyAnXCInIDogXCJpbmxpbmUgPHNjcmlwdD5cIjtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKShcIkRvIG5vdCBhZGQgPHNjcmlwdD4gdGFncyB1c2luZyBuZXh0L2hlYWQgKHNlZSBcIiArIHNyY01lc3NhZ2UgKyBcIikuIFVzZSBuZXh0L3NjcmlwdCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXNjcmlwdC10YWdzLWluLWhlYWQtY29tcG9uZW50XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09IFwibGlua1wiICYmIGMucHJvcHNbXCJyZWxcIl0gPT09IFwic3R5bGVzaGVldFwiKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0RvIG5vdCBhZGQgc3R5bGVzaGVldHMgdXNpbmcgbmV4dC9oZWFkIChzZWUgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiPiB0YWcgd2l0aCBocmVmPVwiJyArIGMucHJvcHNbXCJocmVmXCJdICsgJ1wiKS4gVXNlIERvY3VtZW50IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc3R5bGVzaGVldHMtaW4taGVhZC1jb21wb25lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoYywge1xuICAgICAgICAgICAga2V5XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqLyBmdW5jdGlvbiBIZWFkKHBhcmFtKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIGNvbnN0IGFtcFN0YXRlID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUuQW1wU3RhdGVDb250ZXh0KTtcbiAgICBjb25zdCBoZWFkTWFuYWdlciA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2hlYWRtYW5hZ2VyY29udGV4dHNoYXJlZHJ1bnRpbWUuSGVhZE1hbmFnZXJDb250ZXh0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfc2lkZWVmZmVjdC5kZWZhdWx0LCB7XG4gICAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlOiByZWR1Y2VDb21wb25lbnRzLFxuICAgICAgICBoZWFkTWFuYWdlcjogaGVhZE1hbmFnZXIsXG4gICAgICAgIGluQW1wTW9kZTogKDAsIF9hbXBtb2RlLmlzSW5BbXBNb2RlKShhbXBTdGF0ZSksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuY29uc3QgX2RlZmF1bHQgPSBIZWFkO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImRlZmF1bHRIZWFkIiwiZGVmYXVsdCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfc2lkZWVmZmVjdCIsIl9hbXBjb250ZXh0c2hhcmVkcnVudGltZSIsIl9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FtcG1vZGUiLCJfd2Fybm9uY2UiLCJpbkFtcE1vZGUiLCJoZWFkIiwianN4IiwiY2hhclNldCIsInB1c2giLCJjb250ZW50Iiwib25seVJlYWN0RWxlbWVudCIsImxpc3QiLCJjaGlsZCIsInR5cGUiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX09QVElNSVpFX0ZPTlRTIiwic29tZSIsInVybCIsInN0YXJ0c1dpdGgiLCJuZXdQcm9wcyIsInVuZGVmaW5lZCIsImNsb25lRWxlbWVudCIsInNyY01lc3NhZ2UiLCJ3YXJuT25jZSIsIkhlYWQiLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js":
/*!***********************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/side-effect.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsb0ZBQU87QUFDOUIsTUFBTUMsV0FBVyxPQUFPQyxXQUFXO0FBQ25DLE1BQU1DLDRCQUE0QkYsV0FBVyxLQUFLLElBQUlGLE9BQU9LLGVBQWU7QUFDNUUsTUFBTUMsc0JBQXNCSixXQUFXLEtBQUssSUFBSUYsT0FBT08sU0FBUztBQUNoRSxTQUFTUixXQUFXUyxLQUFLOztJQUNyQixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFDakQsU0FBU0c7UUFDTCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUM3QyxNQUFNQyxlQUFlYixPQUFPYyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBRU0sTUFBTSxDQUFDQztZQUM3RlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQ2pFO0lBQ0o7SUFDQSxJQUFJTixVQUFVO1FBQ1YsSUFBSW1CO1FBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCQyxHQUFHLENBQUNkLE1BQU1lLFFBQVE7UUFDaktaO0lBQ0o7SUFDQVAsMEJBQTBCO1FBQ3RCLElBQUlpQjtRQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkMsR0FBRyxDQUFDZCxNQUFNZSxRQUFRO1FBQ2pLLE9BQU87WUFDSCxJQUFJRjtZQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkcsTUFBTSxDQUFDaEIsTUFBTWUsUUFBUTtRQUN4SztJQUNKO0lBQ0Esa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRm5CLDBCQUEwQjtRQUN0QixJQUFJSyxhQUFhO1lBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1FBQ2pDO1FBQ0EsT0FBTztZQUNILElBQUlGLGFBQWE7Z0JBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBTCxvQkFBb0I7UUFDaEIsSUFBSUcsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtZQUMzQ2hCLFlBQVlnQixjQUFjO1lBQzFCaEIsWUFBWWdCLGNBQWMsR0FBRztRQUNqQztRQUNBLE9BQU87WUFDSCxJQUFJaEIsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtnQkFDM0NoQixZQUFZZ0IsY0FBYztnQkFDMUJoQixZQUFZZ0IsY0FBYyxHQUFHO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWCxFQUVBLHVDQUF1QztHQW5EOUIxQjs7UUFhTEs7UUFhQUE7UUFVQUU7OztLQXBDS1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcz9mNDdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU2lkZUVmZmVjdDtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QgPSBpc1NlcnZlciA/ICgpPT57fSA6IF9yZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG5jb25zdCB1c2VDbGllbnRPbmx5RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKT0+e30gOiBfcmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wcykge1xuICAgIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wcztcbiAgICBmdW5jdGlvbiBlbWl0Q2hhbmdlKCkge1xuICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykge1xuICAgICAgICAgICAgY29uc3QgaGVhZEVsZW1lbnRzID0gX3JlYWN0LkNoaWxkcmVuLnRvQXJyYXkoQXJyYXkuZnJvbShoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKS5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU2VydmVyKSB7XG4gICAgICAgIHZhciBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcztcbiAgICAgICAgaGVhZE1hbmFnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcyA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcy5hZGQocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICBlbWl0Q2hhbmdlKCk7XG4gICAgfVxuICAgIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgdmFyIF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmFkZChwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdmFyIF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzO1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcyA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZE1hbmFnZXJfbW91bnRlZEluc3RhbmNlcy5kZWxldGUocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFdlIG5lZWQgdG8gY2FsbCBgdXBkYXRlSGVhZGAgbWV0aG9kIHdoZW5ldmVyIHRoZSBgU2lkZUVmZmVjdGAgaXMgdHJpZ2dlciBpbiBhbGxcbiAgICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgICAvLyBiZWluZyByZW5kZXJlZCwgd2Ugb25seSB0cmlnZ2VyIHRoZSBtZXRob2QgZnJvbSB0aGUgbGFzdCBvbmUuXG4gICAgLy8gVGhpcyBpcyBlbnN1cmVkIGJ5IGtlZXBpbmcgdGhlIGxhc3QgdW5mbHVzaGVkIGB1cGRhdGVIZWFkYCBpbiB0aGUgYF9wZW5kaW5nVXBkYXRlYFxuICAgIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gICAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gZW1pdENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gZW1pdENoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB1c2VDbGllbnRPbmx5RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWRlLWVmZmVjdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiU2lkZUVmZmVjdCIsIl9yZWFjdCIsInJlcXVpcmUiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsIl9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzIiwiYWRkIiwiY2hpbGRyZW4iLCJkZWxldGUiLCJfcGVuZGluZ1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsdUdBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnSEFBZ0g7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMkRBQTJELFVBQVU7QUFDckUseUJBQXlCLFVBQVU7QUFDbkM7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLEdBQUc7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzP2Q0MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlO1xuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpOyAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEpIHtcbiAgICAgIC8vIFRPRE86IENyZWF0ZSBhIGNvbnZlbnRpb24gZm9yIG5hbWluZyBjbGllbnQgcmVmZXJlbmNlcyB3aXRoIGRlYnVnIGluZm8uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWJDEodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWJDEodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViA9IGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFVjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*******************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsK0xBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz8wZTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/asyncContext/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAsyncContextStrategy: function() { return /* binding */ getAsyncContextStrategy; },\n/* harmony export */   setAsyncContextStrategy: function() { return /* binding */ setAsyncContextStrategy; }\n/* harmony export */ });\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n/* harmony import */ var _stackStrategy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stackStrategy.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js\");\n\n\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nfunction setAsyncContextStrategy(strategy) {\n  // Get main carrier (global for every environment)\n  const registry = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getMainCarrier)();\n  const sentry = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getSentryCarrier)(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nfunction getAsyncContextStrategy(carrier) {\n  const sentry = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getSentryCarrier)(carrier);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return (0,_stackStrategy_js__WEBPACK_IMPORTED_MODULE_1__.getStackAsyncContextStrategy)();\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9hc3luY0NvbnRleHQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRTtBQUNDOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBYztBQUNqQyxpQkFBaUIsNkRBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBZ0I7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsK0VBQTRCO0FBQ3JDOztBQUU0RDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vYXN5bmNDb250ZXh0L2luZGV4LmpzP2U4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TWFpbkNhcnJpZXIsIGdldFNlbnRyeUNhcnJpZXIgfSBmcm9tICcuLi9jYXJyaWVyLmpzJztcbmltcG9ydCB7IGdldFN0YWNrQXN5bmNDb250ZXh0U3RyYXRlZ3kgfSBmcm9tICcuL3N0YWNrU3RyYXRlZ3kuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlIFByaXZhdGUgQVBJIHdpdGggbm8gc2VtdmVyIGd1YXJhbnRlZXMhXG4gKlxuICogU2V0cyB0aGUgZ2xvYmFsIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3lcbiAqL1xuZnVuY3Rpb24gc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgLy8gR2V0IG1haW4gY2FycmllciAoZ2xvYmFsIGZvciBldmVyeSBlbnZpcm9ubWVudClcbiAgY29uc3QgcmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBzZW50cnkgPSBnZXRTZW50cnlDYXJyaWVyKHJlZ2lzdHJ5KTtcbiAgc2VudHJ5LmFjcyA9IHN0cmF0ZWd5O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBhc3luYyBjb250ZXh0IHN0cmF0ZWd5LlxuICogSWYgbm9uZSBoYXMgYmVlbiBzZXR1cCwgdGhlIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKSB7XG4gIGNvbnN0IHNlbnRyeSA9IGdldFNlbnRyeUNhcnJpZXIoY2Fycmllcik7XG5cbiAgaWYgKHNlbnRyeS5hY3MpIHtcbiAgICByZXR1cm4gc2VudHJ5LmFjcztcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBkZWZhdWx0IG9uZSAoc3RhY2spXG4gIHJldHVybiBnZXRTdGFja0FzeW5jQ29udGV4dFN0cmF0ZWd5KCk7XG59XG5cbmV4cG9ydCB7IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5LCBzZXRBc3luY0NvbnRleHRTdHJhdGVneSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncContextStack: function() { return /* binding */ AsyncContextStack; },\n/* harmony export */   getStackAsyncContextStrategy: function() { return /* binding */ getStackAsyncContextStrategy; }\n/* harmony export */ });\n/* harmony import */ var _defaultScopes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../defaultScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/defaultScopes.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js\");\n/* harmony import */ var _utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils-hoist/is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n\n\n\n\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__.Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__.Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if ((0,_utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_1__.isThenable)(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_2__.getMainCarrier)();\n  const sentry = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_2__.getSentryCarrier)(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack((0,_defaultScopes_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultCurrentScope)(), (0,_defaultScopes_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultIsolationScope)()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack() ;\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\n\n//# sourceMappingURL=stackStrategy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9hc3luY0NvbnRleHQvc3RhY2tTdHJhdGVneS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUY7QUFDbkQ7QUFDYztBQUNlOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQUs7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyw0Q0FBSztBQUN4QyxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFjO0FBQ2pDLGlCQUFpQiw2REFBZ0I7O0FBRWpDLCtEQUErRCx5RUFBc0IsSUFBSSwyRUFBd0I7QUFDakg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUUyRDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vYXN5bmNDb250ZXh0L3N0YWNrU3RyYXRlZ3kuanM/ZDIyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREZWZhdWx0Q3VycmVudFNjb3BlLCBnZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUgfSBmcm9tICcuLi9kZWZhdWx0U2NvcGVzLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi4vc2NvcGUuanMnO1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L2lzLmpzJztcbmltcG9ydCB7IGdldE1haW5DYXJyaWVyLCBnZXRTZW50cnlDYXJyaWVyIH0gZnJvbSAnLi4vY2Fycmllci5qcyc7XG5cbi8qKlxuICogVGhpcyBpcyBhbiBvYmplY3QgdGhhdCBob2xkcyBhIHN0YWNrIG9mIHNjb3Blcy5cbiAqL1xuY2xhc3MgQXN5bmNDb250ZXh0U3RhY2sge1xuXG4gICBjb25zdHJ1Y3RvcihzY29wZSwgaXNvbGF0aW9uU2NvcGUpIHtcbiAgICBsZXQgYXNzaWduZWRTY29wZTtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBhc3NpZ25lZFNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbmVkU2NvcGUgPSBzY29wZTtcbiAgICB9XG5cbiAgICBsZXQgYXNzaWduZWRJc29sYXRpb25TY29wZTtcbiAgICBpZiAoIWlzb2xhdGlvblNjb3BlKSB7XG4gICAgICBhc3NpZ25lZElzb2xhdGlvblNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbmVkSXNvbGF0aW9uU2NvcGUgPSBpc29sYXRpb25TY29wZTtcbiAgICB9XG5cbiAgICAvLyBzY29wZSBzdGFjayBmb3IgZG9tYWlucyBvciB0aGUgcHJvY2Vzc1xuICAgIHRoaXMuX3N0YWNrID0gW3sgc2NvcGU6IGFzc2lnbmVkU2NvcGUgfV07XG4gICAgdGhpcy5faXNvbGF0aW9uU2NvcGUgPSBhc3NpZ25lZElzb2xhdGlvblNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmsgYSBzY29wZSBmb3IgdGhlIHN0YWNrLlxuICAgKi9cbiAgIHdpdGhTY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5fcHVzaFNjb3BlKCk7XG5cbiAgICBsZXQgbWF5YmVQcm9taXNlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjayhzY29wZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fcG9wU2NvcGUoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKGlzVGhlbmFibGUobWF5YmVQcm9taXNlUmVzdWx0KSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIGlzVGhlbmFibGUgcmV0dXJucyB0aGUgd3JvbmcgdHlwZVxuICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZVJlc3VsdC50aGVuKFxuICAgICAgICByZXMgPT4ge1xuICAgICAgICAgIHRoaXMuX3BvcFNjb3BlKCk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wU2NvcGUoKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3BTY29wZSgpO1xuICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgb2YgdGhlIHN0YWNrLlxuICAgKi9cbiAgIGdldENsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLmNsaWVudCA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NvcGUgb2YgdGhlIHRvcCBzdGFjay5cbiAgICovXG4gICBnZXRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaXNvbGF0aW9uIHNjb3BlIGZvciB0aGUgc3RhY2suXG4gICAqL1xuICAgZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzb2xhdGlvblNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3Qgc2NvcGUgbGF5ZXIgaW4gdGhlIG9yZGVyIGRvbWFpbiA+IGxvY2FsID4gcHJvY2Vzcy5cbiAgICovXG4gICBnZXRTdGFja1RvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0gO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBzY29wZSB0byB0aGUgc3RhY2suXG4gICAqL1xuICAgX3B1c2hTY29wZSgpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNsb25lIHRoZSBjb250ZW50IG9mIHByZXYgc2NvcGVcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuZ2V0U2NvcGUoKS5jbG9uZSgpO1xuICAgIHRoaXMuX3N0YWNrLnB1c2goe1xuICAgICAgY2xpZW50OiB0aGlzLmdldENsaWVudCgpLFxuICAgICAgc2NvcGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcCBhIHNjb3BlIGZyb20gdGhlIHN0YWNrLlxuICAgKi9cbiAgIF9wb3BTY29wZSgpIHtcbiAgICBpZiAodGhpcy5fc3RhY2subGVuZ3RoIDw9IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gISF0aGlzLl9zdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgZ2xvYmFsIGFzeW5jIGNvbnRleHQgc3RhY2suXG4gKiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBkdXJpbmcgdGhlIHY4IGN5Y2xlIGFuZCBpcyBvbmx5IGhlcmUgdG8gbWFrZSBtaWdyYXRpb24gZWFzaWVyLlxuICovXG5mdW5jdGlvbiBnZXRBc3luY0NvbnRleHRTdGFjaygpIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBzZW50cnkgPSBnZXRTZW50cnlDYXJyaWVyKHJlZ2lzdHJ5KTtcblxuICByZXR1cm4gKHNlbnRyeS5zdGFjayA9IHNlbnRyeS5zdGFjayB8fCBuZXcgQXN5bmNDb250ZXh0U3RhY2soZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLCBnZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUoKSkpO1xufVxuXG5mdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGdldEFzeW5jQ29udGV4dFN0YWNrKCkud2l0aFNjb3BlKGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gd2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjaykge1xuICBjb25zdCBzdGFjayA9IGdldEFzeW5jQ29udGV4dFN0YWNrKCkgO1xuICByZXR1cm4gc3RhY2sud2l0aFNjb3BlKCgpID0+IHtcbiAgICBzdGFjay5nZXRTdGFja1RvcCgpLnNjb3BlID0gc2NvcGU7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjaykge1xuICByZXR1cm4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS53aXRoU2NvcGUoKCkgPT4ge1xuICAgIHJldHVybiBjYWxsYmFjayhnZXRBc3luY0NvbnRleHRTdGFjaygpLmdldElzb2xhdGlvblNjb3BlKCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YWNrLWJhc2VkIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrQXN5bmNDb250ZXh0U3RyYXRlZ3koKSB7XG4gIHJldHVybiB7XG4gICAgd2l0aElzb2xhdGlvblNjb3BlLFxuICAgIHdpdGhTY29wZSxcbiAgICB3aXRoU2V0U2NvcGUsXG4gICAgd2l0aFNldElzb2xhdGlvblNjb3BlOiAoX2lzb2xhdGlvblNjb3BlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgcmV0dXJuIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjayk7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50U2NvcGU6ICgpID0+IGdldEFzeW5jQ29udGV4dFN0YWNrKCkuZ2V0U2NvcGUoKSxcbiAgICBnZXRJc29sYXRpb25TY29wZTogKCkgPT4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS5nZXRJc29sYXRpb25TY29wZSgpLFxuICB9O1xufVxuXG5leHBvcnQgeyBBc3luY0NvbnRleHRTdGFjaywgZ2V0U3RhY2tBc3luY0NvbnRleHRTdHJhdGVneSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2tTdHJhdGVneS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js":
/*!*********************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/carrier.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getGlobalSingleton: function() { return /* binding */ getGlobalSingleton; },\n/* harmony export */   getMainCarrier: function() { return /* binding */ getMainCarrier; },\n/* harmony export */   getSentryCarrier: function() { return /* binding */ getSentryCarrier; }\n/* harmony export */ });\n/* harmony import */ var _utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-hoist/version.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/version.js\");\n/* harmony import */ var _utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-hoist/worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(_utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ);\n  return _utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nfunction getSentryCarrier(carrier) {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || _utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[_utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION] = __SENTRY__[_utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(\n  name,\n  creator,\n  obj = _utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ,\n) {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[_utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION] = __SENTRY__[_utils_hoist_version_js__WEBPACK_IMPORTED_MODULE_1__.SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n\n\n//# sourceMappingURL=carrier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jYXJyaWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVEO0FBQ0M7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBVTtBQUM3QixTQUFTLGlFQUFVO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0EsNkNBQTZDLGdFQUFXOztBQUV4RDtBQUNBO0FBQ0EscUJBQXFCLGdFQUFXLGVBQWUsZ0VBQVcsT0FBTztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBVTtBQUNsQjtBQUNBLDJEQUEyRDtBQUMzRCw4QkFBOEIsZ0VBQVcsZUFBZSxnRUFBVyxPQUFPO0FBQzFFO0FBQ0E7QUFDQTs7QUFFZ0U7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2NhcnJpZXIuanM/ODA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTREtfVkVSU0lPTiB9IGZyb20gJy4vdXRpbHMtaG9pc3QvdmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi91dGlscy1ob2lzdC93b3JsZHdpZGUuanMnO1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGdsb2JhbGx5IGFjY2Vzc2libGUgcHJvcGVydGllcyBhbmQgbWFpbnRhaW5zIGEgc2NvcGUgc3RhY2suXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgc2hpbSByZWdpc3RyeS5cbiAqXG4gKiBGSVhNRTogVGhpcyBmdW5jdGlvbiBpcyBwcm9ibGVtYXRpYywgYmVjYXVzZSBkZXNwaXRlIGFsd2F5cyByZXR1cm5pbmcgYSB2YWxpZCBDYXJyaWVyLFxuICogaXQgaGFzIGFuIG9wdGlvbmFsIGBfX1NFTlRSWV9fYCBwcm9wZXJ0eSwgd2hpY2ggdGhlbiBpbiB0dXJuIHJlcXVpcmVzIHVzIHRvIGFsd2F5cyBwZXJmb3JtIGFuIHVubmVjZXNzYXJ5IGNoZWNrXG4gKiBhdCB0aGUgY2FsbC1zaXRlLiBXZSBhbHdheXMgYWNjZXNzIHRoZSBjYXJyaWVyIHRocm91Z2ggdGhpcyBmdW5jdGlvbiwgc28gd2UgY2FuIGd1YXJhbnRlZSB0aGF0IGBfX1NFTlRSWV9fYCBpcyB0aGVyZS5cbiAqKi9cbmZ1bmN0aW9uIGdldE1haW5DYXJyaWVyKCkge1xuICAvLyBUaGlzIGVuc3VyZXMgYSBTZW50cnkgY2FycmllciBleGlzdHNcbiAgZ2V0U2VudHJ5Q2FycmllcihHTE9CQUxfT0JKKTtcbiAgcmV0dXJuIEdMT0JBTF9PQko7XG59XG5cbi8qKiBXaWxsIGVpdGhlciBnZXQgdGhlIGV4aXN0aW5nIHNlbnRyeSBjYXJyaWVyLCBvciBjcmVhdGUgYSBuZXcgb25lLiAqL1xuZnVuY3Rpb24gZ2V0U2VudHJ5Q2FycmllcihjYXJyaWVyKSB7XG4gIGNvbnN0IF9fU0VOVFJZX18gPSAoY2Fycmllci5fX1NFTlRSWV9fID0gY2Fycmllci5fX1NFTlRSWV9fIHx8IHt9KTtcblxuICAvLyBGb3Igbm93OiBGaXJzdCBTREsgdGhhdCBzZXRzIHRoZSAudmVyc2lvbiBwcm9wZXJ0eSB3aW5zXG4gIF9fU0VOVFJZX18udmVyc2lvbiA9IF9fU0VOVFJZX18udmVyc2lvbiB8fCBTREtfVkVSU0lPTjtcblxuICAvLyBJbnRlbnRpb25hbGx5IHBvcHVsYXRpbmcgYW5kIHJldHVybmluZyB0aGUgdmVyc2lvbiBvZiBcInRoaXNcIiBTREsgaW5zdGFuY2VcbiAgLy8gcmF0aGVyIHRoYW4gd2hhdCdzIHNldCBpbiAudmVyc2lvbiBzbyB0aGF0IFwidGhpc1wiIFNESyBhbHdheXMgZ2V0cyBpdHMgY2FycmllclxuICByZXR1cm4gKF9fU0VOVFJZX19bU0RLX1ZFUlNJT05dID0gX19TRU5UUllfX1tTREtfVkVSU0lPTl0gfHwge30pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBnbG9iYWwgc2luZ2xldG9uIGNvbnRhaW5lZCBpbiB0aGUgZ2xvYmFsIGBfX1NFTlRSWV9fW11gIG9iamVjdC5cbiAqXG4gKiBJZiB0aGUgc2luZ2xldG9uIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBpbiBgX19TRU5UUllfX2AsIGl0IHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGUgZ2l2ZW4gZmFjdG9yeVxuICogZnVuY3Rpb24gYW5kIGFkZGVkIHRvIHRoZSBgX19TRU5UUllfX2Agb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGdsb2JhbCBzaW5nbGV0b24gb24gX19TRU5UUllfX1xuICogQHBhcmFtIGNyZWF0b3IgY3JlYXRvciBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBvbiBgX19TRU5UUllfX2BcbiAqIEBwYXJhbSBvYmogKE9wdGlvbmFsKSBUaGUgZ2xvYmFsIG9iamVjdCBvbiB3aGljaCB0byBsb29rIGZvciBgX19TRU5UUllfX2AsIGlmIG5vdCBgR0xPQkFMX09CSmAncyByZXR1cm4gdmFsdWVcbiAqIEByZXR1cm5zIHRoZSBzaW5nbGV0b25cbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2luZ2xldG9uKFxuICBuYW1lLFxuICBjcmVhdG9yLFxuICBvYmogPSBHTE9CQUxfT0JKLFxuKSB7XG4gIGNvbnN0IF9fU0VOVFJZX18gPSAob2JqLl9fU0VOVFJZX18gPSBvYmouX19TRU5UUllfXyB8fCB7fSk7XG4gIGNvbnN0IGNhcnJpZXIgPSAoX19TRU5UUllfX1tTREtfVkVSU0lPTl0gPSBfX1NFTlRSWV9fW1NES19WRVJTSU9OXSB8fCB7fSk7XG4gIC8vIE5vdGU6IFdlIGRvIG5vdCB3YW50IHRvIHNldCBgY2Fycmllci52ZXJzaW9uYCBoZXJlLCBhcyB0aGlzIG1heSBiZSBjYWxsZWQgYmVmb3JlIGFueSBgaW5pdGAgaXMgY2FsbGVkLCBlLmcuIGZvciB0aGUgZGVmYXVsdCBzY29wZXNcbiAgcmV0dXJuIGNhcnJpZXJbbmFtZV0gfHwgKGNhcnJpZXJbbmFtZV0gPSBjcmVhdG9yKCkpO1xufVxuXG5leHBvcnQgeyBnZXRHbG9iYWxTaW5nbGV0b24sIGdldE1haW5DYXJyaWVyLCBnZXRTZW50cnlDYXJyaWVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJyaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/constants.js":
/*!***********************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/constants.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_ENVIRONMENT: function() { return /* binding */ DEFAULT_ENVIRONMENT; }\n/* harmony export */ });\nconst DEFAULT_ENVIRONMENT = 'production';\n\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUUrQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vY29uc3RhbnRzLmpzPzM4MDkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9FTlZJUk9OTUVOVCA9ICdwcm9kdWN0aW9uJztcblxuZXhwb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js":
/*!***************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/currentScopes.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClient: function() { return /* binding */ getClient; },\n/* harmony export */   getCurrentScope: function() { return /* binding */ getCurrentScope; },\n/* harmony export */   getGlobalScope: function() { return /* binding */ getGlobalScope; },\n/* harmony export */   getIsolationScope: function() { return /* binding */ getIsolationScope; },\n/* harmony export */   getTraceContextFromScope: function() { return /* binding */ getTraceContextFromScope; },\n/* harmony export */   withIsolationScope: function() { return /* binding */ withIsolationScope; },\n/* harmony export */   withScope: function() { return /* binding */ withScope; }\n/* harmony export */ });\n/* harmony import */ var _asyncContext_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asyncContext/index.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/index.js\");\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js\");\n/* harmony import */ var _utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js\");\n\n\n\n\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getMainCarrier)();\n  const acs = (0,_asyncContext_index_js__WEBPACK_IMPORTED_MODULE_1__.getAsyncContextStrategy)(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getMainCarrier)();\n  const acs = (0,_asyncContext_index_js__WEBPACK_IMPORTED_MODULE_1__.getAsyncContextStrategy)(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalSingleton)('globalScope', () => new _scope_js__WEBPACK_IMPORTED_MODULE_2__.Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(\n  ...rest\n) {\n  const carrier = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getMainCarrier)();\n  const acs = (0,_asyncContext_index_js__WEBPACK_IMPORTED_MODULE_1__.getAsyncContextStrategy)(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(\n  ...rest\n\n) {\n  const carrier = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getMainCarrier)();\n  const acs = (0,_asyncContext_index_js__WEBPACK_IMPORTED_MODULE_1__.getAsyncContextStrategy)(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || (0,_utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_3__.generateSpanId)(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n\n\n//# sourceMappingURL=currentScopes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jdXJyZW50U2NvcGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWtFO0FBQ0E7QUFDL0I7QUFDa0M7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFjO0FBQ2hDLGNBQWMsK0VBQXVCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBYztBQUNoQyxjQUFjLCtFQUF1QjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFrQiwwQkFBMEIsNENBQUs7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQWM7QUFDaEMsY0FBYywrRUFBdUI7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkRBQWM7QUFDaEMsY0FBYywrRUFBdUI7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsMkNBQTJDOztBQUVyRDtBQUNBO0FBQ0Esa0NBQWtDLGtGQUFjO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVrSTtBQUNsSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vY3VycmVudFNjb3Blcy5qcz9hYzBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5IH0gZnJvbSAnLi9hc3luY0NvbnRleHQvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0TWFpbkNhcnJpZXIsIGdldEdsb2JhbFNpbmdsZXRvbiB9IGZyb20gJy4vY2Fycmllci5qcyc7XG5pbXBvcnQgeyBTY29wZSB9IGZyb20gJy4vc2NvcGUuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTcGFuSWQgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcyc7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIGNvbnN0IGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBhY3MgPSBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKTtcbiAgcmV0dXJuIGFjcy5nZXRDdXJyZW50U2NvcGUoKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXNvbGF0aW9uIHNjb3BlLlxuICogVGhlIGlzb2xhdGlvbiBzY29wZSBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRJc29sYXRpb25TY29wZSgpIHtcbiAgY29uc3QgY2FycmllciA9IGdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IGFjcyA9IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIpO1xuICByZXR1cm4gYWNzLmdldElzb2xhdGlvblNjb3BlKCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBUaGlzIHNjb3BlIGlzIGFwcGxpZWQgdG8gX2FsbF8gZXZlbnRzLlxuICovXG5mdW5jdGlvbiBnZXRHbG9iYWxTY29wZSgpIHtcbiAgcmV0dXJuIGdldEdsb2JhbFNpbmdsZXRvbignZ2xvYmFsU2NvcGUnLCAoKSA9PiBuZXcgU2NvcGUoKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzY29wZSB3aXRoIGFuZCBleGVjdXRlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIHdpdGhpbi5cbiAqIFRoZSBzY29wZSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgb25jZSB0aGUgb3BlcmF0aW9uXG4gKiBmaW5pc2hlcyBvciB0aHJvd3MuXG4gKi9cblxuLyoqXG4gKiBFaXRoZXIgY3JlYXRlcyBhIG5ldyBhY3RpdmUgc2NvcGUsIG9yIHNldHMgdGhlIGdpdmVuIHNjb3BlIGFzIGFjdGl2ZSBzY29wZSBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhTY29wZShcbiAgLi4ucmVzdFxuKSB7XG4gIGNvbnN0IGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBhY3MgPSBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKTtcblxuICAvLyBJZiBhIHNjb3BlIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gbWFrZSB0aGlzIHRoZSBhY3RpdmUgc2NvcGUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmVcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgW3Njb3BlLCBjYWxsYmFja10gPSByZXN0O1xuXG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgcmV0dXJuIGFjcy53aXRoU2NvcGUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Mud2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gYWNzLndpdGhTY29wZShyZXN0WzBdKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBmb3JrIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZSBhbmQgdGhlIGN1cnJlbnQgc2NvcGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgYXN5bmMgY29udGV4dCBzdHJhdGVneS4gSWYgbm9cbiAqIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kgaXMgc2V0LCB0aGUgaXNvbGF0aW9uIHNjb3BlIGFuZCB0aGUgY3VycmVudCBzY29wZSB3aWxsIG5vdCBiZSBmb3JrZWQgKHRoaXMgaXMgY3VycmVudGx5IHRoZVxuICogY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBicm93c2VyKS5cbiAqXG4gKiBVc2FnZSBvZiB0aGlzIGZ1bmN0aW9uIGluIGVudmlyb25tZW50cyB3aXRob3V0IGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kgaXMgZGlzY291cmFnZWQgYW5kIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIFNlbnRyeSBTREsgYW5kIFNESyBpbnRlZ3JhdGlvbiBkZXZlbG9wbWVudC4gSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGJlIHVzZWQgaW4gXCJub3JtYWxcIlxuICogYXBwbGljYXRpb25zIGRpcmVjdGx5IGJlY2F1c2UgaXQgY29tZXMgd2l0aCBwaXRmYWxscy4gVXNlIGF0IHlvdXIgb3duIHJpc2shXG4gKi9cblxuLyoqXG4gKiBFaXRoZXIgY3JlYXRlcyBhIG5ldyBhY3RpdmUgaXNvbGF0aW9uIHNjb3BlLCBvciBzZXRzIHRoZSBnaXZlbiBpc29sYXRpb24gc2NvcGUgYXMgYWN0aXZlIHNjb3BlIGluIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKFxuICAuLi5yZXN0XG5cbikge1xuICBjb25zdCBjYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2Fycmllcik7XG5cbiAgLy8gSWYgYSBzY29wZSBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIG1ha2UgdGhpcyB0aGUgYWN0aXZlIHNjb3BlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtpc29sYXRpb25TY29wZSwgY2FsbGJhY2tdID0gcmVzdDtcblxuICAgIGlmICghaXNvbGF0aW9uU2NvcGUpIHtcbiAgICAgIHJldHVybiBhY3Mud2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNzLndpdGhTZXRJc29sYXRpb25TY29wZShpc29sYXRpb25TY29wZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGFjcy53aXRoSXNvbGF0aW9uU2NvcGUocmVzdFswXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKCkuZ2V0Q2xpZW50KCk7XG59XG5cbi8qKlxuICogR2V0IGEgdHJhY2UgY29udGV4dCBmb3IgdGhlIGdpdmVuIHNjb3BlLlxuICovXG5mdW5jdGlvbiBnZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUoc2NvcGUpIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBwYXJlbnRTcGFuSWQsIHByb3BhZ2F0aW9uU3BhbklkIH0gPSBwcm9wYWdhdGlvbkNvbnRleHQ7XG5cbiAgY29uc3QgdHJhY2VDb250ZXh0ID0ge1xuICAgIHRyYWNlX2lkOiB0cmFjZUlkLFxuICAgIHNwYW5faWQ6IHByb3BhZ2F0aW9uU3BhbklkIHx8IGdlbmVyYXRlU3BhbklkKCksXG4gIH07XG5cbiAgaWYgKHBhcmVudFNwYW5JZCkge1xuICAgIHRyYWNlQ29udGV4dC5wYXJlbnRfc3Bhbl9pZCA9IHBhcmVudFNwYW5JZDtcbiAgfVxuXG4gIHJldHVybiB0cmFjZUNvbnRleHQ7XG59XG5cbmV4cG9ydCB7IGdldENsaWVudCwgZ2V0Q3VycmVudFNjb3BlLCBnZXRHbG9iYWxTY29wZSwgZ2V0SXNvbGF0aW9uU2NvcGUsIGdldFRyYWNlQ29udGV4dEZyb21TY29wZSwgd2l0aElzb2xhdGlvblNjb3BlLCB3aXRoU2NvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnJlbnRTY29wZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/debug-build.js":
/*!*************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/debug-build.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEBUG_BUILD: function() { return /* binding */ DEBUG_BUILD; }\n/* harmony export */ });\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n\n//# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9kZWJ1Zy1idWlsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vZGVidWctYnVpbGQuanM/MDVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnQgeyBERUJVR19CVUlMRCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctYnVpbGQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/debug-build.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/defaultScopes.js":
/*!***************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/defaultScopes.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultCurrentScope: function() { return /* binding */ getDefaultCurrentScope; },\n/* harmony export */   getDefaultIsolationScope: function() { return /* binding */ getDefaultIsolationScope; }\n/* harmony export */ });\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js\");\n\n\n\n/** Get the default current scope. */\nfunction getDefaultCurrentScope() {\n  return (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalSingleton)('defaultCurrentScope', () => new _scope_js__WEBPACK_IMPORTED_MODULE_1__.Scope());\n}\n\n/** Get the default isolation scope. */\nfunction getDefaultIsolationScope() {\n  return (0,_carrier_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalSingleton)('defaultIsolationScope', () => new _scope_js__WEBPACK_IMPORTED_MODULE_1__.Scope());\n}\n\n\n//# sourceMappingURL=defaultScopes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9kZWZhdWx0U2NvcGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0Q7QUFDZjs7QUFFbkM7QUFDQTtBQUNBLFNBQVMsK0RBQWtCLGtDQUFrQyw0Q0FBSztBQUNsRTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywrREFBa0Isb0NBQW9DLDRDQUFLO0FBQ3BFOztBQUU0RDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vZGVmYXVsdFNjb3Blcy5qcz8xMjk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEdsb2JhbFNpbmdsZXRvbiB9IGZyb20gJy4vY2Fycmllci5qcyc7XG5pbXBvcnQgeyBTY29wZSB9IGZyb20gJy4vc2NvcGUuanMnO1xuXG4vKiogR2V0IHRoZSBkZWZhdWx0IGN1cnJlbnQgc2NvcGUuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gZ2V0R2xvYmFsU2luZ2xldG9uKCdkZWZhdWx0Q3VycmVudFNjb3BlJywgKCkgPT4gbmV3IFNjb3BlKCkpO1xufVxuXG4vKiogR2V0IHRoZSBkZWZhdWx0IGlzb2xhdGlvbiBzY29wZS4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRJc29sYXRpb25TY29wZSgpIHtcbiAgcmV0dXJuIGdldEdsb2JhbFNpbmdsZXRvbignZGVmYXVsdElzb2xhdGlvblNjb3BlJywgKCkgPT4gbmV3IFNjb3BlKCkpO1xufVxuXG5leHBvcnQgeyBnZXREZWZhdWx0Q3VycmVudFNjb3BlLCBnZXREZWZhdWx0SXNvbGF0aW9uU2NvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRTY29wZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/defaultScopes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/eventProcessors.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/eventProcessors.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notifyEventProcessors: function() { return /* binding */ notifyEventProcessors; }\n/* harmony export */ });\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/debug-build.js\");\n/* harmony import */ var _utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils-hoist/is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _utils_hoist_syncpromise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-hoist/syncpromise.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js\");\n\n\n\n\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nfunction notifyEventProcessors(\n  processors,\n  event,\n  hint,\n  index = 0,\n) {\n  return new _utils_hoist_syncpromise_js__WEBPACK_IMPORTED_MODULE_0__.SyncPromise((resolve, reject) => {\n    const processor = processors[index];\n    if (event === null || typeof processor !== 'function') {\n      resolve(event);\n    } else {\n      const result = processor({ ...event }, hint) ;\n\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && processor.id && result === null && _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.log(`Event processor \"${processor.id}\" dropped event`);\n\n      if ((0,_utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_3__.isThenable)(result)) {\n        void result\n          .then(final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n          .then(null, reject);\n      } else {\n        void notifyEventProcessors(processors, result, hint, index + 1)\n          .then(resolve)\n          .then(null, reject);\n      }\n    }\n  });\n}\n\n\n//# sourceMappingURL=eventProcessors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9ldmVudFByb2Nlc3NvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDRTtBQUNBO0FBQ1U7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQyxVQUFVOztBQUUzQyxNQUFNLHdEQUFXLHVDQUF1QywwREFBTSx5QkFBeUIsYUFBYTs7QUFFcEcsVUFBVSw4REFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2V2ZW50UHJvY2Vzc29ycy5qcz84ZjNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9pcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBTeW5jUHJvbWlzZSB9IGZyb20gJy4vdXRpbHMtaG9pc3Qvc3luY3Byb21pc2UuanMnO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gYXJyYXkgb2YgZXZlbnQgcHJvY2Vzc29ycywgcmV0dXJuaW5nIHRoZSBwcm9jZXNzZWQgZXZlbnQgKG9yIGBudWxsYCBpZiB0aGUgZXZlbnQgd2FzIGRyb3BwZWQpLlxuICovXG5mdW5jdGlvbiBub3RpZnlFdmVudFByb2Nlc3NvcnMoXG4gIHByb2Nlc3NvcnMsXG4gIGV2ZW50LFxuICBoaW50LFxuICBpbmRleCA9IDAsXG4pIHtcbiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc29yID0gcHJvY2Vzc29yc1tpbmRleF07XG4gICAgaWYgKGV2ZW50ID09PSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzb3IoeyAuLi5ldmVudCB9LCBoaW50KSA7XG5cbiAgICAgIERFQlVHX0JVSUxEICYmIHByb2Nlc3Nvci5pZCAmJiByZXN1bHQgPT09IG51bGwgJiYgbG9nZ2VyLmxvZyhgRXZlbnQgcHJvY2Vzc29yIFwiJHtwcm9jZXNzb3IuaWR9XCIgZHJvcHBlZCBldmVudGApO1xuXG4gICAgICBpZiAoaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIHZvaWQgcmVzdWx0XG4gICAgICAgICAgLnRoZW4oZmluYWwgPT4gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIGZpbmFsLCBoaW50LCBpbmRleCArIDEpLnRoZW4ocmVzb2x2ZSkpXG4gICAgICAgICAgLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZvaWQgbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIHJlc3VsdCwgaGludCwgaW5kZXggKyAxKVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBub3RpZnlFdmVudFByb2Nlc3NvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50UHJvY2Vzc29ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/eventProcessors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/exports.js":
/*!*********************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/exports.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEventProcessor: function() { return /* binding */ addEventProcessor; },\n/* harmony export */   captureCheckIn: function() { return /* binding */ captureCheckIn; },\n/* harmony export */   captureEvent: function() { return /* binding */ captureEvent; },\n/* harmony export */   captureException: function() { return /* binding */ captureException; },\n/* harmony export */   captureMessage: function() { return /* binding */ captureMessage; },\n/* harmony export */   captureSession: function() { return /* binding */ captureSession; },\n/* harmony export */   close: function() { return /* binding */ close; },\n/* harmony export */   endSession: function() { return /* binding */ endSession; },\n/* harmony export */   flush: function() { return /* binding */ flush; },\n/* harmony export */   isEnabled: function() { return /* binding */ isEnabled; },\n/* harmony export */   isInitialized: function() { return /* binding */ isInitialized; },\n/* harmony export */   lastEventId: function() { return /* binding */ lastEventId; },\n/* harmony export */   setContext: function() { return /* binding */ setContext; },\n/* harmony export */   setExtra: function() { return /* binding */ setExtra; },\n/* harmony export */   setExtras: function() { return /* binding */ setExtras; },\n/* harmony export */   setTag: function() { return /* binding */ setTag; },\n/* harmony export */   setTags: function() { return /* binding */ setTags; },\n/* harmony export */   setUser: function() { return /* binding */ setUser; },\n/* harmony export */   startSession: function() { return /* binding */ startSession; },\n/* harmony export */   withMonitor: function() { return /* binding */ withMonitor; }\n/* harmony export */ });\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./currentScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/debug-build.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./session.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/session.js\");\n/* harmony import */ var _utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/prepareEvent.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/prepareEvent.js\");\n/* harmony import */ var _utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils-hoist/is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n/* harmony import */ var _utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils-hoist/time.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n/* harmony import */ var _utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils-hoist/worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)().captureException(exception, (0,_utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_1__.parseEventHintOrCaptureContext)(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)().captureMessage(message, level, context);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)();\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  if (!client) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_4__.uuid4)();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_5__.timestampInSeconds)();\n\n  function finishCheckIn(status) {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_5__.timestampInSeconds)() - now });\n  }\n\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.withIsolationScope)(() => {\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if ((0,_utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_6__.isThenable)(maybePromiseResult)) {\n      Promise.resolve(maybePromiseResult).then(\n        () => {\n          finishCheckIn('ok');\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      );\n    } else {\n      finishCheckIn('ok');\n    }\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  if (client) {\n    return client.flush(timeout);\n  }\n  _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  if (client) {\n    return client.close(timeout);\n  }\n  _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_3__.logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!(0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const isolationScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n  const currentScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = _utils_hoist_worldwide_js__WEBPACK_IMPORTED_MODULE_7__.GLOBAL_OBJ.navigator || {};\n\n  const session = (0,_session_js__WEBPACK_IMPORTED_MODULE_8__.makeSession)({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    (0,_session_js__WEBPACK_IMPORTED_MODULE_8__.updateSession)(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n  const currentScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    (0,_session_js__WEBPACK_IMPORTED_MODULE_8__.closeSession)(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\n\n//# sourceMappingURL=exports.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9leHBvcnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVHO0FBQ3hEO0FBQ3lCO0FBQ0M7QUFDeEI7QUFDQTtBQUNIO0FBQ2E7QUFDSDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWUsK0JBQStCLHNGQUE4QjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRSxTQUFTLGtFQUFlO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtFQUFlO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0VBQWlCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9FQUFpQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9FQUFpQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBaUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBaUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBaUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvRUFBaUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBZTtBQUMvQixpQkFBaUIsNERBQVM7QUFDMUI7QUFDQSxJQUFJLHdEQUFXLElBQUksMERBQU07QUFDekIsSUFBSTtBQUNKLElBQUksd0RBQVcsSUFBSSwwREFBTTtBQUN6QixJQUFJO0FBQ0o7QUFDQTs7QUFFQSxTQUFTLDJEQUFLO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9DQUFvQztBQUN6RSxjQUFjLHdFQUFrQjs7QUFFaEM7QUFDQSxxQkFBcUIsMENBQTBDLHdFQUFrQixVQUFVO0FBQzNGOztBQUVBLFNBQVMscUVBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQVcsSUFBSSwwREFBTTtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsK0RBQStELG1CQUFtQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFXLElBQUksMERBQU07QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0VBQWlCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0VBQWlCO0FBQzFDLHVCQUF1QixrRUFBZTs7QUFFdEM7QUFDQSxVQUFVLFlBQVksRUFBRSxpRUFBVTs7QUFFbEMsa0JBQWtCLHdEQUFXO0FBQzdCO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQWEsbUJBQW1CLGtCQUFrQjtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0VBQWlCO0FBQzFDLHVCQUF1QixrRUFBZTs7QUFFdEM7QUFDQTtBQUNBLElBQUkseURBQVk7QUFDaEI7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBaUI7QUFDMUMsaUJBQWlCLDREQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb1E7QUFDcFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2V4cG9ydHMuanM/NjVjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRDdXJyZW50U2NvcGUsIGdldENsaWVudCwgd2l0aElzb2xhdGlvblNjb3BlLCBnZXRJc29sYXRpb25TY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgbWFrZVNlc3Npb24sIHVwZGF0ZVNlc3Npb24sIGNsb3NlU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBwYXJzZUV2ZW50SGludE9yQ2FwdHVyZUNvbnRleHQgfSBmcm9tICcuL3V0aWxzL3ByZXBhcmVFdmVudC5qcyc7XG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9pcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcyc7XG5pbXBvcnQgeyB1dWlkNCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbWlzYy5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuaW1wb3J0IHsgR0xPQkFMX09CSiB9IGZyb20gJy4vdXRpbHMtaG9pc3Qvd29ybGR3aWRlLmpzJztcblxuLyoqXG4gKiBDYXB0dXJlcyBhbiBleGNlcHRpb24gZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBleGNlcHRpb24gdG8gY2FwdHVyZS5cbiAqIEBwYXJhbSBoaW50IE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIFNlbnRyeSBldmVudC5cbiAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgU2VudHJ5IGV2ZW50LlxuICovXG5mdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKCkuY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIHBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dChoaW50KSk7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgYSBtZXNzYWdlIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byBTZW50cnkuXG4gKiBAcGFyYW0gY2FwdHVyZUNvbnRleHQgRGVmaW5lIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBvciBwYXNzIGluIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGNhcHR1cmVDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgZXhwbGljaXQgc2NvcGVzIHVwZ3JhZGUsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWdpbmFsXG4gIC8vIGFyaXR5IG9mIHRoZSBgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwpYCBtZXRob2QuXG4gIGNvbnN0IGxldmVsID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ID09PSAnc3RyaW5nJyA/IGNhcHR1cmVDb250ZXh0IDogdW5kZWZpbmVkO1xuICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ICE9PSAnc3RyaW5nJyA/IHsgY2FwdHVyZUNvbnRleHQgfSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGdldEN1cnJlbnRTY29wZSgpLmNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGxldmVsLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIG1hbnVhbGx5IGNyZWF0ZWQgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gU2VudHJ5LlxuICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICogQHJldHVybnMgdGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBldmVudC5cbiAqL1xuZnVuY3Rpb24gY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7XG4gIHJldHVybiBnZXRDdXJyZW50U2NvcGUoKS5jYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpO1xufVxuXG4vKipcbiAqIFNldHMgY29udGV4dCBkYXRhIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSBvZiB0aGUgY29udGV4dFxuICogQHBhcmFtIGNvbnRleHQgQW55IGtpbmQgb2YgZGF0YS4gVGhpcyBkYXRhIHdpbGwgYmUgbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIGV4dHJhcyBFeHRyYXMgb2JqZWN0IHRvIG1lcmdlIGludG8gY3VycmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBzZXRFeHRyYXMoZXh0cmFzKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0RXh0cmFzKGV4dHJhcyk7XG59XG5cbi8qKlxuICogU2V0IGtleTp2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIGtleSBTdHJpbmcgb2YgZXh0cmFcbiAqIEBwYXJhbSBleHRyYSBBbnkga2luZCBvZiBkYXRhLiBUaGlzIGRhdGEgd2lsbCBiZSBub3JtYWxpemVkLlxuICovXG5mdW5jdGlvbiBzZXRFeHRyYShrZXksIGV4dHJhKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0RXh0cmEoa2V5LCBleHRyYSk7XG59XG5cbi8qKlxuICogU2V0IGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIHRhZ3MgVGFncyBjb250ZXh0IG9iamVjdCB0byBtZXJnZSBpbnRvIGN1cnJlbnQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gc2V0VGFncyh0YWdzKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0VGFncyh0YWdzKTtcbn1cblxuLyoqXG4gKiBTZXQga2V5OnZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHVuc2V0IGEgdGFnLCBieSBwYXNzaW5nIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBrZXkgU3RyaW5nIGtleSBvZiB0YWdcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiB0YWdcbiAqL1xuZnVuY3Rpb24gc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRUYWcoa2V5LCB2YWx1ZSk7XG59XG5cbi8qKlxuICogVXBkYXRlcyB1c2VyIGNvbnRleHQgaW5mb3JtYXRpb24gZm9yIGZ1dHVyZSBldmVudHMuXG4gKlxuICogQHBhcmFtIHVzZXIgVXNlciBjb250ZXh0IG9iamVjdCB0byBiZSBzZXQgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gUGFzcyBgbnVsbGAgdG8gdW5zZXQgdGhlIHVzZXIuXG4gKi9cbmZ1bmN0aW9uIHNldFVzZXIodXNlcikge1xuICBnZXRJc29sYXRpb25TY29wZSgpLnNldFVzZXIodXNlcik7XG59XG5cbi8qKlxuICogVGhlIGxhc3QgZXJyb3IgZXZlbnQgaWQgb2YgdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIHJlYWxseSByZXR1cm5zIHRoZSBsYXN0IHJlY29yZGVkIGVycm9yIGV2ZW50IGlkIG9uIHRoZSBjdXJyZW50XG4gKiBpc29sYXRpb24gc2NvcGUuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgaGFuZGxpbmcgYSBjZXJ0YWluIGVycm9yIGFuZCBhbm90aGVyIGVycm9yXG4gKiBpcyBjYXB0dXJlZCBpbiBiZXR3ZWVuLCB0aGUgbGFzdCBvbmUgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aGUgb25lIHlvdSBtaWdodCBleHBlY3QuXG4gKiBBbHNvLCBpZHMgb2YgZXZlbnRzIHRoYXQgd2VyZSBuZXZlciBzZW50IHRvIFNlbnRyeSAoZm9yIGV4YW1wbGUgYmVjYXVzZVxuICogdGhleSB3ZXJlIGRyb3BwZWQgaW4gYGJlZm9yZVNlbmRgKSBjb3VsZCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbGFzdCBldmVudCBpZCBvZiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICovXG5mdW5jdGlvbiBsYXN0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGdldElzb2xhdGlvblNjb3BlKCkubGFzdEV2ZW50SWQoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjcm9uIG1vbml0b3IgY2hlY2sgaW4gYW5kIHNlbmQgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBjaGVja0luIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGNoZWNrIGluLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVDaGVja0luKGNoZWNrSW4sIHVwc2VydE1vbml0b3JDb25maWcpIHtcbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBjYXB0dXJlIGNoZWNrLWluLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgfSBlbHNlIGlmICghY2xpZW50LmNhcHR1cmVDaGVja0luKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBjYXB0dXJlIGNoZWNrLWluLiBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIGNoZWNrLWlucy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2xpZW50LmNhcHR1cmVDaGVja0luKGNoZWNrSW4sIHVwc2VydE1vbml0b3JDb25maWcsIHNjb3BlKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkNCgpO1xufVxuXG4vKipcbiAqIFdyYXBzIGEgY2FsbGJhY2sgd2l0aCBhIGNyb24gbW9uaXRvciBjaGVjayBpbi4gVGhlIGNoZWNrIGluIHdpbGwgYmUgc2VudCB0byBTZW50cnkgd2hlbiB0aGUgY2FsbGJhY2sgZmluaXNoZXMuXG4gKlxuICogQHBhcmFtIG1vbml0b3JTbHVnIFRoZSBkaXN0aW5jdCBzbHVnIG9mIHRoZSBtb25pdG9yLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIHdpdGhNb25pdG9yKFxuICBtb25pdG9yU2x1ZyxcbiAgY2FsbGJhY2ssXG4gIHVwc2VydE1vbml0b3JDb25maWcsXG4pIHtcbiAgY29uc3QgY2hlY2tJbklkID0gY2FwdHVyZUNoZWNrSW4oeyBtb25pdG9yU2x1Zywgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIH0sIHVwc2VydE1vbml0b3JDb25maWcpO1xuICBjb25zdCBub3cgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBmdW5jdGlvbiBmaW5pc2hDaGVja0luKHN0YXR1cykge1xuICAgIGNhcHR1cmVDaGVja0luKHsgbW9uaXRvclNsdWcsIHN0YXR1cywgY2hlY2tJbklkLCBkdXJhdGlvbjogdGltZXN0YW1wSW5TZWNvbmRzKCkgLSBub3cgfSk7XG4gIH1cblxuICByZXR1cm4gd2l0aElzb2xhdGlvblNjb3BlKCgpID0+IHtcbiAgICBsZXQgbWF5YmVQcm9taXNlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZpbmlzaENoZWNrSW4oJ2Vycm9yJyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChpc1RoZW5hYmxlKG1heWJlUHJvbWlzZVJlc3VsdCkpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2VSZXN1bHQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgICAgICB9LFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdlcnJvcicpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGwgYGZsdXNoKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gKiB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgc3VjY2Vzc2Z1bGx5IGRyYWlucyBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgaXRcbiAqIGRvZXNuJ3QgKG9yIGlmIHRoZXJlJ3Mgbm8gY2xpZW50IGRlZmluZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiBmbHVzaCh0aW1lb3V0KSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5mbHVzaCh0aW1lb3V0KTtcbiAgfVxuICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignQ2Fubm90IGZsdXNoIGV2ZW50cy4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xufVxuXG4vKipcbiAqIENhbGwgYGNsb3NlKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5jbG9zZX0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlIGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzXG4gKiBwYXJhbWV0ZXIgd2lsbCBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgZGlzYWJsaW5nIGl0c2VsZi5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBgdHJ1ZWAgaWYgdGhlIHF1ZXVlIHN1Y2Nlc3NmdWxseSBkcmFpbnMgYmVmb3JlIHRoZSB0aW1lb3V0LCBvciBgZmFsc2VgIGlmIGl0XG4gKiBkb2Vzbid0IChvciBpZiB0aGVyZSdzIG5vIGNsaWVudCBkZWZpbmVkKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xvc2UodGltZW91dCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgaWYgKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuY2xvc2UodGltZW91dCk7XG4gIH1cbiAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBmbHVzaCBldmVudHMgYW5kIGRpc2FibGUgU0RLLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIFNlbnRyeSBoYXMgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gaXNJbml0aWFsaXplZCgpIHtcbiAgcmV0dXJuICEhZ2V0Q2xpZW50KCk7XG59XG5cbi8qKiBJZiB0aGUgU0RLIGlzIGluaXRpYWxpemVkICYgZW5hYmxlZC4gKi9cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIHJldHVybiBjbGllbnQ/LmdldE9wdGlvbnMoKS5lbmFibGVkICE9PSBmYWxzZSAmJiAhIWNsaWVudD8uZ2V0VHJhbnNwb3J0KCk7XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IHByb2Nlc3Nvci5cbiAqIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUsIGVuc3VyaW5nIGFueSBldmVudCB0aGF0IGlzIHByb2Nlc3NlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb25cbiAqIGNvbnRleHQgd2lsbCBoYXZlIHRoZSBwcm9jZXNzb3IgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRQcm9jZXNzb3IoY2FsbGJhY2spIHtcbiAgZ2V0SXNvbGF0aW9uU2NvcGUoKS5hZGRFdmVudFByb2Nlc3NvcihjYWxsYmFjayk7XG59XG5cbi8qKlxuICogU3RhcnQgYSBzZXNzaW9uIG9uIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZS5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCAob3B0aW9uYWwpIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBzZXNzaW9uIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHRoZSBuZXcgYWN0aXZlIHNlc3Npb25cbiAqL1xuZnVuY3Rpb24gc3RhcnRTZXNzaW9uKGNvbnRleHQpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICAvLyBXaWxsIGZldGNoIHVzZXJBZ2VudCBpZiBjYWxsZWQgZnJvbSBicm93c2VyIHNka1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gR0xPQkFMX09CSi5uYXZpZ2F0b3IgfHwge307XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKHtcbiAgICB1c2VyOiBjdXJyZW50U2NvcGUuZ2V0VXNlcigpIHx8IGlzb2xhdGlvblNjb3BlLmdldFVzZXIoKSxcbiAgICAuLi4odXNlckFnZW50ICYmIHsgdXNlckFnZW50IH0pLFxuICAgIC4uLmNvbnRleHQsXG4gIH0pO1xuXG4gIC8vIEVuZCBleGlzdGluZyBzZXNzaW9uIGlmIHRoZXJlJ3Mgb25lXG4gIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2Vzc2lvbigpO1xuICBpZiAoY3VycmVudFNlc3Npb24/LnN0YXR1cyA9PT0gJ29rJykge1xuICAgIHVwZGF0ZVNlc3Npb24oY3VycmVudFNlc3Npb24sIHsgc3RhdHVzOiAnZXhpdGVkJyB9KTtcbiAgfVxuXG4gIGVuZFNlc3Npb24oKTtcblxuICAvLyBBZnRlcndhcmRzIHdlIHNldCB0aGUgbmV3IHNlc3Npb24gb24gdGhlIHNjb3BlXG4gIGlzb2xhdGlvblNjb3BlLnNldFNlc3Npb24oc2Vzc2lvbik7XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogRW5kIHRoZSBzZXNzaW9uIG9uIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZW5kU2Vzc2lvbigpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChzZXNzaW9uKSB7XG4gICAgY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xuICB9XG4gIF9zZW5kU2Vzc2lvblVwZGF0ZSgpO1xuXG4gIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZVxuICBpc29sYXRpb25TY29wZS5zZXRTZXNzaW9uKCk7XG59XG5cbi8qKlxuICogU2VuZHMgdGhlIGN1cnJlbnQgU2Vzc2lvbiBvbiB0aGUgc2NvcGVcbiAqL1xuZnVuY3Rpb24gX3NlbmRTZXNzaW9uVXBkYXRlKCkge1xuICBjb25zdCBpc29sYXRpb25TY29wZSA9IGdldElzb2xhdGlvblNjb3BlKCk7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBjb25zdCBzZXNzaW9uID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2Vzc2lvbigpO1xuICBpZiAoc2Vzc2lvbiAmJiBjbGllbnQpIHtcbiAgICBjbGllbnQuY2FwdHVyZVNlc3Npb24oc2Vzc2lvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyB0aGUgY3VycmVudCBzZXNzaW9uIG9uIHRoZSBzY29wZSB0byBTZW50cnlcbiAqXG4gKiBAcGFyYW0gZW5kIElmIHNldCB0aGUgc2Vzc2lvbiB3aWxsIGJlIG1hcmtlZCBhcyBleGl0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgc2NvcGUuXG4gKiAgICAgICAgICAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVTZXNzaW9uKGVuZCA9IGZhbHNlKSB7XG4gIC8vIGJvdGggc2VuZCB0aGUgdXBkYXRlIGFuZCBwdWxsIHRoZSBzZXNzaW9uIGZyb20gdGhlIHNjb3BlXG4gIGlmIChlbmQpIHtcbiAgICBlbmRTZXNzaW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGVcbiAgX3NlbmRTZXNzaW9uVXBkYXRlKCk7XG59XG5cbmV4cG9ydCB7IGFkZEV2ZW50UHJvY2Vzc29yLCBjYXB0dXJlQ2hlY2tJbiwgY2FwdHVyZUV2ZW50LCBjYXB0dXJlRXhjZXB0aW9uLCBjYXB0dXJlTWVzc2FnZSwgY2FwdHVyZVNlc3Npb24sIGNsb3NlLCBlbmRTZXNzaW9uLCBmbHVzaCwgaXNFbmFibGVkLCBpc0luaXRpYWxpemVkLCBsYXN0RXZlbnRJZCwgc2V0Q29udGV4dCwgc2V0RXh0cmEsIHNldEV4dHJhcywgc2V0VGFnLCBzZXRUYWdzLCBzZXRVc2VyLCBzdGFydFNlc3Npb24sIHdpdGhNb25pdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBvcnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/exports.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js":
/*!*******************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/scope.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scope: function() { return /* binding */ Scope; }\n/* harmony export */ });\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./session.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/session.js\");\n/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/merge.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/merge.js\");\n/* harmony import */ var _utils_spanOnScope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/spanOnScope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanOnScope.js\");\n/* harmony import */ var _utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils-hoist/is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils-hoist/logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n/* harmony import */ var _utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-hoist/propagationContext.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js\");\n/* harmony import */ var _utils_hoist_string_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils-hoist/string.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js\");\n/* harmony import */ var _utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils-hoist/time.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\n\n/**\n * Holds additional event information.\n */\nclass Scope {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: (0,_utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_0__.generateTraceId)(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n   clone() {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    (0,_utils_spanOnScope_js__WEBPACK_IMPORTED_MODULE_1__._setSpanForScope)(newScope, (0,_utils_spanOnScope_js__WEBPACK_IMPORTED_MODULE_1__._getSpanForScope)(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      (0,_session_js__WEBPACK_IMPORTED_MODULE_2__.updateSession)(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n   setTag(key, value) {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : (0,_utils_hoist_is_js__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(scopeToMerge)\n          ? (captureContext )\n          : undefined;\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    (0,_utils_spanOnScope_js__WEBPACK_IMPORTED_MODULE_1__._setSpanForScope)(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({ traceId: (0,_utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_0__.generateTraceId)(), sampleRand: Math.random() });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_4__.dateTimestampInSeconds)(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? (0,_utils_hoist_string_js__WEBPACK_IMPORTED_MODULE_5__.truncate)(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: (0,_utils_spanOnScope_js__WEBPACK_IMPORTED_MODULE_1__._getSpanForScope)(this),\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_6__.merge)(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n   captureException(exception, hint) {\n    const eventId = hint?.event_id || (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_7__.uuid4)();\n\n    if (!this._client) {\n      _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_8__.logger.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint?.event_id || (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_7__.uuid4)();\n\n    if (!this._client) {\n      _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_8__.logger.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n   captureEvent(event, hint) {\n    const eventId = hint?.event_id || (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_7__.uuid4)();\n\n    if (!this._client) {\n      _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_8__.logger.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\n\n//# sourceMappingURL=scope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zY29wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0o7QUFDbUM7QUFDeEI7QUFDSDtBQUNIO0FBQ3dCO0FBQ25CO0FBQ1k7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtRkFBZTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUEsSUFBSSx1RUFBZ0IsV0FBVyx1RUFBZ0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBYSxrQkFBa0IsTUFBTTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBYTtBQUN2QjtBQUNBOztBQUVBLFlBQVksMkVBQTJFOztBQUV2RixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1RUFBZ0I7QUFDcEI7QUFDQSxpQ0FBaUMsU0FBUyxtRkFBZSwrQkFBK0I7O0FBRXhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNEVBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFLO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esc0NBQXNDLDJEQUFLOztBQUUzQztBQUNBLE1BQU0sMERBQU07QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHNDQUFzQywyREFBSzs7QUFFM0M7QUFDQSxNQUFNLDBEQUFNO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHNDQUFzQywyREFBSzs7QUFFM0M7QUFDQSxNQUFNLDBEQUFNO0FBQ1o7QUFDQTs7QUFFQSx1Q0FBdUMsNEJBQTRCOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zY29wZS5qcz85YTFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwZGF0ZVNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24uanMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICcuL3V0aWxzL21lcmdlLmpzJztcbmltcG9ydCB7IF9zZXRTcGFuRm9yU2NvcGUsIF9nZXRTcGFuRm9yU2NvcGUgfSBmcm9tICcuL3V0aWxzL3NwYW5PblNjb3BlLmpzJztcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHV1aWQ0IH0gZnJvbSAnLi91dGlscy1ob2lzdC9taXNjLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVHJhY2VJZCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJztcbmltcG9ydCB7IHRydW5jYXRlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9zdHJpbmcuanMnO1xuaW1wb3J0IHsgZGF0ZVRpbWVzdGFtcEluU2Vjb25kcyB9IGZyb20gJy4vdXRpbHMtaG9pc3QvdGltZS5qcyc7XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZSBmb3IgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX0JSRUFEQ1JVTUJTID0gMTAwO1xuXG4vKipcbiAqIEEgY29udGV4dCB0byBiZSB1c2VkIGZvciBjYXB0dXJpbmcgYW4gZXZlbnQuXG4gKiBUaGlzIGNhbiBlaXRoZXIgYmUgYSBTY29wZSwgb3IgYSBwYXJ0aWFsIFNjb3BlQ29udGV4dCxcbiAqIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBzY29wZSBhbmQgcmV0dXJucyBhIG5ldyBzY29wZSB0byB1c2UuXG4gKi9cblxuLyoqXG4gKiBIb2xkcyBhZGRpdGlvbmFsIGV2ZW50IGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBTY29wZSB7XG4gIC8qKiBGbGFnIGlmIG5vdGlmeWluZyBpcyBoYXBwZW5pbmcuICovXG5cbiAgLyoqIENhbGxiYWNrIGZvciBjbGllbnQgdG8gcmVjZWl2ZSBzY29wZSBjaGFuZ2VzLiAqL1xuXG4gIC8qKiBDYWxsYmFjayBsaXN0IHRoYXQgd2lsbCBiZSBjYWxsZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmcuICovXG5cbiAgLyoqIEFycmF5IG9mIGJyZWFkY3J1bWJzLiAqL1xuXG4gIC8qKiBVc2VyICovXG5cbiAgLyoqIFRhZ3MgKi9cblxuICAvKiogRXh0cmEgKi9cblxuICAvKiogQ29udGV4dHMgKi9cblxuICAvKiogQXR0YWNobWVudHMgKi9cblxuICAvKiogUHJvcGFnYXRpb24gQ29udGV4dCBmb3IgZGlzdHJpYnV0ZWQgdHJhY2luZyAqL1xuXG4gIC8qKlxuICAgKiBBIHBsYWNlIHRvIHN0YXNoIGRhdGEgd2hpY2ggaXMgbmVlZGVkIGF0IHNvbWUgcG9pbnQgaW4gdGhlIFNESydzIGV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgYnV0IHdoaWNoIHNob3VsZG4ndCBnZXRcbiAgICogc2VudCB0byBTZW50cnlcbiAgICovXG5cbiAgLyoqIEZpbmdlcnByaW50ICovXG5cbiAgLyoqIFNldmVyaXR5ICovXG5cbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIE5hbWVcbiAgICpcbiAgICogSU1QT1JUQU5UOiBUaGUgdHJhbnNhY3Rpb24gbmFtZSBvbiB0aGUgc2NvcGUgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCByb290IHNwYW5zL3RyYW5zYWN0aW9uIG9iamVjdHMuXG4gICAqIEl0J3MgcHVycG9zZSBpcyB0byBhc3NpZ24gYSB0cmFuc2FjdGlvbiB0byB0aGUgc2NvcGUgdGhhdCdzIGFkZGVkIHRvIG5vbi10cmFuc2FjdGlvbiBldmVudHMuXG4gICAqL1xuXG4gIC8qKiBTZXNzaW9uICovXG5cbiAgLyoqIFRoZSBjbGllbnQgb24gdGhpcyBzY29wZSAqL1xuXG4gIC8qKiBDb250YWlucyB0aGUgbGFzdCBldmVudCBpZCBvZiBhIGNhcHR1cmVkIGV2ZW50LiAgKi9cblxuICAvLyBOT1RFOiBBbnkgZmllbGQgd2hpY2ggZ2V0cyBhZGRlZCBoZXJlIHNob3VsZCBnZXQgYWRkZWQgbm90IG9ubHkgdG8gdGhlIGNvbnN0cnVjdG9yIGJ1dCBhbHNvIHRvIHRoZSBgY2xvbmVgIG1ldGhvZC5cblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IFtdO1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gW107XG4gICAgdGhpcy5fdXNlciA9IHt9O1xuICAgIHRoaXMuX3RhZ3MgPSB7fTtcbiAgICB0aGlzLl9leHRyYSA9IHt9O1xuICAgIHRoaXMuX2NvbnRleHRzID0ge307XG4gICAgdGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge307XG4gICAgdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0ID0ge1xuICAgICAgdHJhY2VJZDogZ2VuZXJhdGVUcmFjZUlkKCksXG4gICAgICBzYW1wbGVSYW5kOiBNYXRoLnJhbmRvbSgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgYWxsIGRhdGEgZnJvbSB0aGlzIHNjb3BlIGludG8gYSBuZXcgc2NvcGUuXG4gICAqL1xuICAgY2xvbmUoKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICBuZXdTY29wZS5fYnJlYWRjcnVtYnMgPSBbLi4udGhpcy5fYnJlYWRjcnVtYnNdO1xuICAgIG5ld1Njb3BlLl90YWdzID0geyAuLi50aGlzLl90YWdzIH07XG4gICAgbmV3U2NvcGUuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSB9O1xuICAgIG5ld1Njb3BlLl9jb250ZXh0cyA9IHsgLi4udGhpcy5fY29udGV4dHMgfTtcbiAgICBpZiAodGhpcy5fY29udGV4dHMuZmxhZ3MpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29weSB0aGUgYHZhbHVlc2AgYXJyYXkgc28gaW5zZXJ0aW9ucyBvbiBhIGNsb25lZCBzY29wZVxuICAgICAgLy8gd29uJ3QgYWZmZWN0IHRoZSBvcmlnaW5hbCBhcnJheS5cbiAgICAgIG5ld1Njb3BlLl9jb250ZXh0cy5mbGFncyA9IHtcbiAgICAgICAgdmFsdWVzOiBbLi4udGhpcy5fY29udGV4dHMuZmxhZ3MudmFsdWVzXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmV3U2NvcGUuX3VzZXIgPSB0aGlzLl91c2VyO1xuICAgIG5ld1Njb3BlLl9sZXZlbCA9IHRoaXMuX2xldmVsO1xuICAgIG5ld1Njb3BlLl9zZXNzaW9uID0gdGhpcy5fc2Vzc2lvbjtcbiAgICBuZXdTY29wZS5fdHJhbnNhY3Rpb25OYW1lID0gdGhpcy5fdHJhbnNhY3Rpb25OYW1lO1xuICAgIG5ld1Njb3BlLl9maW5nZXJwcmludCA9IHRoaXMuX2ZpbmdlcnByaW50O1xuICAgIG5ld1Njb3BlLl9ldmVudFByb2Nlc3NvcnMgPSBbLi4udGhpcy5fZXZlbnRQcm9jZXNzb3JzXTtcbiAgICBuZXdTY29wZS5fYXR0YWNobWVudHMgPSBbLi4udGhpcy5fYXR0YWNobWVudHNdO1xuICAgIG5ld1Njb3BlLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7IC4uLnRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSB9O1xuICAgIG5ld1Njb3BlLl9wcm9wYWdhdGlvbkNvbnRleHQgPSB7IC4uLnRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCB9O1xuICAgIG5ld1Njb3BlLl9jbGllbnQgPSB0aGlzLl9jbGllbnQ7XG4gICAgbmV3U2NvcGUuX2xhc3RFdmVudElkID0gdGhpcy5fbGFzdEV2ZW50SWQ7XG5cbiAgICBfc2V0U3BhbkZvclNjb3BlKG5ld1Njb3BlLCBfZ2V0U3BhbkZvclNjb3BlKHRoaXMpKTtcblxuICAgIHJldHVybiBuZXdTY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsaWVudCBhc3NpZ25lZCB0byB0aGlzIHNjb3BlLlxuICAgKiBOb3RlIHRoYXQgbm90IGV2ZXJ5IHNjb3BlIHdpbGwgaGF2ZSBhIGNsaWVudCBhc3NpZ25lZCAtIGlzb2xhdGlvbiBzY29wZXMgJiB0aGUgZ2xvYmFsIHNjb3BlIHdpbGwgZ2VuZXJhbGx5IG5vdCBoYXZlIGEgY2xpZW50LFxuICAgKiBhcyB3ZWxsIGFzIG1hbnVhbGx5IGNyZWF0ZWQgc2NvcGVzLlxuICAgKi9cbiAgIHNldENsaWVudChjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBJRCBvZiB0aGUgbGFzdCBjYXB0dXJlZCBlcnJvciBldmVudC5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgb25seSBjYXB0dXJlZCBvbiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICAgKi9cbiAgIHNldExhc3RFdmVudElkKGxhc3RFdmVudElkKSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50SWQgPSBsYXN0RXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBhc3NpZ25lZCB0byB0aGlzIHNjb3BlLlxuICAgKi9cbiAgIGdldENsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50IDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIElEIG9mIHRoZSBsYXN0IGNhcHR1cmVkIGVycm9yIGV2ZW50LlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBvbmx5IGF2YWlsYWJsZSBvbiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICAgKi9cbiAgIGxhc3RFdmVudElkKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0RXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFkZFNjb3BlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgcHJvY2Vzc29yIHRoYXQgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIGV2ZW50IGlzIHNlbnQuXG4gICAqL1xuICAgYWRkRXZlbnRQcm9jZXNzb3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyIGZvciB0aGlzIHNjb3BlLlxuICAgKiBTZXQgdG8gYG51bGxgIHRvIHVuc2V0IHRoZSB1c2VyLlxuICAgKi9cbiAgIHNldFVzZXIodXNlcikge1xuICAgIC8vIElmIG51bGwgaXMgcGFzc2VkIHdlIHdhbnQgdG8gdW5zZXQgZXZlcnl0aGluZywgYnV0IHN0aWxsIGRlZmluZSBrZXlzLFxuICAgIC8vIHNvIHRoYXQgbGF0ZXIgZG93biBpbiB0aGUgcGlwZWxpbmUgYW55IGV4aXN0aW5nIHZhbHVlcyBhcmUgY2xlYXJlZC5cbiAgICB0aGlzLl91c2VyID0gdXNlciB8fCB7XG4gICAgICBlbWFpbDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIGlwX2FkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIHVzZXJuYW1lOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9zZXNzaW9uKSB7XG4gICAgICB1cGRhdGVTZXNzaW9uKHRoaXMuX3Nlc3Npb24sIHsgdXNlciB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlciBmcm9tIHRoaXMgc2NvcGUuXG4gICAqL1xuICAgZ2V0VXNlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgaW50byBleGlzdGluZyB0YWdzIG9uIHRoZSBzY29wZSxcbiAgICogYW5kIHdpbGwgYmUgc2VudCBhcyB0YWdzIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0VGFncyh0YWdzKSB7XG4gICAgdGhpcy5fdGFncyA9IHtcbiAgICAgIC4uLnRoaXMuX3RhZ3MsXG4gICAgICAuLi50YWdzLFxuICAgIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBzaW5nbGUgdGFnIHRoYXQgd2lsbCBiZSBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gICBzZXRUYWcoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MsIFtrZXldOiB2YWx1ZSB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludG8gZXhpc3RpbmcgZXh0cmEgb24gdGhlIHNjb3BlLFxuICAgKiBhbmQgd2lsbCBiZSBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0RXh0cmFzKGV4dHJhcykge1xuICAgIHRoaXMuX2V4dHJhID0ge1xuICAgICAgLi4udGhpcy5fZXh0cmEsXG4gICAgICAuLi5leHRyYXMsXG4gICAgfTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHNpbmdsZSBrZXk6dmFsdWUgZXh0cmEgZW50cnkgdGhhdCB3aWxsIGJlIHNlbnQgYXMgZXh0cmEgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAgICovXG4gICBzZXRFeHRyYShrZXksIGV4dHJhKSB7XG4gICAgdGhpcy5fZXh0cmEgPSB7IC4uLnRoaXMuX2V4dHJhLCBba2V5XTogZXh0cmEgfTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbmdlcnByaW50IG9uIHRoZSBzY29wZSB0byBzZW5kIHdpdGggdGhlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmluZ2VycHJpbnQgRmluZ2VycHJpbnQgdG8gZ3JvdXAgZXZlbnRzIGluIFNlbnRyeS5cbiAgICovXG4gICBzZXRGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsZXZlbCBvbiB0aGUgc2NvcGUgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAqL1xuICAgc2V0TGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNhY3Rpb24gbmFtZSBvbiB0aGUgc2NvcGUgc28gdGhhdCB0aGUgbmFtZSBvZiBlLmcuIHRha2VuIHNlcnZlciByb3V0ZSBvclxuICAgKiB0aGUgcGFnZSBsb2NhdGlvbiBpcyBhdHRhY2hlZCB0byBmdXR1cmUgZXZlbnRzLlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6IENhbGxpbmcgdGhpcyBmdW5jdGlvbiBkb2VzIE5PVCBjaGFuZ2UgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgICogcm9vdCBzcGFuLiBJZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIG5hbWUgb2YgdGhlIGFjdGl2ZSByb290IHNwYW4sIHVzZVxuICAgKiBgU2VudHJ5LnVwZGF0ZVNwYW5OYW1lKHJvb3RTcGFuLCAnbmV3IG5hbWUnKWAgaW5zdGVhZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIFNESyB1cGRhdGVzIHRoZSBzY29wZSdzIHRyYW5zYWN0aW9uIG5hbWUgYXV0b21hdGljYWxseSBvbiBzZW5zaWJsZVxuICAgKiBvY2Nhc2lvbnMsIHN1Y2ggYXMgYSBwYWdlIG5hdmlnYXRpb24gb3Igd2hlbiBoYW5kbGluZyBhIG5ldyByZXF1ZXN0IG9uIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICAgc2V0VHJhbnNhY3Rpb25OYW1lKG5hbWUpIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSBuYW1lO1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjb250ZXh0IGRhdGEgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogRGF0YSBwYXNzZWQgYXMgY29udGV4dCB3aWxsIGJlIG5vcm1hbGl6ZWQuIFlvdSBjYW4gYWxzbyBwYXNzIGBudWxsYCB0byB1bnNldCB0aGUgY29udGV4dC5cbiAgICogTm90ZSB0aGF0IGNvbnRleHQgZGF0YSB3aWxsIG5vdCBiZSBtZXJnZWQgLSBjYWxsaW5nIGBzZXRDb250ZXh0YCB3aWxsIG92ZXJ3cml0ZSBhbiBleGlzdGluZyBjb250ZXh0IHdpdGggdGhlIHNhbWUga2V5LlxuICAgKi9cbiAgIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb250ZXh0c1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb250ZXh0c1trZXldID0gY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2Vzc2lvbiBmb3IgdGhlIHNjb3BlLlxuICAgKi9cbiAgIHNldFNlc3Npb24oc2Vzc2lvbikge1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgZGVsZXRlIHRoaXMuX3Nlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICAgIH1cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gICBnZXRTZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNjb3BlIHdpdGggcHJvdmlkZWQgZGF0YS4gQ2FuIHdvcmsgaW4gdGhyZWUgdmFyaWF0aW9uczpcbiAgICogLSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB1cGRhdGFibGUgYXR0cmlidXRlc1xuICAgKiAtIFNjb3BlIGluc3RhbmNlIHRoYXQnbGwgZXh0cmFjdCB0aGUgYXR0cmlidXRlcyBmcm9tXG4gICAqIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCdsbCByZWNlaXZlIHRoZSBjdXJyZW50IHNjb3BlIGFzIGFuIGFyZ3VtZW50IGFuZCBhbGxvdyBmb3IgbW9kaWZpY2F0aW9uc1xuICAgKi9cbiAgIHVwZGF0ZShjYXB0dXJlQ29udGV4dCkge1xuICAgIGlmICghY2FwdHVyZUNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlVG9NZXJnZSA9IHR5cGVvZiBjYXB0dXJlQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IGNhcHR1cmVDb250ZXh0KHRoaXMpIDogY2FwdHVyZUNvbnRleHQ7XG5cbiAgICBjb25zdCBzY29wZUluc3RhbmNlID1cbiAgICAgIHNjb3BlVG9NZXJnZSBpbnN0YW5jZW9mIFNjb3BlXG4gICAgICAgID8gc2NvcGVUb01lcmdlLmdldFNjb3BlRGF0YSgpXG4gICAgICAgIDogaXNQbGFpbk9iamVjdChzY29wZVRvTWVyZ2UpXG4gICAgICAgICAgPyAoY2FwdHVyZUNvbnRleHQgKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgeyB0YWdzLCBleHRyYSwgdXNlciwgY29udGV4dHMsIGxldmVsLCBmaW5nZXJwcmludCA9IFtdLCBwcm9wYWdhdGlvbkNvbnRleHQgfSA9IHNjb3BlSW5zdGFuY2UgfHwge307XG5cbiAgICB0aGlzLl90YWdzID0geyAuLi50aGlzLl90YWdzLCAuLi50YWdzIH07XG4gICAgdGhpcy5fZXh0cmEgPSB7IC4uLnRoaXMuX2V4dHJhLCAuLi5leHRyYSB9O1xuICAgIHRoaXMuX2NvbnRleHRzID0geyAuLi50aGlzLl9jb250ZXh0cywgLi4uY29udGV4dHMgfTtcblxuICAgIGlmICh1c2VyICYmIE9iamVjdC5rZXlzKHVzZXIpLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsKSB7XG4gICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgIH1cblxuICAgIGlmIChmaW5nZXJwcmludC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG4gICAgfVxuXG4gICAgaWYgKHByb3BhZ2F0aW9uQ29udGV4dCkge1xuICAgICAgdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0ID0gcHJvcGFnYXRpb25Db250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY3VycmVudCBzY29wZSBhbmQgcmVzZXRzIGl0cyBwcm9wZXJ0aWVzLlxuICAgKiBOb3RlOiBUaGUgY2xpZW50IHdpbGwgbm90IGJlIGNsZWFyZWQuXG4gICAqL1xuICAgY2xlYXIoKSB7XG4gICAgLy8gY2xpZW50IGlzIG5vdCBjbGVhcmVkIGhlcmUgb24gcHVycG9zZSFcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IFtdO1xuICAgIHRoaXMuX3RhZ3MgPSB7fTtcbiAgICB0aGlzLl9leHRyYSA9IHt9O1xuICAgIHRoaXMuX3VzZXIgPSB7fTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIF9zZXRTcGFuRm9yU2NvcGUodGhpcywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHRoaXMuc2V0UHJvcGFnYXRpb25Db250ZXh0KHsgdHJhY2VJZDogZ2VuZXJhdGVUcmFjZUlkKCksIHNhbXBsZVJhbmQ6IE1hdGgucmFuZG9tKCkgfSk7XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBicmVhZGNydW1iIHRvIHRoZSBzY29wZS5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGxhc3QgMTAwIGJyZWFkY3J1bWJzIGFyZSBrZXB0LlxuICAgKi9cbiAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgbWF4QnJlYWRjcnVtYnMpIHtcbiAgICBjb25zdCBtYXhDcnVtYnMgPSB0eXBlb2YgbWF4QnJlYWRjcnVtYnMgPT09ICdudW1iZXInID8gbWF4QnJlYWRjcnVtYnMgOiBERUZBVUxUX01BWF9CUkVBRENSVU1CUztcblxuICAgIC8vIE5vIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCwgc28gZG9uJ3Qgbm90aWZ5IHNjb3BlIGxpc3RlbmVyc1xuICAgIGlmIChtYXhDcnVtYnMgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VkQnJlYWRjcnVtYiA9IHtcbiAgICAgIHRpbWVzdGFtcDogZGF0ZVRpbWVzdGFtcEluU2Vjb25kcygpLFxuICAgICAgLi4uYnJlYWRjcnVtYixcbiAgICAgIC8vIEJyZWFkY3J1bWIgbWVzc2FnZXMgY2FuIHRoZW9yZXRpY2FsbHkgYmUgaW5maW5pdGVseSBsYXJnZSBhbmQgdGhleSdyZSBoZWxkIGluIG1lbW9yeSBzbyB3ZSB0cnVuY2F0ZSB0aGVtIG5vdCB0byBsZWFrICh0b28gbXVjaCkgbWVtb3J5XG4gICAgICBtZXNzYWdlOiBicmVhZGNydW1iLm1lc3NhZ2UgPyB0cnVuY2F0ZShicmVhZGNydW1iLm1lc3NhZ2UsIDIwNDgpIDogYnJlYWRjcnVtYi5tZXNzYWdlLFxuICAgIH07XG5cbiAgICB0aGlzLl9icmVhZGNydW1icy5wdXNoKG1lcmdlZEJyZWFkY3J1bWIpO1xuICAgIGlmICh0aGlzLl9icmVhZGNydW1icy5sZW5ndGggPiBtYXhDcnVtYnMpIHtcbiAgICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gdGhpcy5fYnJlYWRjcnVtYnMuc2xpY2UoLW1heENydW1icyk7XG4gICAgICB0aGlzLl9jbGllbnQ/LnJlY29yZERyb3BwZWRFdmVudCgnYnVmZmVyX292ZXJmbG93JywgJ2xvZ19pdGVtJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBicmVhZGNydW1iIG9mIHRoZSBzY29wZS5cbiAgICovXG4gICBnZXRMYXN0QnJlYWRjcnVtYigpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWRjcnVtYnNbdGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGJyZWFkY3J1bWJzIGZyb20gdGhlIHNjb3BlLlxuICAgKi9cbiAgIGNsZWFyQnJlYWRjcnVtYnMoKSB7XG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhdHRhY2htZW50IHRvIHRoZSBzY29wZS5cbiAgICovXG4gICBhZGRBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICB0aGlzLl9hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBhdHRhY2htZW50cyBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gICBjbGVhckF0dGFjaG1lbnRzKCkge1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIG9mIHRoaXMgc2NvcGUsIHdoaWNoIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFuIGV2ZW50IGR1cmluZyBwcm9jZXNzaW5nLlxuICAgKi9cbiAgIGdldFNjb3BlRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJlYWRjcnVtYnM6IHRoaXMuX2JyZWFkY3J1bWJzLFxuICAgICAgYXR0YWNobWVudHM6IHRoaXMuX2F0dGFjaG1lbnRzLFxuICAgICAgY29udGV4dHM6IHRoaXMuX2NvbnRleHRzLFxuICAgICAgdGFnczogdGhpcy5fdGFncyxcbiAgICAgIGV4dHJhOiB0aGlzLl9leHRyYSxcbiAgICAgIHVzZXI6IHRoaXMuX3VzZXIsXG4gICAgICBsZXZlbDogdGhpcy5fbGV2ZWwsXG4gICAgICBmaW5nZXJwcmludDogdGhpcy5fZmluZ2VycHJpbnQgfHwgW10sXG4gICAgICBldmVudFByb2Nlc3NvcnM6IHRoaXMuX2V2ZW50UHJvY2Vzc29ycyxcbiAgICAgIHByb3BhZ2F0aW9uQ29udGV4dDogdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0LFxuICAgICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICB0cmFuc2FjdGlvbk5hbWU6IHRoaXMuX3RyYW5zYWN0aW9uTmFtZSxcbiAgICAgIHNwYW46IF9nZXRTcGFuRm9yU2NvcGUodGhpcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSB3aGljaCB3aWxsIGJlIGFjY2Vzc2libGUgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmcgYnV0IHdvbid0IGdldCBzZW50IHRvIFNlbnRyeS5cbiAgICovXG4gICBzZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEobmV3RGF0YSkge1xuICAgIHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IG1lcmdlKHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSwgbmV3RGF0YSwgMik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHByb3BhZ2F0aW9uIGNvbnRleHQgdG8gdGhlIHNjb3BlLCB1c2VkIGZvciBkaXN0cmlidXRlZCB0cmFjaW5nXG4gICAqL1xuICAgc2V0UHJvcGFnYXRpb25Db250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gdGhlIHNjb3BlLCB1c2VkIGZvciBkaXN0cmlidXRlZCB0cmFjaW5nXG4gICAqL1xuICAgZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhbiBleGNlcHRpb24gZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgU2VudHJ5IGV2ZW50LlxuICAgKi9cbiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQ/LmV2ZW50X2lkIHx8IHV1aWQ0KCk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hJyk7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ1NlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24nKTtcblxuICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlRXhjZXB0aW9uKFxuICAgICAgZXhjZXB0aW9uLFxuICAgICAge1xuICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb24sXG4gICAgICAgIC4uLmhpbnQsXG4gICAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYSBtZXNzYWdlIGZvciB0aGlzIHNjb3BlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gICAqL1xuICAgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIGhpbnQpIHtcbiAgICBjb25zdCBldmVudElkID0gaGludD8uZXZlbnRfaWQgfHwgdXVpZDQoKTtcblxuICAgIGlmICghdGhpcy5fY2xpZW50KSB7XG4gICAgICBsb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhJyk7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZU1lc3NhZ2UoXG4gICAgICBtZXNzYWdlLFxuICAgICAgbGV2ZWwsXG4gICAgICB7XG4gICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBtZXNzYWdlLFxuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb24sXG4gICAgICAgIC4uLmhpbnQsXG4gICAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYSBTZW50cnkgZXZlbnQgZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgZXZlbnQuXG4gICAqL1xuICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQ/LmV2ZW50X2lkIHx8IHV1aWQ0KCk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBldmVudCEnKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlRXZlbnQoZXZlbnQsIHsgLi4uaGludCwgZXZlbnRfaWQ6IGV2ZW50SWQgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gZXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IHNldCBjYWxsLlxuICAgKi9cbiAgIF9ub3RpZnlTY29wZUxpc3RlbmVycygpIHtcbiAgICAvLyBXZSBuZWVkIHRoaXMgY2hlY2sgZm9yIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyB0byBiZSBhYmxlIHRvIHdvcmsgb24gc2NvcGUgZHVyaW5nIHVwZGF0ZXNcbiAgICAvLyBJZiB0aGlzIGNoZWNrIGlzIG5vdCBoZXJlIHdlJ2xsIHByb2R1Y2UgZW5kbGVzcyByZWN1cnNpb24gd2hlbiBzb21ldGhpbmcgaXMgZG9uZSB3aXRoIHRoZSBzY29wZVxuICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2suXG4gICAgaWYgKCF0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IHRydWU7XG4gICAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBTY29wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/semanticAttributes.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/semanticAttributes.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SEMANTIC_ATTRIBUTE_CACHE_HIT: function() { return /* binding */ SEMANTIC_ATTRIBUTE_CACHE_HIT; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE: function() { return /* binding */ SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_CACHE_KEY: function() { return /* binding */ SEMANTIC_ATTRIBUTE_CACHE_KEY; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME: function() { return /* binding */ SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD: function() { return /* binding */ SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_PROFILE_ID: function() { return /* binding */ SEMANTIC_ATTRIBUTE_PROFILE_ID; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_OP: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_OP; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_SENTRY_SOURCE: function() { return /* binding */ SEMANTIC_ATTRIBUTE_SENTRY_SOURCE; },\n/* harmony export */   SEMANTIC_ATTRIBUTE_URL_FULL: function() { return /* binding */ SEMANTIC_ATTRIBUTE_URL_FULL; },\n/* harmony export */   SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE: function() { return /* binding */ SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE; }\n/* harmony export */ });\n/**\n * Use this attribute to represent the source of a span.\n * Should be one of: custom, url, route, view, component, task, unknown\n *\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';\n\n/**\n * Attributes that holds the sample rate that was locally applied to a span.\n * If this attribute is not defined, it means that the span inherited a sampling decision.\n *\n * NOTE: Is only defined on root spans.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';\n\n/**\n * Use this attribute to represent the operation of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';\n\n/**\n * Use this attribute to represent the origin of a span.\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';\n\n/** The reason why an idle span finished. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason';\n\n/** The unit of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit';\n\n/** The value of a measurement, which may be stored as a TimedEvent. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value';\n\n/**\n * A custom span name set by users guaranteed to be taken over any automatically\n * inferred name. This attribute is removed before the span is sent.\n *\n * @internal only meant for internal SDK usage\n * @hidden\n */\nconst SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name';\n\n/**\n * The id of the profile that this span occurred in.\n */\nconst SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';\n\nconst SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key';\n\nconst SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size';\n\n/** TODO: Remove these once we update to latest semantic conventions */\nconst SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method';\nconst SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full';\n\n/**\n * A span link attribute to mark the link as a special span link.\n *\n * Known values:\n * - `previous_trace`: The span links to the frontend root span of the previous trace.\n * - `next_trace`: The span links to the frontend root span of the next trace. (Not set by the SDK)\n *\n * Other values may be set as appropriate.\n * @see https://develop.sentry.dev/sdk/telemetry/traces/span-links/#link-types\n */\nconst SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type';\n\n\n//# sourceMappingURL=semanticAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zZW1hbnRpY0F0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxbEI7QUFDcmxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zZW1hbnRpY0F0dHJpYnV0ZXMuanM/NWRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSB0aGlzIGF0dHJpYnV0ZSB0byByZXByZXNlbnQgdGhlIHNvdXJjZSBvZiBhIHNwYW4uXG4gKiBTaG91bGQgYmUgb25lIG9mOiBjdXN0b20sIHVybCwgcm91dGUsIHZpZXcsIGNvbXBvbmVudCwgdGFzaywgdW5rbm93blxuICpcbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UgPSAnc2VudHJ5LnNvdXJjZSc7XG5cbi8qKlxuICogQXR0cmlidXRlcyB0aGF0IGhvbGRzIHRoZSBzYW1wbGUgcmF0ZSB0aGF0IHdhcyBsb2NhbGx5IGFwcGxpZWQgdG8gYSBzcGFuLlxuICogSWYgdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGRlZmluZWQsIGl0IG1lYW5zIHRoYXQgdGhlIHNwYW4gaW5oZXJpdGVkIGEgc2FtcGxpbmcgZGVjaXNpb24uXG4gKlxuICogTk9URTogSXMgb25seSBkZWZpbmVkIG9uIHJvb3Qgc3BhbnMuXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEUgPSAnc2VudHJ5LnNhbXBsZV9yYXRlJztcblxuLyoqXG4gKiBVc2UgdGhpcyBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBvcGVyYXRpb24gb2YgYSBzcGFuLlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QID0gJ3NlbnRyeS5vcCc7XG5cbi8qKlxuICogVXNlIHRoaXMgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgb3JpZ2luIG9mIGEgc3Bhbi5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4gPSAnc2VudHJ5Lm9yaWdpbic7XG5cbi8qKiBUaGUgcmVhc29uIHdoeSBhbiBpZGxlIHNwYW4gZmluaXNoZWQuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OID0gJ3NlbnRyeS5pZGxlX3NwYW5fZmluaXNoX3JlYXNvbic7XG5cbi8qKiBUaGUgdW5pdCBvZiBhIG1lYXN1cmVtZW50LCB3aGljaCBtYXkgYmUgc3RvcmVkIGFzIGEgVGltZWRFdmVudC4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVCA9ICdzZW50cnkubWVhc3VyZW1lbnRfdW5pdCc7XG5cbi8qKiBUaGUgdmFsdWUgb2YgYSBtZWFzdXJlbWVudCwgd2hpY2ggbWF5IGJlIHN0b3JlZCBhcyBhIFRpbWVkRXZlbnQuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1ZBTFVFID0gJ3NlbnRyeS5tZWFzdXJlbWVudF92YWx1ZSc7XG5cbi8qKlxuICogQSBjdXN0b20gc3BhbiBuYW1lIHNldCBieSB1c2VycyBndWFyYW50ZWVkIHRvIGJlIHRha2VuIG92ZXIgYW55IGF1dG9tYXRpY2FsbHlcbiAqIGluZmVycmVkIG5hbWUuIFRoaXMgYXR0cmlidXRlIGlzIHJlbW92ZWQgYmVmb3JlIHRoZSBzcGFuIGlzIHNlbnQuXG4gKlxuICogQGludGVybmFsIG9ubHkgbWVhbnQgZm9yIGludGVybmFsIFNESyB1c2FnZVxuICogQGhpZGRlblxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUUgPSAnc2VudHJ5LmN1c3RvbV9zcGFuX25hbWUnO1xuXG4vKipcbiAqIFRoZSBpZCBvZiB0aGUgcHJvZmlsZSB0aGF0IHRoaXMgc3BhbiBvY2N1cnJlZCBpbi5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1BST0ZJTEVfSUQgPSAnc2VudHJ5LnByb2ZpbGVfaWQnO1xuXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUUgPSAnc2VudHJ5LmV4Y2x1c2l2ZV90aW1lJztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0hJVCA9ICdjYWNoZS5oaXQnO1xuXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfS0VZID0gJ2NhY2hlLmtleSc7XG5cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9JVEVNX1NJWkUgPSAnY2FjaGUuaXRlbV9zaXplJztcblxuLyoqIFRPRE86IFJlbW92ZSB0aGVzZSBvbmNlIHdlIHVwZGF0ZSB0byBsYXRlc3Qgc2VtYW50aWMgY29udmVudGlvbnMgKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9EID0gJ2h0dHAucmVxdWVzdC5tZXRob2QnO1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMID0gJ3VybC5mdWxsJztcblxuLyoqXG4gKiBBIHNwYW4gbGluayBhdHRyaWJ1dGUgdG8gbWFyayB0aGUgbGluayBhcyBhIHNwZWNpYWwgc3BhbiBsaW5rLlxuICpcbiAqIEtub3duIHZhbHVlczpcbiAqIC0gYHByZXZpb3VzX3RyYWNlYDogVGhlIHNwYW4gbGlua3MgdG8gdGhlIGZyb250ZW5kIHJvb3Qgc3BhbiBvZiB0aGUgcHJldmlvdXMgdHJhY2UuXG4gKiAtIGBuZXh0X3RyYWNlYDogVGhlIHNwYW4gbGlua3MgdG8gdGhlIGZyb250ZW5kIHJvb3Qgc3BhbiBvZiB0aGUgbmV4dCB0cmFjZS4gKE5vdCBzZXQgYnkgdGhlIFNESylcbiAqXG4gKiBPdGhlciB2YWx1ZXMgbWF5IGJlIHNldCBhcyBhcHByb3ByaWF0ZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL3RlbGVtZXRyeS90cmFjZXMvc3Bhbi1saW5rcy8jbGluay10eXBlc1xuICovXG5jb25zdCBTRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEUgPSAnc2VudHJ5LmxpbmsudHlwZSc7XG5cbmV4cG9ydCB7IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9ISVQsIFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9JVEVNX1NJWkUsIFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9LRVksIFNFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRSwgU0VNQU5USUNfQVRUUklCVVRFX0hUVFBfUkVRVUVTVF9NRVRIT0QsIFNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lELCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfSURMRV9TUEFOX0ZJTklTSF9SRUFTT04sIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVU5JVCwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRSwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4sIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFLCBTRU1BTlRJQ19BVFRSSUJVVEVfVVJMX0ZVTEwsIFNFTUFOVElDX0xJTktfQVRUUklCVVRFX0xJTktfVFlQRSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYW50aWNBdHRyaWJ1dGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/semanticAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/session.js":
/*!*********************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/session.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeSession: function() { return /* binding */ closeSession; },\n/* harmony export */   makeSession: function() { return /* binding */ makeSession; },\n/* harmony export */   updateSession: function() { return /* binding */ updateSession; }\n/* harmony export */ });\n/* harmony import */ var _utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-hoist/misc.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n/* harmony import */ var _utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-hoist/time.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n\n\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)();\n\n  const session = {\n    sid: (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation.  Kamil\n    session.sid = context.sid.length === 32 ? context.sid : (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n\n\n//# sourceMappingURL=session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ2E7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdFQUFrQjs7QUFFekM7QUFDQSxTQUFTLDJEQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsd0VBQWtCOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyREFBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsSUFBSTtBQUNKLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFb0Q7QUFDcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3Nlc3Npb24uanM/NzkzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1dWlkNCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbWlzYy5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFNlc3Npb25gIG9iamVjdCBieSBzZXR0aW5nIGNlcnRhaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLiBJZiBvcHRpb25hbCBAcGFyYW0gY29udGV4dFxuICogaXMgcGFzc2VkLCB0aGUgcGFzc2VkIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IChvcHRpb25hbCkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHNlc3Npb24gb2JqZWN0XG4gKlxuICogQHJldHVybnMgYSBuZXcgYFNlc3Npb25gIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihjb250ZXh0KSB7XG4gIC8vIEJvdGggdGltZXN0YW1wIGFuZCBzdGFydGVkIGFyZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLlxuICBjb25zdCBzdGFydGluZ1RpbWUgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBjb25zdCBzZXNzaW9uID0ge1xuICAgIHNpZDogdXVpZDQoKSxcbiAgICBpbml0OiB0cnVlLFxuICAgIHRpbWVzdGFtcDogc3RhcnRpbmdUaW1lLFxuICAgIHN0YXJ0ZWQ6IHN0YXJ0aW5nVGltZSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBzdGF0dXM6ICdvaycsXG4gICAgZXJyb3JzOiAwLFxuICAgIGlnbm9yZUR1cmF0aW9uOiBmYWxzZSxcbiAgICB0b0pTT046ICgpID0+IHNlc3Npb25Ub0pTT04oc2Vzc2lvbiksXG4gIH07XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNlc3Npb24gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcGFzc2VkIGluIHRoZSBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBvYmplY3QgYW5kIHJldHVybnMgdm9pZC5cbiAqIChIYWQgdG8gZG8gdGhpcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBhbmQgdXBkYXRlZCBzZXNzaW9uIGJlY2F1c2UgY2xvc2luZyBhbmQgc2VuZGluZyBhIHNlc3Npb25cbiAqIG1ha2VzIGFuIHVwZGF0ZSB0byB0aGUgc2Vzc2lvbiBhZnRlciBpdCB3YXMgcGFzc2VkIHRvIHRoZSBzZW5kaW5nIGxvZ2ljLlxuICogQHNlZSBDbGllbnQuY2FwdHVyZVNlc3Npb24gKVxuICpcbiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBgU2Vzc2lvbmAgdG8gdXBkYXRlXG4gKiBAcGFyYW0gY29udGV4dCB0aGUgYFNlc3Npb25Db250ZXh0YCBob2xkaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gQHBhcmFtIHNlc3Npb25cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChjb250ZXh0LnVzZXIpIHtcbiAgICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQudXNlci5pcF9hZGRyZXNzKSB7XG4gICAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQudXNlci5pcF9hZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICghc2Vzc2lvbi5kaWQgJiYgIWNvbnRleHQuZGlkKSB7XG4gICAgICBzZXNzaW9uLmRpZCA9IGNvbnRleHQudXNlci5pZCB8fCBjb250ZXh0LnVzZXIuZW1haWwgfHwgY29udGV4dC51c2VyLnVzZXJuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb24udGltZXN0YW1wID0gY29udGV4dC50aW1lc3RhbXAgfHwgdGltZXN0YW1wSW5TZWNvbmRzKCk7XG5cbiAgaWYgKGNvbnRleHQuYWJub3JtYWxfbWVjaGFuaXNtKSB7XG4gICAgc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20gPSBjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbTtcbiAgfVxuXG4gIGlmIChjb250ZXh0Lmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbiA9IGNvbnRleHQuaWdub3JlRHVyYXRpb247XG4gIH1cbiAgaWYgKGNvbnRleHQuc2lkKSB7XG4gICAgLy8gR29vZCBlbm91Z2ggdXVpZCB2YWxpZGF0aW9uLiDigJQgS2FtaWxcbiAgICBzZXNzaW9uLnNpZCA9IGNvbnRleHQuc2lkLmxlbmd0aCA9PT0gMzIgPyBjb250ZXh0LnNpZCA6IHV1aWQ0KCk7XG4gIH1cbiAgaWYgKGNvbnRleHQuaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2Vzc2lvbi5pbml0ID0gY29udGV4dC5pbml0O1xuICB9XG4gIGlmICghc2Vzc2lvbi5kaWQgJiYgY29udGV4dC5kaWQpIHtcbiAgICBzZXNzaW9uLmRpZCA9IGAke2NvbnRleHQuZGlkfWA7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0LnN0YXJ0ZWQgPT09ICdudW1iZXInKSB7XG4gICAgc2Vzc2lvbi5zdGFydGVkID0gY29udGV4dC5zdGFydGVkO1xuICB9XG4gIGlmIChzZXNzaW9uLmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgc2Vzc2lvbi5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICBzZXNzaW9uLmR1cmF0aW9uID0gY29udGV4dC5kdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNlc3Npb24udGltZXN0YW1wIC0gc2Vzc2lvbi5zdGFydGVkO1xuICAgIHNlc3Npb24uZHVyYXRpb24gPSBkdXJhdGlvbiA+PSAwID8gZHVyYXRpb24gOiAwO1xuICB9XG4gIGlmIChjb250ZXh0LnJlbGVhc2UpIHtcbiAgICBzZXNzaW9uLnJlbGVhc2UgPSBjb250ZXh0LnJlbGVhc2U7XG4gIH1cbiAgaWYgKGNvbnRleHQuZW52aXJvbm1lbnQpIHtcbiAgICBzZXNzaW9uLmVudmlyb25tZW50ID0gY29udGV4dC5lbnZpcm9ubWVudDtcbiAgfVxuICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQuaXBBZGRyZXNzKSB7XG4gICAgc2Vzc2lvbi5pcEFkZHJlc3MgPSBjb250ZXh0LmlwQWRkcmVzcztcbiAgfVxuICBpZiAoIXNlc3Npb24udXNlckFnZW50ICYmIGNvbnRleHQudXNlckFnZW50KSB7XG4gICAgc2Vzc2lvbi51c2VyQWdlbnQgPSBjb250ZXh0LnVzZXJBZ2VudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRleHQuZXJyb3JzID09PSAnbnVtYmVyJykge1xuICAgIHNlc3Npb24uZXJyb3JzID0gY29udGV4dC5lcnJvcnM7XG4gIH1cbiAgaWYgKGNvbnRleHQuc3RhdHVzKSB7XG4gICAgc2Vzc2lvbi5zdGF0dXMgPSBjb250ZXh0LnN0YXR1cztcbiAgfVxufVxuXG4vKipcbiAqIENsb3NlcyBhIHNlc3Npb24gYnkgc2V0dGluZyBpdHMgc3RhdHVzIGFuZCB1cGRhdGluZyB0aGUgc2Vzc2lvbiBvYmplY3Qgd2l0aCBpdC5cbiAqIEludGVybmFsbHkgY2FsbHMgYHVwZGF0ZVNlc3Npb25gIHRvIHVwZGF0ZSB0aGUgcGFzc2VkIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBzZXNzaW9uIChAc2VlIHVwZGF0ZVNlc3Npb24gZm9yIGV4cGxhbmF0aW9uKS5cbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgYFNlc3Npb25gIG9iamVjdCB0byBiZSBjbG9zZWRcbiAqIEBwYXJhbSBzdGF0dXMgdGhlIGBTZXNzaW9uU3RhdHVzYCB3aXRoIHdoaWNoIHRoZSBzZXNzaW9uIHdhcyBjbG9zZWQuIElmIHlvdSBkb24ndCBwYXNzIGEgc3RhdHVzLFxuICogICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIHdpbGwga2VlcCB0aGUgcHJldmlvdXNseSBzZXQgc3RhdHVzLCB1bmxlc3MgaXQgd2FzIGAnb2snYCBpbiB3aGljaCBjYXNlXG4gKiAgICAgICAgICAgICAgIGl0IGlzIGNoYW5nZWQgdG8gYCdleGl0ZWQnYC5cbiAqL1xuZnVuY3Rpb24gY2xvc2VTZXNzaW9uKHNlc3Npb24sIHN0YXR1cykge1xuICBsZXQgY29udGV4dCA9IHt9O1xuICBpZiAoc3RhdHVzKSB7XG4gICAgY29udGV4dCA9IHsgc3RhdHVzIH07XG4gIH0gZWxzZSBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09ICdvaycpIHtcbiAgICBjb250ZXh0ID0geyBzdGF0dXM6ICdleGl0ZWQnIH07XG4gIH1cblxuICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYSBwYXNzZWQgc2Vzc2lvbiBvYmplY3QgdG8gYSBKU09OIG9iamVjdCB3aXRoIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHN0cnVjdHVyZS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIFNlbnRyeSBiYWNrZW5kIHJlcXVpcmVzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHNjaGVtYSBvZiBhIHNlc3Npb25cbiAqIHRoYW4gdGhlIG9uZSB0aGUgSlMgU0RLcyB1c2UgaW50ZXJuYWxseS5cbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgc2Vzc2lvbiB0byBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAcmV0dXJucyBhIEpTT04gb2JqZWN0IG9mIHRoZSBwYXNzZWQgc2Vzc2lvblxuICovXG5mdW5jdGlvbiBzZXNzaW9uVG9KU09OKHNlc3Npb24pIHtcbiAgcmV0dXJuIHtcbiAgICBzaWQ6IGAke3Nlc3Npb24uc2lkfWAsXG4gICAgaW5pdDogc2Vzc2lvbi5pbml0LFxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHNlYyBpcyBjb252ZXJ0ZWQgdG8gbXMgZm9yIGRhdGUgY29uc3RydWN0b3JcbiAgICBzdGFydGVkOiBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0ZWQgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoc2Vzc2lvbi50aW1lc3RhbXAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHN0YXR1czogc2Vzc2lvbi5zdGF0dXMsXG4gICAgZXJyb3JzOiBzZXNzaW9uLmVycm9ycyxcbiAgICBkaWQ6IHR5cGVvZiBzZXNzaW9uLmRpZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNlc3Npb24uZGlkID09PSAnc3RyaW5nJyA/IGAke3Nlc3Npb24uZGlkfWAgOiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IHNlc3Npb24uZHVyYXRpb24sXG4gICAgYWJub3JtYWxfbWVjaGFuaXNtOiBzZXNzaW9uLmFibm9ybWFsX21lY2hhbmlzbSxcbiAgICBhdHRyczoge1xuICAgICAgcmVsZWFzZTogc2Vzc2lvbi5yZWxlYXNlLFxuICAgICAgZW52aXJvbm1lbnQ6IHNlc3Npb24uZW52aXJvbm1lbnQsXG4gICAgICBpcF9hZGRyZXNzOiBzZXNzaW9uLmlwQWRkcmVzcyxcbiAgICAgIHVzZXJfYWdlbnQ6IHNlc3Npb24udXNlckFnZW50LFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCB7IGNsb3NlU2Vzc2lvbiwgbWFrZVNlc3Npb24sIHVwZGF0ZVNlc3Npb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/session.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   freezeDscOnSpan: function() { return /* binding */ freezeDscOnSpan; },\n/* harmony export */   getDynamicSamplingContextFromClient: function() { return /* binding */ getDynamicSamplingContextFromClient; },\n/* harmony export */   getDynamicSamplingContextFromScope: function() { return /* binding */ getDynamicSamplingContextFromScope; },\n/* harmony export */   getDynamicSamplingContextFromSpan: function() { return /* binding */ getDynamicSamplingContextFromSpan; },\n/* harmony export */   spanToBaggageHeader: function() { return /* binding */ spanToBaggageHeader; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/constants.js\");\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../currentScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../semanticAttributes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/semanticAttributes.js\");\n/* harmony import */ var _utils_hasSpansEnabled_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/hasSpansEnabled.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js\");\n/* harmony import */ var _utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/spanUtils.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanUtils.js\");\n/* harmony import */ var _utils_hoist_baggage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils-hoist/baggage.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js\");\n/* harmony import */ var _utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils-hoist/object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/utils.js\");\n\n\n\n\n\n\n\n\n\n/**\n * If you change this value, also update the terser plugin config to\n * avoid minification of the object property!\n */\nconst FROZEN_DSC_FIELD = '_frozenDsc';\n\n/**\n * Freeze the given DSC on the given span.\n */\nfunction freezeDscOnSpan(span, dsc) {\n  const spanWithMaybeDsc = span ;\n  (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__.addNonEnumerableProperty)(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n}\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */\nfunction getDynamicSamplingContextFromClient(trace_id, client) {\n  const options = client.getOptions();\n\n  const { publicKey: public_key } = client.getDsn() || {};\n\n  // Instead of conditionally adding non-undefined values, we add them and then remove them if needed\n  // otherwise, the order of baggage entries changes, which \"breaks\" a bunch of tests etc.\n  const dsc = {\n    environment: options.environment || _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ENVIRONMENT,\n    release: options.release,\n    public_key,\n    trace_id,\n  };\n\n  client.emit('createDsc', dsc);\n\n  return dsc;\n}\n\n/**\n * Get the dynamic sampling context for the currently active scopes.\n */\nfunction getDynamicSamplingContextFromScope(client, scope) {\n  const propagationContext = scope.getPropagationContext();\n  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);\n}\n\n/**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */\nfunction getDynamicSamplingContextFromSpan(span) {\n  const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getClient)();\n  if (!client) {\n    return {};\n  }\n\n  const rootSpan = (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.getRootSpan)(span);\n  const rootSpanJson = (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.spanToJSON)(rootSpan);\n  const rootSpanAttributes = rootSpanJson.data;\n  const traceState = rootSpan.spanContext().traceState;\n\n  // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.\n  // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.\n  const rootSpanSampleRate =\n    traceState?.get('sentry.sample_rate') ?? rootSpanAttributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  function applyLocalSampleRateToDsc(dsc) {\n    if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {\n      dsc.sample_rate = `${rootSpanSampleRate}`;\n    }\n    return dsc;\n  }\n\n  // For core implementation, we freeze the DSC onto the span as a non-enumerable property\n  const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];\n  if (frozenDsc) {\n    return applyLocalSampleRateToDsc(frozenDsc);\n  }\n\n  // For OpenTelemetry, we freeze the DSC on the trace state\n  const traceStateDsc = traceState?.get('sentry.dsc');\n\n  // If the span has a DSC, we want it to take precedence\n  const dscOnTraceState = traceStateDsc && (0,_utils_hoist_baggage_js__WEBPACK_IMPORTED_MODULE_5__.baggageHeaderToDynamicSamplingContext)(traceStateDsc);\n\n  if (dscOnTraceState) {\n    return applyLocalSampleRateToDsc(dscOnTraceState);\n  }\n\n  // Else, we generate it from the span\n  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);\n\n  // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n  const source = rootSpanAttributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n  // after JSON conversion, txn.name becomes jsonSpan.description\n  const name = rootSpanJson.description;\n  if (source !== 'url' && name) {\n    dsc.transaction = name;\n  }\n\n  // How can we even land here with hasSpansEnabled() returning false?\n  // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests\n  // So we end up with an active span that is not sampled (neither positively nor negatively)\n  if ((0,_utils_hasSpansEnabled_js__WEBPACK_IMPORTED_MODULE_6__.hasSpansEnabled)()) {\n    dsc.sampled = String((0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.spanIsSampled)(rootSpan));\n    dsc.sample_rand =\n      // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans\n      // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span\n      traceState?.get('sentry.sample_rand') ??\n      // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.getCapturedScopesOnSpan)(rootSpan).scope?.getPropagationContext().sampleRand.toString();\n  }\n\n  applyLocalSampleRateToDsc(dsc);\n\n  client.emit('createDsc', dsc, rootSpan);\n\n  return dsc;\n}\n\n/**\n * Convert a Span to a baggage header.\n */\nfunction spanToBaggageHeader(span) {\n  const dsc = getDynamicSamplingContextFromSpan(span);\n  return (0,_utils_hoist_baggage_js__WEBPACK_IMPORTED_MODULE_5__.dynamicSamplingContextToSentryBaggageHeader)(dsc);\n}\n\n\n//# sourceMappingURL=dynamicSamplingContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNOO0FBQ21FO0FBQ3JEO0FBQ2lCO0FBQ2dEO0FBQzNEO0FBQ2Y7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0ZBQXdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsd0JBQXdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOERBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdFQUFXO0FBQzlCLHVCQUF1QiwrREFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx5RkFBcUM7QUFDckc7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyw4RkFBcUM7O0FBRWhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLG9GQUFnQzs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBFQUFlO0FBQ3JCLHlCQUF5QixrRUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBdUI7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvR0FBMkM7QUFDcEQ7O0FBRTRKO0FBQzVKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanM/ZDViZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX0VOVklST05NRU5UIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldENsaWVudCB9IGZyb20gJy4uL2N1cnJlbnRTY29wZXMuanMnO1xuaW1wb3J0IHsgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURSwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UgfSBmcm9tICcuLi9zZW1hbnRpY0F0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaGFzU3BhbnNFbmFibGVkIH0gZnJvbSAnLi4vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzJztcbmltcG9ydCB7IGdldFJvb3RTcGFuLCBzcGFuVG9KU09OLCBzcGFuSXNTYW1wbGVkIH0gZnJvbSAnLi4vdXRpbHMvc3BhblV0aWxzLmpzJztcbmltcG9ydCB7IGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQsIGR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIgfSBmcm9tICcuLi91dGlscy1ob2lzdC9iYWdnYWdlLmpzJztcbmltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcyc7XG5pbXBvcnQgeyBnZXRDYXB0dXJlZFNjb3Blc09uU3BhbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIElmIHlvdSBjaGFuZ2UgdGhpcyB2YWx1ZSwgYWxzbyB1cGRhdGUgdGhlIHRlcnNlciBwbHVnaW4gY29uZmlnIHRvXG4gKiBhdm9pZCBtaW5pZmljYXRpb24gb2YgdGhlIG9iamVjdCBwcm9wZXJ0eSFcbiAqL1xuY29uc3QgRlJPWkVOX0RTQ19GSUVMRCA9ICdfZnJvemVuRHNjJztcblxuLyoqXG4gKiBGcmVlemUgdGhlIGdpdmVuIERTQyBvbiB0aGUgZ2l2ZW4gc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZnJlZXplRHNjT25TcGFuKHNwYW4sIGRzYykge1xuICBjb25zdCBzcGFuV2l0aE1heWJlRHNjID0gc3BhbiA7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzcGFuV2l0aE1heWJlRHNjLCBGUk9aRU5fRFNDX0ZJRUxELCBkc2MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZnJvbSBhIGNsaWVudC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRoZSBgY3JlYXRlRHNjYCBsaWZlY3ljbGUgaG9vayBhcyBhIHNpZGUgZWZmZWN0LlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudCh0cmFjZV9pZCwgY2xpZW50KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNfa2V5IH0gPSBjbGllbnQuZ2V0RHNuKCkgfHwge307XG5cbiAgLy8gSW5zdGVhZCBvZiBjb25kaXRpb25hbGx5IGFkZGluZyBub24tdW5kZWZpbmVkIHZhbHVlcywgd2UgYWRkIHRoZW0gYW5kIHRoZW4gcmVtb3ZlIHRoZW0gaWYgbmVlZGVkXG4gIC8vIG90aGVyd2lzZSwgdGhlIG9yZGVyIG9mIGJhZ2dhZ2UgZW50cmllcyBjaGFuZ2VzLCB3aGljaCBcImJyZWFrc1wiIGEgYnVuY2ggb2YgdGVzdHMgZXRjLlxuICBjb25zdCBkc2MgPSB7XG4gICAgZW52aXJvbm1lbnQ6IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgICByZWxlYXNlOiBvcHRpb25zLnJlbGVhc2UsXG4gICAgcHVibGljX2tleSxcbiAgICB0cmFjZV9pZCxcbiAgfTtcblxuICBjbGllbnQuZW1pdCgnY3JlYXRlRHNjJywgZHNjKTtcblxuICByZXR1cm4gZHNjO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY29wZXMuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU2NvcGUoY2xpZW50LCBzY29wZSkge1xuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcbiAgcmV0dXJuIHByb3BhZ2F0aW9uQ29udGV4dC5kc2MgfHwgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQocHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsIGNsaWVudCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBmcm9tIGEgc3BhbiAoYW5kIGNsaWVudCBhbmQgc2NvcGUpXG4gKlxuICogQHBhcmFtIHNwYW4gdGhlIHNwYW4gZnJvbSB3aGljaCBhIGZldyB2YWx1ZXMgbGlrZSB0aGUgcm9vdCBzcGFuIG5hbWUgYW5kIHNhbXBsZSByYXRlIGFyZSBleHRyYWN0ZWQuXG4gKlxuICogQHJldHVybnMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3Qgcm9vdFNwYW4gPSBnZXRSb290U3BhbihzcGFuKTtcbiAgY29uc3Qgcm9vdFNwYW5Kc29uID0gc3BhblRvSlNPTihyb290U3Bhbik7XG4gIGNvbnN0IHJvb3RTcGFuQXR0cmlidXRlcyA9IHJvb3RTcGFuSnNvbi5kYXRhO1xuICBjb25zdCB0cmFjZVN0YXRlID0gcm9vdFNwYW4uc3BhbkNvbnRleHQoKS50cmFjZVN0YXRlO1xuXG4gIC8vIFRoZSBzcGFuIHNhbXBsZSByYXRlIHRoYXQgd2FzIGxvY2FsbHkgYXBwbGllZCB0byB0aGUgcm9vdCBzcGFuIHNob3VsZCBhbHNvIGFsd2F5cyBiZSBhcHBsaWVkIHRvIHRoZSBEU0MsIGV2ZW4gaWYgdGhlIERTQyBpcyBmcm96ZW4uXG4gIC8vIFRoaXMgaXMgc28gdGhhdCB0aGUgZG93bnN0cmVhbSB0cmFjZXMvc2VydmljZXMgY2FuIHVzZSBwYXJlbnRTYW1wbGVSYXRlIGluIHRoZWlyIGB0cmFjZXNTYW1wbGVyYCB0byBtYWtlIGNvbnNpc3RlbnQgc2FtcGxpbmcgZGVjaXNpb25zIGFjcm9zcyB0aGUgZW50aXJlIHRyYWNlLlxuICBjb25zdCByb290U3BhblNhbXBsZVJhdGUgPVxuICAgIHRyYWNlU3RhdGU/LmdldCgnc2VudHJ5LnNhbXBsZV9yYXRlJykgPz8gcm9vdFNwYW5BdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdO1xuICBmdW5jdGlvbiBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGRzYykge1xuICAgIGlmICh0eXBlb2Ygcm9vdFNwYW5TYW1wbGVSYXRlID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygcm9vdFNwYW5TYW1wbGVSYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgZHNjLnNhbXBsZV9yYXRlID0gYCR7cm9vdFNwYW5TYW1wbGVSYXRlfWA7XG4gICAgfVxuICAgIHJldHVybiBkc2M7XG4gIH1cblxuICAvLyBGb3IgY29yZSBpbXBsZW1lbnRhdGlvbiwgd2UgZnJlZXplIHRoZSBEU0Mgb250byB0aGUgc3BhbiBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG4gIGNvbnN0IGZyb3plbkRzYyA9IChyb290U3BhbiApW0ZST1pFTl9EU0NfRklFTERdO1xuICBpZiAoZnJvemVuRHNjKSB7XG4gICAgcmV0dXJuIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZnJvemVuRHNjKTtcbiAgfVxuXG4gIC8vIEZvciBPcGVuVGVsZW1ldHJ5LCB3ZSBmcmVlemUgdGhlIERTQyBvbiB0aGUgdHJhY2Ugc3RhdGVcbiAgY29uc3QgdHJhY2VTdGF0ZURzYyA9IHRyYWNlU3RhdGU/LmdldCgnc2VudHJ5LmRzYycpO1xuXG4gIC8vIElmIHRoZSBzcGFuIGhhcyBhIERTQywgd2Ugd2FudCBpdCB0byB0YWtlIHByZWNlZGVuY2VcbiAgY29uc3QgZHNjT25UcmFjZVN0YXRlID0gdHJhY2VTdGF0ZURzYyAmJiBiYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KHRyYWNlU3RhdGVEc2MpO1xuXG4gIGlmIChkc2NPblRyYWNlU3RhdGUpIHtcbiAgICByZXR1cm4gYXBwbHlMb2NhbFNhbXBsZVJhdGVUb0RzYyhkc2NPblRyYWNlU3RhdGUpO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgZ2VuZXJhdGUgaXQgZnJvbSB0aGUgc3BhblxuICBjb25zdCBkc2MgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudChzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZCwgY2xpZW50KTtcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIGhhdmUgYSB0cmFuc2FjdGlvbiBuYW1lIGluIHRoZSBEU0MgaWYgdGhlIHNvdXJjZSBpcyBcInVybFwiIGJlY2F1c2UgVVJMcyBtaWdodCBjb250YWluIFBJSVxuICBjb25zdCBzb3VyY2UgPSByb290U3BhbkF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdO1xuXG4gIC8vIGFmdGVyIEpTT04gY29udmVyc2lvbiwgdHhuLm5hbWUgYmVjb21lcyBqc29uU3Bhbi5kZXNjcmlwdGlvblxuICBjb25zdCBuYW1lID0gcm9vdFNwYW5Kc29uLmRlc2NyaXB0aW9uO1xuICBpZiAoc291cmNlICE9PSAndXJsJyAmJiBuYW1lKSB7XG4gICAgZHNjLnRyYW5zYWN0aW9uID0gbmFtZTtcbiAgfVxuXG4gIC8vIEhvdyBjYW4gd2UgZXZlbiBsYW5kIGhlcmUgd2l0aCBoYXNTcGFuc0VuYWJsZWQoKSByZXR1cm5pbmcgZmFsc2U/XG4gIC8vIE90ZWwgY3JlYXRlcyBhIE5vbi1yZWNvcmRpbmcgc3BhbiBpbiBUcmFjaW5nIFdpdGhvdXQgUGVyZm9ybWFuY2UgbW9kZSB3aGVuIGhhbmRsaW5nIGluY29taW5nIHJlcXVlc3RzXG4gIC8vIFNvIHdlIGVuZCB1cCB3aXRoIGFuIGFjdGl2ZSBzcGFuIHRoYXQgaXMgbm90IHNhbXBsZWQgKG5laXRoZXIgcG9zaXRpdmVseSBub3IgbmVnYXRpdmVseSlcbiAgaWYgKGhhc1NwYW5zRW5hYmxlZCgpKSB7XG4gICAgZHNjLnNhbXBsZWQgPSBTdHJpbmcoc3BhbklzU2FtcGxlZChyb290U3BhbikpO1xuICAgIGRzYy5zYW1wbGVfcmFuZCA9XG4gICAgICAvLyBJbiBPVEVMIHdlIHN0b3JlIHRoZSBzYW1wbGUgcmFuZCBvbiB0aGUgdHJhY2Ugc3RhdGUgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjZXNzIHNjb3BlcyBmb3IgTm9uUmVjb3JkaW5nU3BhbnNcbiAgICAgIC8vIFRoZSBTZW50cnkgT1RFTCBTcGFuU2FtcGxlciB0YWtlcyBjYXJlIG9mIHdyaXRpbmcgdGhlIHNhbXBsZSByYW5kIG9uIHRoZSByb290IHNwYW5cbiAgICAgIHRyYWNlU3RhdGU/LmdldCgnc2VudHJ5LnNhbXBsZV9yYW5kJykgPz9cbiAgICAgIC8vIE9uIGFsbCBvdGhlciBwbGF0Zm9ybXMgd2UgY2FuIGFjdHVhbGx5IGdldCB0aGUgc2NvcGVzIGZyb20gYSByb290IHNwYW4gKHdlIHVzZSB0aGlzIGFzIGEgZmFsbGJhY2spXG4gICAgICBnZXRDYXB0dXJlZFNjb3Blc09uU3Bhbihyb290U3Bhbikuc2NvcGU/LmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLnNhbXBsZVJhbmQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZHNjKTtcblxuICBjbGllbnQuZW1pdCgnY3JlYXRlRHNjJywgZHNjLCByb290U3Bhbik7XG5cbiAgcmV0dXJuIGRzYztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgU3BhbiB0byBhIGJhZ2dhZ2UgaGVhZGVyLlxuICovXG5mdW5jdGlvbiBzcGFuVG9CYWdnYWdlSGVhZGVyKHNwYW4pIHtcbiAgY29uc3QgZHNjID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuICByZXR1cm4gZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkc2MpO1xufVxuXG5leHBvcnQgeyBmcmVlemVEc2NPblNwYW4sIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50LCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlLCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4sIHNwYW5Ub0JhZ2dhZ2VIZWFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/spanstatus.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/tracing/spanstatus.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SPAN_STATUS_ERROR: function() { return /* binding */ SPAN_STATUS_ERROR; },\n/* harmony export */   SPAN_STATUS_OK: function() { return /* binding */ SPAN_STATUS_OK; },\n/* harmony export */   SPAN_STATUS_UNSET: function() { return /* binding */ SPAN_STATUS_UNSET; },\n/* harmony export */   getSpanStatusFromHttpCode: function() { return /* binding */ getSpanStatusFromHttpCode; },\n/* harmony export */   setHttpStatus: function() { return /* binding */ setHttpStatus; }\n/* harmony export */ });\nconst SPAN_STATUS_UNSET = 0;\nconst SPAN_STATUS_OK = 1;\nconst SPAN_STATUS_ERROR = 2;\n\n/**\n * Converts a HTTP status code into a sentry status with a message.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\n// https://develop.sentry.dev/sdk/event-payloads/span/\nfunction getSpanStatusFromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return { code: SPAN_STATUS_OK };\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return { code: SPAN_STATUS_ERROR, message: 'unauthenticated' };\n      case 403:\n        return { code: SPAN_STATUS_ERROR, message: 'permission_denied' };\n      case 404:\n        return { code: SPAN_STATUS_ERROR, message: 'not_found' };\n      case 409:\n        return { code: SPAN_STATUS_ERROR, message: 'already_exists' };\n      case 413:\n        return { code: SPAN_STATUS_ERROR, message: 'failed_precondition' };\n      case 429:\n        return { code: SPAN_STATUS_ERROR, message: 'resource_exhausted' };\n      case 499:\n        return { code: SPAN_STATUS_ERROR, message: 'cancelled' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'invalid_argument' };\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return { code: SPAN_STATUS_ERROR, message: 'unimplemented' };\n      case 503:\n        return { code: SPAN_STATUS_ERROR, message: 'unavailable' };\n      case 504:\n        return { code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' };\n      default:\n        return { code: SPAN_STATUS_ERROR, message: 'internal_error' };\n    }\n  }\n\n  return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n}\n\n/**\n * Sets the Http status attributes on the current span based on the http code.\n * Additionally, the span's status is updated, depending on the http code.\n */\nfunction setHttpStatus(span, httpStatus) {\n  span.setAttribute('http.response.status_code', httpStatus);\n\n  const spanStatus = getSpanStatusFromHttpCode(httpStatus);\n  if (spanStatus.message !== 'unknown_error') {\n    span.setStatus(spanStatus);\n  }\n}\n\n\n//# sourceMappingURL=spanstatus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS90cmFjaW5nL3NwYW5zdGF0dXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEc7QUFDMUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNpbmcvc3BhbnN0YXR1cy5qcz9kNDkwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNQQU5fU1RBVFVTX1VOU0VUID0gMDtcbmNvbnN0IFNQQU5fU1RBVFVTX09LID0gMTtcbmNvbnN0IFNQQU5fU1RBVFVTX0VSUk9SID0gMjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEhUVFAgc3RhdHVzIGNvZGUgaW50byBhIHNlbnRyeSBzdGF0dXMgd2l0aCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGh0dHBTdGF0dXMgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gKiBAcmV0dXJucyBUaGUgc3BhbiBzdGF0dXMgb3IgdW5rbm93bl9lcnJvci5cbiAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL2V2ZW50LXBheWxvYWRzL3NwYW4vXG5mdW5jdGlvbiBnZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKGh0dHBTdGF0dXMpIHtcbiAgaWYgKGh0dHBTdGF0dXMgPCA0MDAgJiYgaHR0cFN0YXR1cyA+PSAxMDApIHtcbiAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19PSyB9O1xuICB9XG5cbiAgaWYgKGh0dHBTdGF0dXMgPj0gNDAwICYmIGh0dHBTdGF0dXMgPCA1MDApIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgIGNhc2UgNDAxOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3VuYXV0aGVudGljYXRlZCcgfTtcbiAgICAgIGNhc2UgNDAzOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Blcm1pc3Npb25fZGVuaWVkJyB9O1xuICAgICAgY2FzZSA0MDQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnbm90X2ZvdW5kJyB9O1xuICAgICAgY2FzZSA0MDk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnYWxyZWFkeV9leGlzdHMnIH07XG4gICAgICBjYXNlIDQxMzpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdmYWlsZWRfcHJlY29uZGl0aW9uJyB9O1xuICAgICAgY2FzZSA0Mjk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAncmVzb3VyY2VfZXhoYXVzdGVkJyB9O1xuICAgICAgY2FzZSA0OTk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnY2FuY2VsbGVkJyB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdpbnZhbGlkX2FyZ3VtZW50JyB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChodHRwU3RhdHVzID49IDUwMCAmJiBodHRwU3RhdHVzIDwgNjAwKSB7XG4gICAgc3dpdGNoIChodHRwU3RhdHVzKSB7XG4gICAgICBjYXNlIDUwMTpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmltcGxlbWVudGVkJyB9O1xuICAgICAgY2FzZSA1MDM6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5hdmFpbGFibGUnIH07XG4gICAgICBjYXNlIDUwNDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdkZWFkbGluZV9leGNlZWRlZCcgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW50ZXJuYWxfZXJyb3InIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIEh0dHAgc3RhdHVzIGF0dHJpYnV0ZXMgb24gdGhlIGN1cnJlbnQgc3BhbiBiYXNlZCBvbiB0aGUgaHR0cCBjb2RlLlxuICogQWRkaXRpb25hbGx5LCB0aGUgc3BhbidzIHN0YXR1cyBpcyB1cGRhdGVkLCBkZXBlbmRpbmcgb24gdGhlIGh0dHAgY29kZS5cbiAqL1xuZnVuY3Rpb24gc2V0SHR0cFN0YXR1cyhzcGFuLCBodHRwU3RhdHVzKSB7XG4gIHNwYW4uc2V0QXR0cmlidXRlKCdodHRwLnJlc3BvbnNlLnN0YXR1c19jb2RlJywgaHR0cFN0YXR1cyk7XG5cbiAgY29uc3Qgc3BhblN0YXR1cyA9IGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUoaHR0cFN0YXR1cyk7XG4gIGlmIChzcGFuU3RhdHVzLm1lc3NhZ2UgIT09ICd1bmtub3duX2Vycm9yJykge1xuICAgIHNwYW4uc2V0U3RhdHVzKHNwYW5TdGF0dXMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFNQQU5fU1RBVFVTX0VSUk9SLCBTUEFOX1NUQVRVU19PSywgU1BBTl9TVEFUVVNfVU5TRVQsIGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUsIHNldEh0dHBTdGF0dXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwYW5zdGF0dXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/spanstatus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/utils.js":
/*!***************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/tracing/utils.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCapturedScopesOnSpan: function() { return /* binding */ getCapturedScopesOnSpan; },\n/* harmony export */   setCapturedScopesOnSpan: function() { return /* binding */ setCapturedScopesOnSpan; }\n/* harmony export */ });\n/* harmony import */ var _utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils-hoist/object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n\n\nconst SCOPE_ON_START_SPAN_FIELD = '_sentryScope';\nconst ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';\n\n/** Store the scope & isolation scope for a span, which can the be used when it is finished. */\nfunction setCapturedScopesOnSpan(span, scope, isolationScope) {\n  if (span) {\n    (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__.addNonEnumerableProperty)(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n    (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__.addNonEnumerableProperty)(span, SCOPE_ON_START_SPAN_FIELD, scope);\n  }\n}\n\n/**\n * Grabs the scope and isolation scope off a span that were active when the span was started.\n */\nfunction getCapturedScopesOnSpan(span) {\n  return {\n    scope: (span )[SCOPE_ON_START_SPAN_FIELD],\n    isolationScope: (span )[ISOLATION_SCOPE_ON_START_SPAN_FIELD],\n  };\n}\n\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS90cmFjaW5nL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdGQUF3QjtBQUM1QixJQUFJLGdGQUF3QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNpbmcvdXRpbHMuanM/ZjgzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkgfSBmcm9tICcuLi91dGlscy1ob2lzdC9vYmplY3QuanMnO1xuXG5jb25zdCBTQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEID0gJ19zZW50cnlTY29wZSc7XG5jb25zdCBJU09MQVRJT05fU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRCA9ICdfc2VudHJ5SXNvbGF0aW9uU2NvcGUnO1xuXG4vKiogU3RvcmUgdGhlIHNjb3BlICYgaXNvbGF0aW9uIHNjb3BlIGZvciBhIHNwYW4sIHdoaWNoIGNhbiB0aGUgYmUgdXNlZCB3aGVuIGl0IGlzIGZpbmlzaGVkLiAqL1xuZnVuY3Rpb24gc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGUsIGlzb2xhdGlvblNjb3BlKSB7XG4gIGlmIChzcGFuKSB7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIElTT0xBVElPTl9TQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxELCBpc29sYXRpb25TY29wZSk7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIFNDT1BFX09OX1NUQVJUX1NQQU5fRklFTEQsIHNjb3BlKTtcbiAgfVxufVxuXG4vKipcbiAqIEdyYWJzIHRoZSBzY29wZSBhbmQgaXNvbGF0aW9uIHNjb3BlIG9mZiBhIHNwYW4gdGhhdCB3ZXJlIGFjdGl2ZSB3aGVuIHRoZSBzcGFuIHdhcyBzdGFydGVkLlxuICovXG5mdW5jdGlvbiBnZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuKSB7XG4gIHJldHVybiB7XG4gICAgc2NvcGU6IChzcGFuIClbU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRF0sXG4gICAgaXNvbGF0aW9uU2NvcGU6IChzcGFuIClbSVNPTEFUSU9OX1NDT1BFX09OX1NUQVJUX1NQQU5fRklFTERdLFxuICB9O1xufVxuXG5leHBvcnQgeyBnZXRDYXB0dXJlZFNjb3Blc09uU3Bhbiwgc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_BAGGAGE_STRING_LENGTH: function() { return /* binding */ MAX_BAGGAGE_STRING_LENGTH; },\n/* harmony export */   SENTRY_BAGGAGE_KEY_PREFIX: function() { return /* binding */ SENTRY_BAGGAGE_KEY_PREFIX; },\n/* harmony export */   SENTRY_BAGGAGE_KEY_PREFIX_REGEX: function() { return /* binding */ SENTRY_BAGGAGE_KEY_PREFIX_REGEX; },\n/* harmony export */   baggageHeaderToDynamicSamplingContext: function() { return /* binding */ baggageHeaderToDynamicSamplingContext; },\n/* harmony export */   dynamicSamplingContextToSentryBaggageHeader: function() { return /* binding */ dynamicSamplingContextToSentryBaggageHeader; },\n/* harmony export */   objectToBaggageHeader: function() { return /* binding */ objectToBaggageHeader; },\n/* harmony export */   parseBaggageHeader: function() { return /* binding */ parseBaggageHeader; }\n/* harmony export */ });\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js\");\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n\n\n\n\nconst SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nconst MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  const baggageObject = parseBaggageHeader(baggageHeader);\n\n  if (!baggageObject) {\n    return undefined;\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  if (!dynamicSamplingContext) {\n    return undefined;\n  }\n\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Take a baggage header and parse it into an object.\n */\nfunction parseBaggageHeader(\n  baggageHeader,\n) {\n  if (!baggageHeader || (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(baggageHeader) && !Array.isArray(baggageHeader))) {\n    return undefined;\n  }\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    return baggageHeader.reduce((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      Object.entries(currBaggageObject).forEach(([key, value]) => {\n        acc[key] = value;\n      });\n      return acc;\n    }, {});\n  }\n\n  return baggageHeaderToObject(baggageHeader);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce((acc, [key, value]) => {\n      if (key && value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD &&\n        _logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\n\n//# sourceMappingURL=baggage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9iYWdnYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDWjtBQUNFOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQixFQUFFLE9BQU87QUFDbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEIsR0FBRyxnQ0FBZ0M7QUFDN0Ysb0VBQW9FLGNBQWMsR0FBRyxhQUFhO0FBQ2xHO0FBQ0EsTUFBTSx3REFBVztBQUNqQixRQUFRLDhDQUFNO0FBQ2QsNkJBQTZCLFdBQVcsWUFBWSxhQUFhO0FBQ2pFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFZ087QUFDaE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2JhZ2dhZ2UuanM/Yjk0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLmpzJztcblxuY29uc3QgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCA9ICdzZW50cnktJztcblxuY29uc3QgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCA9IC9ec2VudHJ5LS87XG5cbi8qKlxuICogTWF4IGxlbmd0aCBvZiBhIHNlcmlhbGl6ZWQgYmFnZ2FnZSBzdHJpbmdcbiAqXG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvYmFnZ2FnZS8jbGltaXRzXG4gKi9cbmNvbnN0IE1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEggPSA4MTkyO1xuXG4vKipcbiAqIFRha2VzIGEgYmFnZ2FnZSBoZWFkZXIgYW5kIHR1cm5zIGl0IGludG8gRHluYW1pYyBTYW1wbGluZyBDb250ZXh0LCBieSBleHRyYWN0aW5nIGFsbCB0aGUgXCJzZW50cnktXCIgcHJlZml4ZWQgdmFsdWVzXG4gKiBmcm9tIGl0LlxuICpcbiAqIEBwYXJhbSBiYWdnYWdlSGVhZGVyIEEgdmVyeSBicmVhZCBkZWZpbml0aW9uIG9mIGEgYmFnZ2FnZSBoZWFkZXIgYXMgaXQgbWlnaHQgYXBwZWFyIGluIHZhcmlvdXMgZnJhbWV3b3Jrcy5cbiAqIEByZXR1cm5zIFRoZSBEeW5hbWljIFNhbXBsaW5nIENvbnRleHQgdGhhdCB3YXMgZm91bmQgb24gYGJhZ2dhZ2VIZWFkZXJgLCBpZiB0aGVyZSB3YXMgYW55LCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoXG4gIC8vIFZlcnkgbGliZXJhbCBkZWZpbml0aW9uIG9mIHdoYXQgYW55IGluY29taW5nIGhlYWRlciBtaWdodCBsb29rIGxpa2VcbiAgYmFnZ2FnZUhlYWRlcixcbikge1xuICBjb25zdCBiYWdnYWdlT2JqZWN0ID0gcGFyc2VCYWdnYWdlSGVhZGVyKGJhZ2dhZ2VIZWFkZXIpO1xuXG4gIGlmICghYmFnZ2FnZU9iamVjdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBSZWFkIGFsbCBcInNlbnRyeS1cIiBwcmVmaXhlZCB2YWx1ZXMgb3V0IG9mIHRoZSBiYWdnYWdlIG9iamVjdCBhbmQgcHV0IGl0IG9udG8gYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgb2JqZWN0LlxuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gT2JqZWN0LmVudHJpZXMoYmFnZ2FnZU9iamVjdCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkubWF0Y2goU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCkpIHtcbiAgICAgIGNvbnN0IG5vblByZWZpeGVkS2V5ID0ga2V5LnNsaWNlKFNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVgubGVuZ3RoKTtcbiAgICAgIGFjY1tub25QcmVmaXhlZEtleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIC8vIE9ubHkgcmV0dXJuIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IG9iamVjdCBpZiB0aGVyZSBhcmUga2V5cyBpbiBpdC5cbiAgLy8gQSBrZXlsZXNzIG9iamVjdCBtZWFucyB0aGVyZSB3ZXJlIG5vIHNlbnRyeSB2YWx1ZXMgb24gdGhlIGhlYWRlciwgd2hpY2ggbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBEU0MuXG4gIGlmIChPYmplY3Qua2V5cyhkeW5hbWljU2FtcGxpbmdDb250ZXh0KS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUdXJucyBhIER5bmFtaWMgU2FtcGxpbmcgT2JqZWN0IGludG8gYSBiYWdnYWdlIGhlYWRlciBieSBwcmVmaXhpbmcgYWxsIHRoZSBrZXlzIG9uIHRoZSBvYmplY3Qgd2l0aCBcInNlbnRyeS1cIi5cbiAqXG4gKiBAcGFyYW0gZHluYW1pY1NhbXBsaW5nQ29udGV4dCBUaGUgRHluYW1pYyBTYW1wbGluZyBDb250ZXh0IHRvIHR1cm4gaW50byBhIGhlYWRlci4gRm9yIGNvbnZlbmllbmNlIGFuZCBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIHRoZSBgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dGAgbWV0aG9kIG9uIHRoZSBUcmFuc2FjdGlvbiBjbGFzcyAsdGhpcyBhcmd1bWVudCBjYW4gYWxzbyBiZSBgdW5kZWZpbmVkYC4gSWYgaXQgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm5zIGEgYmFnZ2FnZSBoZWFkZXIsIGNyZWF0ZWQgZnJvbSBgZHluYW1pY1NhbXBsaW5nQ29udGV4dGAsIG9yIGB1bmRlZmluZWRgIGVpdGhlciBpZiBgZHluYW1pY1NhbXBsaW5nQ29udGV4dGBcbiAqIHdhcyBgdW5kZWZpbmVkYCwgb3IgaWYgYGR5bmFtaWNTYW1wbGluZ0NvbnRleHRgIGRpZG4ndCBjb250YWluIGFueSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoXG4gIC8vIHRoaXMgYWxzbyB0YWtlcyB1bmRlZmluZWQgZm9yIGNvbnZlbmllbmNlIGFuZCBidW5kbGUgc2l6ZSBpbiBvdGhlciBwbGFjZXNcbiAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbikge1xuICBpZiAoIWR5bmFtaWNTYW1wbGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gUHJlZml4IGFsbCBEU0Mga2V5cyB3aXRoIFwic2VudHJ5LVwiIGFuZCBwdXQgdGhlbSBpbnRvIGEgbmV3IG9iamVjdFxuICBjb25zdCBzZW50cnlQcmVmaXhlZERTQyA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZShcbiAgICAoYWNjLCBbZHNjS2V5LCBkc2NWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICBhY2NbYCR7U0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWH0ke2RzY0tleX1gXSA9IGRzY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9LFxuICApO1xuXG4gIHJldHVybiBvYmplY3RUb0JhZ2dhZ2VIZWFkZXIoc2VudHJ5UHJlZml4ZWREU0MpO1xufVxuXG4vKipcbiAqIFRha2UgYSBiYWdnYWdlIGhlYWRlciBhbmQgcGFyc2UgaXQgaW50byBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQmFnZ2FnZUhlYWRlcihcbiAgYmFnZ2FnZUhlYWRlcixcbikge1xuICBpZiAoIWJhZ2dhZ2VIZWFkZXIgfHwgKCFpc1N0cmluZyhiYWdnYWdlSGVhZGVyKSAmJiAhQXJyYXkuaXNBcnJheShiYWdnYWdlSGVhZGVyKSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFnZ2FnZUhlYWRlcikpIHtcbiAgICAvLyBDb21iaW5lIGFsbCBiYWdnYWdlIGhlYWRlcnMgaW50byBvbmUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGJhZ2dhZ2UgdmFsdWVzIHNvIHdlIGNhbiBsYXRlciByZWFkIHRoZSBTZW50cnktRFNDLXZhbHVlcyBmcm9tIGl0XG4gICAgcmV0dXJuIGJhZ2dhZ2VIZWFkZXIucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJCYWdnYWdlT2JqZWN0ID0gYmFnZ2FnZUhlYWRlclRvT2JqZWN0KGN1cnIpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoY3VyckJhZ2dhZ2VPYmplY3QpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHJldHVybiBiYWdnYWdlSGVhZGVyVG9PYmplY3QoYmFnZ2FnZUhlYWRlcik7XG59XG5cbi8qKlxuICogV2lsbCBwYXJzZSBhIGJhZ2dhZ2UgaGVhZGVyLCB3aGljaCBpcyBhIHNpbXBsZSBrZXktdmFsdWUgbWFwLCBpbnRvIGEgZmxhdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGJhZ2dhZ2VIZWFkZXIgVGhlIGJhZ2dhZ2UgaGVhZGVyIHRvIHBhcnNlLlxuICogQHJldHVybnMgYSBmbGF0IG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUga2V5LXZhbHVlIHBhaXJzIGZyb20gYGJhZ2dhZ2VIZWFkZXJgLlxuICovXG5mdW5jdGlvbiBiYWdnYWdlSGVhZGVyVG9PYmplY3QoYmFnZ2FnZUhlYWRlcikge1xuICByZXR1cm4gYmFnZ2FnZUhlYWRlclxuICAgIC5zcGxpdCgnLCcpXG4gICAgLm1hcChiYWdnYWdlRW50cnkgPT4gYmFnZ2FnZUVudHJ5LnNwbGl0KCc9JykubWFwKGtleU9yVmFsdWUgPT4gZGVjb2RlVVJJQ29tcG9uZW50KGtleU9yVmFsdWUudHJpbSgpKSkpXG4gICAgLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuXG4vKipcbiAqIFR1cm5zIGEgZmxhdCBvYmplY3QgKGtleS12YWx1ZSBwYWlycykgaW50byBhIGJhZ2dhZ2UgaGVhZGVyLCB3aGljaCBpcyBhbHNvIGp1c3Qga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB0dXJuIGludG8gYSBiYWdnYWdlIGhlYWRlci5cbiAqIEByZXR1cm5zIGEgYmFnZ2FnZSBoZWFkZXIgc3RyaW5nLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgb2JqZWN0IGRpZG4ndCBoYXZlIGFueSB2YWx1ZXMsIHNpbmNlIGFuIGVtcHR5IGJhZ2dhZ2UgaGVhZGVyXG4gKiBpcyBub3Qgc3BlYyBjb21wbGlhbnQuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvQmFnZ2FnZUhlYWRlcihvYmplY3QpIHtcbiAgaWYgKE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQW4gZW1wdHkgYmFnZ2FnZSBoZWFkZXIgaXMgbm90IHNwZWMgY29tcGxpYW50OiBXZSByZXR1cm4gdW5kZWZpbmVkLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0KS5yZWR1Y2UoKGJhZ2dhZ2VIZWFkZXIsIFtvYmplY3RLZXksIG9iamVjdFZhbHVlXSwgY3VycmVudEluZGV4KSA9PiB7XG4gICAgY29uc3QgYmFnZ2FnZUVudHJ5ID0gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdFZhbHVlKX1gO1xuICAgIGNvbnN0IG5ld0JhZ2dhZ2VIZWFkZXIgPSBjdXJyZW50SW5kZXggPT09IDAgPyBiYWdnYWdlRW50cnkgOiBgJHtiYWdnYWdlSGVhZGVyfSwke2JhZ2dhZ2VFbnRyeX1gO1xuICAgIGlmIChuZXdCYWdnYWdlSGVhZGVyLmxlbmd0aCA+IE1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEgpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBOb3QgYWRkaW5nIGtleTogJHtvYmplY3RLZXl9IHdpdGggdmFsOiAke29iamVjdFZhbHVlfSB0byBiYWdnYWdlIGhlYWRlciBkdWUgdG8gZXhjZWVkaW5nIGJhZ2dhZ2Ugc2l6ZSBsaW1pdHMuYCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBiYWdnYWdlSGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3QmFnZ2FnZUhlYWRlcjtcbiAgICB9XG4gIH0sICcnKTtcbn1cblxuZXhwb3J0IHsgTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCwgYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCwgZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlciwgb2JqZWN0VG9CYWdnYWdlSGVhZGVyLCBwYXJzZUJhZ2dhZ2VIZWFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhZ2dhZ2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/browser.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/browser.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComponentName: function() { return /* binding */ getComponentName; },\n/* harmony export */   getLocationHref: function() { return /* binding */ getLocationHref; },\n/* harmony export */   htmlTreeAsString: function() { return /* binding */ htmlTreeAsString; }\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\n\nconst WINDOW = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n\nconst DEFAULT_MAX_STRING_LENGTH = 80;\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction htmlTreeAsString(\n  elem,\n  options = {},\n) {\n  if (!elem) {\n    return '<unknown>';\n  }\n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem ;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    const out = [];\n    let height = 0;\n    let len = 0;\n    const separator = ' > ';\n    const sepLength = separator.length;\n    let nextStr;\n    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;\n    const maxStringLength = (!Array.isArray(options) && options.maxStringLength) || DEFAULT_MAX_STRING_LENGTH;\n\n    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds maxStringLength\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el, keyAttrs) {\n  const elem = el\n\n;\n\n  const out = [];\n\n  if (!elem?.tagName) {\n    return '';\n  }\n\n  // @ts-expect-error WINDOW has HTMLElement\n  if (WINDOW.HTMLElement) {\n    // If using the component name annotation plugin, this value may be available on the DOM node\n    if (elem instanceof HTMLElement && elem.dataset) {\n      if (elem.dataset['sentryComponent']) {\n        return elem.dataset['sentryComponent'];\n      }\n      if (elem.dataset['sentryElement']) {\n        return elem.dataset['sentryElement'];\n      }\n    }\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  const keyAttrPairs = keyAttrs?.length\n    ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n    : null;\n\n  if (keyAttrPairs?.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n    const className = elem.className;\n    if (className && (0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isString)(className)) {\n      const classes = className.split(/\\s+/);\n      for (const c of classes) {\n        out.push(`.${c}`);\n      }\n    }\n  }\n  const allowedAttrs = ['aria-label', 'type', 'name', 'title', 'alt'];\n  for (const k of allowedAttrs) {\n    const attr = elem.getAttribute(k);\n    if (attr) {\n      out.push(`[${k}=\"${attr}\"]`);\n    }\n  }\n\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nfunction getLocationHref() {\n  try {\n    return WINDOW.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n\n/**\n * Given a DOM element, traverses up the tree until it finds the first ancestor node\n * that has the `data-sentry-component` or `data-sentry-element` attribute with `data-sentry-component` taking\n * precedence. This attribute is added at build-time by projects that have the component name annotation plugin installed.\n *\n * @returns a string representation of the component for the provided DOM element, or `null` if not found\n */\nfunction getComponentName(elem) {\n  // @ts-expect-error WINDOW has HTMLElement\n  if (!WINDOW.HTMLElement) {\n    return null;\n  }\n\n  let currentElem = elem ;\n  const MAX_TRAVERSE_HEIGHT = 5;\n  for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {\n    if (!currentElem) {\n      return null;\n    }\n\n    if (currentElem instanceof HTMLElement) {\n      if (currentElem.dataset['sentryComponent']) {\n        return currentElem.dataset['sentryComponent'];\n      }\n      if (currentElem.dataset['sentryElement']) {\n        return currentElem.dataset['sentryElement'];\n      }\n    }\n\n    currentElem = currentElem.parentNode;\n  }\n\n  return null;\n}\n\n\n//# sourceMappingURL=browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ1M7O0FBRTVDLGVBQWUscURBQVU7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixlQUFlLElBQUksZUFBZTtBQUNyRCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQSxxQkFBcUIsZ0RBQVE7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsSUFBSSxLQUFLO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRStEO0FBQy9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9icm93c2VyLmpzP2FlMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL2lzLmpzJztcbmltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmNvbnN0IFdJTkRPVyA9IEdMT0JBTF9PQkogO1xuXG5jb25zdCBERUZBVUxUX01BWF9TVFJJTkdfTEVOR1RIID0gODA7XG5cbi8qKlxuICogR2l2ZW4gYSBjaGlsZCBET00gZWxlbWVudCwgcmV0dXJucyBhIHF1ZXJ5LXNlbGVjdG9yIHN0YXRlbWVudCBkZXNjcmliaW5nIHRoYXRcbiAqIGFuZCBpdHMgYW5jZXN0b3JzXG4gKiBlLmcuIFtIVE1MRWxlbWVudF0gPT4gYm9keSA+IGRpdiA+IGlucHV0I2Zvby5idG5bbmFtZT1iYXpdXG4gKiBAcmV0dXJucyBnZW5lcmF0ZWQgRE9NIHBhdGhcbiAqL1xuZnVuY3Rpb24gaHRtbFRyZWVBc1N0cmluZyhcbiAgZWxlbSxcbiAgb3B0aW9ucyA9IHt9LFxuKSB7XG4gIGlmICghZWxlbSkge1xuICAgIHJldHVybiAnPHVua25vd24+JztcbiAgfVxuXG4gIC8vIHRyeS9jYXRjaCBib3RoOlxuICAvLyAtIGFjY2Vzc2luZyBldmVudC50YXJnZXQgKHNlZSBnZXRzZW50cnkvcmF2ZW4tanMjODM4LCAjNzY4KVxuICAvLyAtIGBodG1sVHJlZUFzU3RyaW5nYCBiZWNhdXNlIGl0J3MgY29tcGxleCwgYW5kIGp1c3QgYWNjZXNzaW5nIHRoZSBET00gaW5jb3JyZWN0bHlcbiAgLy8gLSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy5cbiAgdHJ5IHtcbiAgICBsZXQgY3VycmVudEVsZW0gPSBlbGVtIDtcbiAgICBjb25zdCBNQVhfVFJBVkVSU0VfSEVJR0hUID0gNTtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVuID0gMDtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSAnID4gJztcbiAgICBjb25zdCBzZXBMZW5ndGggPSBzZXBhcmF0b3IubGVuZ3RoO1xuICAgIGxldCBuZXh0U3RyO1xuICAgIGNvbnN0IGtleUF0dHJzID0gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMgOiBvcHRpb25zLmtleUF0dHJzO1xuICAgIGNvbnN0IG1heFN0cmluZ0xlbmd0aCA9ICghQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLm1heFN0cmluZ0xlbmd0aCkgfHwgREVGQVVMVF9NQVhfU1RSSU5HX0xFTkdUSDtcblxuICAgIHdoaWxlIChjdXJyZW50RWxlbSAmJiBoZWlnaHQrKyA8IE1BWF9UUkFWRVJTRV9IRUlHSFQpIHtcbiAgICAgIG5leHRTdHIgPSBfaHRtbEVsZW1lbnRBc1N0cmluZyhjdXJyZW50RWxlbSwga2V5QXR0cnMpO1xuICAgICAgLy8gYmFpbCBvdXQgaWZcbiAgICAgIC8vIC0gbmV4dFN0ciBpcyB0aGUgJ2h0bWwnIGVsZW1lbnRcbiAgICAgIC8vIC0gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRoYXQgd291bGQgYmUgY3JlYXRlZCBleGNlZWRzIG1heFN0cmluZ0xlbmd0aFxuICAgICAgLy8gICAoaWdub3JlIHRoaXMgbGltaXQgaWYgd2UgYXJlIG9uIHRoZSBmaXJzdCBpdGVyYXRpb24pXG4gICAgICBpZiAobmV4dFN0ciA9PT0gJ2h0bWwnIHx8IChoZWlnaHQgPiAxICYmIGxlbiArIG91dC5sZW5ndGggKiBzZXBMZW5ndGggKyBuZXh0U3RyLmxlbmd0aCA+PSBtYXhTdHJpbmdMZW5ndGgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvdXQucHVzaChuZXh0U3RyKTtcblxuICAgICAgbGVuICs9IG5leHRTdHIubGVuZ3RoO1xuICAgICAgY3VycmVudEVsZW0gPSBjdXJyZW50RWxlbS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQucmV2ZXJzZSgpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfSBjYXRjaCAoX29PKSB7XG4gICAgcmV0dXJuICc8dW5rbm93bj4nO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHNpbXBsZSwgcXVlcnktc2VsZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgYSBET00gZWxlbWVudFxuICogZS5nLiBbSFRNTEVsZW1lbnRdID0+IGlucHV0I2Zvby5idG5bbmFtZT1iYXpdXG4gKiBAcmV0dXJucyBnZW5lcmF0ZWQgRE9NIHBhdGhcbiAqL1xuZnVuY3Rpb24gX2h0bWxFbGVtZW50QXNTdHJpbmcoZWwsIGtleUF0dHJzKSB7XG4gIGNvbnN0IGVsZW0gPSBlbFxuXG47XG5cbiAgY29uc3Qgb3V0ID0gW107XG5cbiAgaWYgKCFlbGVtPy50YWdOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBXSU5ET1cgaGFzIEhUTUxFbGVtZW50XG4gIGlmIChXSU5ET1cuSFRNTEVsZW1lbnQpIHtcbiAgICAvLyBJZiB1c2luZyB0aGUgY29tcG9uZW50IG5hbWUgYW5ub3RhdGlvbiBwbHVnaW4sIHRoaXMgdmFsdWUgbWF5IGJlIGF2YWlsYWJsZSBvbiB0aGUgRE9NIG5vZGVcbiAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsZW0uZGF0YXNldCkge1xuICAgICAgaWYgKGVsZW0uZGF0YXNldFsnc2VudHJ5Q29tcG9uZW50J10pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZGF0YXNldFsnc2VudHJ5Q29tcG9uZW50J107XG4gICAgICB9XG4gICAgICBpZiAoZWxlbS5kYXRhc2V0WydzZW50cnlFbGVtZW50J10pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZGF0YXNldFsnc2VudHJ5RWxlbWVudCddO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG91dC5wdXNoKGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAvLyBQYWlycyBvZiBhdHRyaWJ1dGUga2V5cyBkZWZpbmVkIGluIGBzZXJpYWxpemVBdHRyaWJ1dGVgIGFuZCB0aGVpciB2YWx1ZXMgb24gZWxlbWVudC5cbiAgY29uc3Qga2V5QXR0clBhaXJzID0ga2V5QXR0cnM/Lmxlbmd0aFxuICAgID8ga2V5QXR0cnMuZmlsdGVyKGtleUF0dHIgPT4gZWxlbS5nZXRBdHRyaWJ1dGUoa2V5QXR0cikpLm1hcChrZXlBdHRyID0+IFtrZXlBdHRyLCBlbGVtLmdldEF0dHJpYnV0ZShrZXlBdHRyKV0pXG4gICAgOiBudWxsO1xuXG4gIGlmIChrZXlBdHRyUGFpcnM/Lmxlbmd0aCkge1xuICAgIGtleUF0dHJQYWlycy5mb3JFYWNoKGtleUF0dHJQYWlyID0+IHtcbiAgICAgIG91dC5wdXNoKGBbJHtrZXlBdHRyUGFpclswXX09XCIke2tleUF0dHJQYWlyWzFdfVwiXWApO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbGVtLmlkKSB7XG4gICAgICBvdXQucHVzaChgIyR7ZWxlbS5pZH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZTtcbiAgICBpZiAoY2xhc3NOYW1lICYmIGlzU3RyaW5nKGNsYXNzTmFtZSkpIHtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBjbGFzc2VzKSB7XG4gICAgICAgIG91dC5wdXNoKGAuJHtjfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhbGxvd2VkQXR0cnMgPSBbJ2FyaWEtbGFiZWwnLCAndHlwZScsICduYW1lJywgJ3RpdGxlJywgJ2FsdCddO1xuICBmb3IgKGNvbnN0IGsgb2YgYWxsb3dlZEF0dHJzKSB7XG4gICAgY29uc3QgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKGspO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBvdXQucHVzaChgWyR7a309XCIke2F0dHJ9XCJdYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBBIHNhZmUgZm9ybSBvZiBsb2NhdGlvbi5ocmVmXG4gKi9cbmZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gV0lORE9XLmRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gIH0gY2F0Y2ggKG9PKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gZWxlbWVudCwgdHJhdmVyc2VzIHVwIHRoZSB0cmVlIHVudGlsIGl0IGZpbmRzIHRoZSBmaXJzdCBhbmNlc3RvciBub2RlXG4gKiB0aGF0IGhhcyB0aGUgYGRhdGEtc2VudHJ5LWNvbXBvbmVudGAgb3IgYGRhdGEtc2VudHJ5LWVsZW1lbnRgIGF0dHJpYnV0ZSB3aXRoIGBkYXRhLXNlbnRyeS1jb21wb25lbnRgIHRha2luZ1xuICogcHJlY2VkZW5jZS4gVGhpcyBhdHRyaWJ1dGUgaXMgYWRkZWQgYXQgYnVpbGQtdGltZSBieSBwcm9qZWN0cyB0aGF0IGhhdmUgdGhlIGNvbXBvbmVudCBuYW1lIGFubm90YXRpb24gcGx1Z2luIGluc3RhbGxlZC5cbiAqXG4gKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50IGZvciB0aGUgcHJvdmlkZWQgRE9NIGVsZW1lbnQsIG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShlbGVtKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgV0lORE9XIGhhcyBIVE1MRWxlbWVudFxuICBpZiAoIVdJTkRPVy5IVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRFbGVtID0gZWxlbSA7XG4gIGNvbnN0IE1BWF9UUkFWRVJTRV9IRUlHSFQgPSA1O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9UUkFWRVJTRV9IRUlHSFQ7IGkrKykge1xuICAgIGlmICghY3VycmVudEVsZW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50RWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBpZiAoY3VycmVudEVsZW0uZGF0YXNldFsnc2VudHJ5Q29tcG9uZW50J10pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRFbGVtLmRhdGFzZXRbJ3NlbnRyeUVsZW1lbnQnXSkge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW0uZGF0YXNldFsnc2VudHJ5RWxlbWVudCddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRFbGVtID0gY3VycmVudEVsZW0ucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnROYW1lLCBnZXRMb2NhdGlvbkhyZWYsIGh0bWxUcmVlQXNTdHJpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEBUG_BUILD: function() { return /* binding */ DEBUG_BUILD; }\n/* harmony export */ });\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n\n//# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9kZWJ1Zy1idWlsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvZGVidWctYnVpbGQuanM/ODJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnQgeyBERUJVR19CVUlMRCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctYnVpbGQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDebugImagesForResources: function() { return /* binding */ getDebugImagesForResources; },\n/* harmony export */   getFilenameToDebugIdMap: function() { return /* binding */ getFilenameToDebugIdMap; }\n/* harmony export */ });\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\nlet parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameDebugIds;\n\n/**\n * Returns a map of filenames to debug identifiers.\n */\nfunction getFilenameToDebugIdMap(stackParser) {\n  const debugIdMap = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return {};\n  }\n\n  const debugIdKeys = Object.keys(debugIdMap);\n\n  // If the count of registered globals hasn't changed since the last call, we\n  // can just return the cached result.\n  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {\n    return cachedFilenameDebugIds;\n  }\n\n  lastKeysCount = debugIdKeys.length;\n\n  // Build a map of filename -> debug_id.\n  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {\n    if (!parsedStackResults) {\n      parsedStackResults = {};\n    }\n\n    const result = parsedStackResults[stackKey];\n\n    if (result) {\n      acc[result[0]] = result[1];\n    } else {\n      const parsedStack = stackParser(stackKey);\n\n      for (let i = parsedStack.length - 1; i >= 0; i--) {\n        const stackFrame = parsedStack[i];\n        const filename = stackFrame?.filename;\n        const debugId = debugIdMap[stackKey];\n\n        if (filename && debugId) {\n          acc[filename] = debugId;\n          parsedStackResults[stackKey] = [filename, debugId];\n          break;\n        }\n      }\n    }\n\n    return acc;\n  }, {});\n\n  return cachedFilenameDebugIds;\n}\n\n/**\n * Returns a list of debug images for the given resources.\n */\nfunction getDebugImagesForResources(\n  stackParser,\n  resource_paths,\n) {\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  if (!filenameDebugIdMap) {\n    return [];\n  }\n\n  const images = [];\n  for (const path of resource_paths) {\n    if (path && filenameDebugIdMap[path]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: path,\n        debug_id: filenameDebugIdMap[path] ,\n      });\n    }\n  }\n\n  return images;\n}\n\n\n//# sourceMappingURL=debug-ids.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9kZWJ1Zy1pZHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscURBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFK0Q7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2RlYnVnLWlkcy5qcz82Nzk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmxldCBwYXJzZWRTdGFja1Jlc3VsdHM7XG5sZXQgbGFzdEtleXNDb3VudDtcbmxldCBjYWNoZWRGaWxlbmFtZURlYnVnSWRzO1xuXG4vKipcbiAqIFJldHVybnMgYSBtYXAgb2YgZmlsZW5hbWVzIHRvIGRlYnVnIGlkZW50aWZpZXJzLlxuICovXG5mdW5jdGlvbiBnZXRGaWxlbmFtZVRvRGVidWdJZE1hcChzdGFja1BhcnNlcikge1xuICBjb25zdCBkZWJ1Z0lkTWFwID0gR0xPQkFMX09CSi5fc2VudHJ5RGVidWdJZHM7XG4gIGlmICghZGVidWdJZE1hcCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGRlYnVnSWRLZXlzID0gT2JqZWN0LmtleXMoZGVidWdJZE1hcCk7XG5cbiAgLy8gSWYgdGhlIGNvdW50IG9mIHJlZ2lzdGVyZWQgZ2xvYmFscyBoYXNuJ3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjYWxsLCB3ZVxuICAvLyBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlZCByZXN1bHQuXG4gIGlmIChjYWNoZWRGaWxlbmFtZURlYnVnSWRzICYmIGRlYnVnSWRLZXlzLmxlbmd0aCA9PT0gbGFzdEtleXNDb3VudCkge1xuICAgIHJldHVybiBjYWNoZWRGaWxlbmFtZURlYnVnSWRzO1xuICB9XG5cbiAgbGFzdEtleXNDb3VudCA9IGRlYnVnSWRLZXlzLmxlbmd0aDtcblxuICAvLyBCdWlsZCBhIG1hcCBvZiBmaWxlbmFtZSAtPiBkZWJ1Z19pZC5cbiAgY2FjaGVkRmlsZW5hbWVEZWJ1Z0lkcyA9IGRlYnVnSWRLZXlzLnJlZHVjZSgoYWNjLCBzdGFja0tleSkgPT4ge1xuICAgIGlmICghcGFyc2VkU3RhY2tSZXN1bHRzKSB7XG4gICAgICBwYXJzZWRTdGFja1Jlc3VsdHMgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYWNjW3Jlc3VsdFswXV0gPSByZXN1bHRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnNlZFN0YWNrID0gc3RhY2tQYXJzZXIoc3RhY2tLZXkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gcGFyc2VkU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHBhcnNlZFN0YWNrW2ldO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHN0YWNrRnJhbWU/LmZpbGVuYW1lO1xuICAgICAgICBjb25zdCBkZWJ1Z0lkID0gZGVidWdJZE1hcFtzdGFja0tleV07XG5cbiAgICAgICAgaWYgKGZpbGVuYW1lICYmIGRlYnVnSWQpIHtcbiAgICAgICAgICBhY2NbZmlsZW5hbWVdID0gZGVidWdJZDtcbiAgICAgICAgICBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldID0gW2ZpbGVuYW1lLCBkZWJ1Z0lkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gY2FjaGVkRmlsZW5hbWVEZWJ1Z0lkcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBkZWJ1ZyBpbWFnZXMgZm9yIHRoZSBnaXZlbiByZXNvdXJjZXMuXG4gKi9cbmZ1bmN0aW9uIGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzKFxuICBzdGFja1BhcnNlcixcbiAgcmVzb3VyY2VfcGF0aHMsXG4pIHtcbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0gZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAoc3RhY2tQYXJzZXIpO1xuXG4gIGlmICghZmlsZW5hbWVEZWJ1Z0lkTWFwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgaW1hZ2VzID0gW107XG4gIGZvciAoY29uc3QgcGF0aCBvZiByZXNvdXJjZV9wYXRocykge1xuICAgIGlmIChwYXRoICYmIGZpbGVuYW1lRGVidWdJZE1hcFtwYXRoXSkge1xuICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAnc291cmNlbWFwJyxcbiAgICAgICAgY29kZV9maWxlOiBwYXRoLFxuICAgICAgICBkZWJ1Z19pZDogZmlsZW5hbWVEZWJ1Z0lkTWFwW3BhdGhdICxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbWFnZXM7XG59XG5cbmV4cG9ydCB7IGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzLCBnZXRGaWxlbmFtZVRvRGVidWdJZE1hcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctaWRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js":
/*!****************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/is.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDOMError: function() { return /* binding */ isDOMError; },\n/* harmony export */   isDOMException: function() { return /* binding */ isDOMException; },\n/* harmony export */   isElement: function() { return /* binding */ isElement; },\n/* harmony export */   isError: function() { return /* binding */ isError; },\n/* harmony export */   isErrorEvent: function() { return /* binding */ isErrorEvent; },\n/* harmony export */   isEvent: function() { return /* binding */ isEvent; },\n/* harmony export */   isInstanceOf: function() { return /* binding */ isInstanceOf; },\n/* harmony export */   isParameterizedString: function() { return /* binding */ isParameterizedString; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isPrimitive: function() { return /* binding */ isPrimitive; },\n/* harmony export */   isRegExp: function() { return /* binding */ isRegExp; },\n/* harmony export */   isRequest: function() { return /* binding */ isRequest; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isSyntheticEvent: function() { return /* binding */ isSyntheticEvent; },\n/* harmony export */   isThenable: function() { return /* binding */ isThenable; },\n/* harmony export */   isVueViewModel: function() { return /* binding */ isVueViewModel; }\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isParameterizedString(wat) {\n  return (\n    typeof wat === 'object' &&\n    wat !== null &&\n    '__sentry_template_string__' in wat &&\n    '__sentry_template_values__' in wat\n  );\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat?.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch (_e) {\n    return false;\n  }\n}\n\n/**\n * Checks whether given value's type is a Vue ViewModel.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isVueViewModel(wat) {\n  // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n  return !!(typeof wat === 'object' && wat !== null && ((wat ).__isVue || (wat )._isVue));\n}\n\n/**\n * Checks whether the given parameter is a Standard Web API Request instance.\n *\n * Returns false if Request is not available in the current runtime.\n */\nfunction isRequest(request) {\n  return typeof Request !== 'undefined' && isInstanceOf(request, Request);\n}\n\n\n//# sourceMappingURL=is.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9pcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrTjtBQUMvTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvaXMuanM/ZTY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIG9uZSBvZiBhIGZldyBFcnJvciBvciBFcnJvci1saWtlXG4gKiB7QGxpbmsgaXNFcnJvcn0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3Iod2F0KSB7XG4gIHN3aXRjaCAob2JqZWN0VG9TdHJpbmcuY2FsbCh3YXQpKSB7XG4gICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRXhjZXB0aW9uXSc6XG4gICAgY2FzZSAnW29iamVjdCBET01FeGNlcHRpb25dJzpcbiAgICBjYXNlICdbb2JqZWN0IFdlYkFzc2VtYmx5LkV4Y2VwdGlvbl0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpc0luc3RhbmNlT2Yod2F0LCBFcnJvcik7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGJ1aWx0LWluIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB3YXQgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNCdWlsdGluKHdhdCwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHdhdCkgPT09IGBbb2JqZWN0ICR7Y2xhc3NOYW1lfV1gO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBFcnJvckV2ZW50XG4gKiB7QGxpbmsgaXNFcnJvckV2ZW50fS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvckV2ZW50KHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ0Vycm9yRXZlbnQnKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgRE9NRXJyb3JcbiAqIHtAbGluayBpc0RPTUVycm9yfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNET01FcnJvcih3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdET01FcnJvcicpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBET01FeGNlcHRpb25cbiAqIHtAbGluayBpc0RPTUV4Y2VwdGlvbn0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uKHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ0RPTUV4Y2VwdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIHN0cmluZ1xuICoge0BsaW5rIGlzU3RyaW5nfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcod2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnU3RyaW5nJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gc3RyaW5nIGlzIHBhcmFtZXRlcml6ZWRcbiAqIHtAbGluayBpc1BhcmFtZXRlcml6ZWRTdHJpbmd9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1BhcmFtZXRlcml6ZWRTdHJpbmcod2F0KSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdhdCA9PT0gJ29iamVjdCcgJiZcbiAgICB3YXQgIT09IG51bGwgJiZcbiAgICAnX19zZW50cnlfdGVtcGxhdGVfc3RyaW5nX18nIGluIHdhdCAmJlxuICAgICdfX3NlbnRyeV90ZW1wbGF0ZV92YWx1ZXNfXycgaW4gd2F0XG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgYSBwcmltaXRpdmUgKHVuZGVmaW5lZCwgbnVsbCwgbnVtYmVyLCBib29sZWFuLCBzdHJpbmcsIGJpZ2ludCwgc3ltYm9sKVxuICoge0BsaW5rIGlzUHJpbWl0aXZlfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUod2F0KSB7XG4gIHJldHVybiB3YXQgPT09IG51bGwgfHwgaXNQYXJhbWV0ZXJpemVkU3RyaW5nKHdhdCkgfHwgKHR5cGVvZiB3YXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiB3YXQgIT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiBvYmplY3QgbGl0ZXJhbCwgb3IgYSBjbGFzcyBpbnN0YW5jZS5cbiAqIHtAbGluayBpc1BsYWluT2JqZWN0fS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdPYmplY3QnKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gRXZlbnQgaW5zdGFuY2VcbiAqIHtAbGluayBpc0V2ZW50fS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFdmVudCh3YXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHdhdCwgRXZlbnQpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiBFbGVtZW50IGluc3RhbmNlXG4gKiB7QGxpbmsgaXNFbGVtZW50fS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHdhdCkge1xuICByZXR1cm4gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGlzSW5zdGFuY2VPZih3YXQsIEVsZW1lbnQpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiByZWdleHBcbiAqIHtAbGluayBpc1JlZ0V4cH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ1JlZ0V4cCcpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGhhcyBhIHRoZW4gZnVuY3Rpb24uXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNUaGVuYWJsZSh3YXQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICByZXR1cm4gQm9vbGVhbih3YXQ/LnRoZW4gJiYgdHlwZW9mIHdhdC50aGVuID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYSBTeW50aGV0aWNFdmVudFxuICoge0BsaW5rIGlzU3ludGhldGljRXZlbnR9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KHdhdCkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh3YXQpICYmICduYXRpdmVFdmVudCcgaW4gd2F0ICYmICdwcmV2ZW50RGVmYXVsdCcgaW4gd2F0ICYmICdzdG9wUHJvcGFnYXRpb24nIGluIHdhdDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gaW5zdGFuY2Ugb2YgcHJvdmlkZWQgY29uc3RydWN0b3IuXG4gKiB7QGxpbmsgaXNJbnN0YW5jZU9mfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSBiYXNlIEEgY29uc3RydWN0b3IgdG8gYmUgdXNlZCBpbiBhIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0luc3RhbmNlT2Yod2F0LCBiYXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdhdCBpbnN0YW5jZW9mIGJhc2U7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgVnVlIFZpZXdNb2RlbC5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNWdWVWaWV3TW9kZWwod2F0KSB7XG4gIC8vIE5vdCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGJlY2F1c2UgaW4gVnVlIDMgaXQgd291bGQgcmVhZCB0aGUgaW5zdGFuY2UncyBTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKSBwcm9wZXJ0eS5cbiAgcmV0dXJuICEhKHR5cGVvZiB3YXQgPT09ICdvYmplY3QnICYmIHdhdCAhPT0gbnVsbCAmJiAoKHdhdCApLl9faXNWdWUgfHwgKHdhdCApLl9pc1Z1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdGFuZGFyZCBXZWIgQVBJIFJlcXVlc3QgaW5zdGFuY2UuXG4gKlxuICogUmV0dXJucyBmYWxzZSBpZiBSZXF1ZXN0IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgcnVudGltZS5cbiAqL1xuZnVuY3Rpb24gaXNSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2YocmVxdWVzdCwgUmVxdWVzdCk7XG59XG5cbmV4cG9ydCB7IGlzRE9NRXJyb3IsIGlzRE9NRXhjZXB0aW9uLCBpc0VsZW1lbnQsIGlzRXJyb3IsIGlzRXJyb3JFdmVudCwgaXNFdmVudCwgaXNJbnN0YW5jZU9mLCBpc1BhcmFtZXRlcml6ZWRTdHJpbmcsIGlzUGxhaW5PYmplY3QsIGlzUHJpbWl0aXZlLCBpc1JlZ0V4cCwgaXNSZXF1ZXN0LCBpc1N0cmluZywgaXNTeW50aGV0aWNFdmVudCwgaXNUaGVuYWJsZSwgaXNWdWVWaWV3TW9kZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/logger.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSOLE_LEVELS: function() { return /* binding */ CONSOLE_LEVELS; },\n/* harmony export */   consoleSandbox: function() { return /* binding */ consoleSandbox; },\n/* harmony export */   logger: function() { return /* binding */ logger; },\n/* harmony export */   originalConsoleMethods: function() { return /* binding */ originalConsoleMethods; }\n/* harmony export */ });\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\n\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nconst CONSOLE_LEVELS = [\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'log',\n  'assert',\n  'trace',\n] ;\n\n/** This may be mutated by the console instrumentation. */\nconst originalConsoleMethods\n\n = {};\n\n/** A Sentry Logger instance. */\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  if (!(\"console\" in _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ)) {\n    return callback();\n  }\n\n  const console = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.console ;\n  const wrappedFuncs = {};\n\n  const wrappedLevels = Object.keys(originalConsoleMethods) ;\n\n  // Restore all wrapped console methods\n  wrappedLevels.forEach(level => {\n    const originalConsoleMethod = originalConsoleMethods[level] ;\n    wrappedFuncs[level] = console[level] ;\n    console[level] = originalConsoleMethod;\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    wrappedLevels.forEach(level => {\n      console[level] = wrappedFuncs[level] ;\n    });\n  }\n}\n\nfunction makeLogger() {\n  let enabled = false;\n  const logger = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n    isEnabled: () => enabled,\n  };\n\n  if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = (...args) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger ;\n}\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n * The logger is a singleton on the carrier, to ensure that a consistent logger is used throughout the SDK.\n */\nconst logger = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_2__.getGlobalSingleton)('logger', makeLogger);\n\n\n//# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9sb2dnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRDtBQUNKO0FBQ0g7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUF1QjtBQUMvQjtBQUNBOztBQUVBLGtCQUFrQixxREFBVTtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLE1BQU0sd0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFVLGtCQUFrQixPQUFPLEdBQUcsS0FBSztBQUN2RCxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBa0I7O0FBRXlDO0FBQzFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9sb2dnZXIuanM/OTk2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRHbG9iYWxTaW5nbGV0b24gfSBmcm9tICcuLi9jYXJyaWVyLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG4vKiogUHJlZml4IGZvciBsb2dnaW5nIHN0cmluZ3MgKi9cbmNvbnN0IFBSRUZJWCA9ICdTZW50cnkgTG9nZ2VyICc7XG5cbmNvbnN0IENPTlNPTEVfTEVWRUxTID0gW1xuICAnZGVidWcnLFxuICAnaW5mbycsXG4gICd3YXJuJyxcbiAgJ2Vycm9yJyxcbiAgJ2xvZycsXG4gICdhc3NlcnQnLFxuICAndHJhY2UnLFxuXSA7XG5cbi8qKiBUaGlzIG1heSBiZSBtdXRhdGVkIGJ5IHRoZSBjb25zb2xlIGluc3RydW1lbnRhdGlvbi4gKi9cbmNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNcblxuID0ge307XG5cbi8qKiBBIFNlbnRyeSBMb2dnZXIgaW5zdGFuY2UuICovXG5cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZSBzZW50cnkgY29uc29sZSBpbnN0cnVtZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gcnVuIGFnYWluc3QgdGhlIG9yaWdpbmFsIGBjb25zb2xlYCBtZXNzYWdlc1xuICogQHJldHVybnMgVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGNvbnNvbGVTYW5kYm94KGNhbGxiYWNrKSB7XG4gIGlmICghKCdjb25zb2xlJyBpbiBHTE9CQUxfT0JKKSkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgY29uc29sZSA9IEdMT0JBTF9PQkouY29uc29sZSA7XG4gIGNvbnN0IHdyYXBwZWRGdW5jcyA9IHt9O1xuXG4gIGNvbnN0IHdyYXBwZWRMZXZlbHMgPSBPYmplY3Qua2V5cyhvcmlnaW5hbENvbnNvbGVNZXRob2RzKSA7XG5cbiAgLy8gUmVzdG9yZSBhbGwgd3JhcHBlZCBjb25zb2xlIG1ldGhvZHNcbiAgd3JhcHBlZExldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVNZXRob2QgPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXSA7XG4gICAgd3JhcHBlZEZ1bmNzW2xldmVsXSA9IGNvbnNvbGVbbGV2ZWxdIDtcbiAgICBjb25zb2xlW2xldmVsXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZDtcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBSZXZlcnQgcmVzdG9yYXRpb24gdG8gd3JhcHBlZCBzdGF0ZVxuICAgIHdyYXBwZWRMZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zb2xlW2xldmVsXSA9IHdyYXBwZWRGdW5jc1tsZXZlbF0gO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2dnZXIoKSB7XG4gIGxldCBlbmFibGVkID0gZmFsc2U7XG4gIGNvbnN0IGxvZ2dlciA9IHtcbiAgICBlbmFibGU6ICgpID0+IHtcbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgZGlzYWJsZTogKCkgPT4ge1xuICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgaXNFbmFibGVkOiAoKSA9PiBlbmFibGVkLFxuICB9O1xuXG4gIGlmIChERUJVR19CVUlMRCkge1xuICAgIENPTlNPTEVfTEVWRUxTLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBsb2dnZXJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgIGNvbnNvbGVTYW5kYm94KCgpID0+IHtcbiAgICAgICAgICAgIEdMT0JBTF9PQkouY29uc29sZVtuYW1lXShgJHtQUkVGSVh9WyR7bmFtZX1dOmAsIC4uLmFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIENPTlNPTEVfTEVWRUxTLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBsb2dnZXJbbmFtZV0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9nZ2VyIDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgbG9nZ2VyIHNpbmdsZXRvbiB3aGljaCBlaXRoZXIgbG9ncyB0aGluZ3Mgb3Igbm8tb3BzIGlmIGxvZ2dpbmcgaXMgbm90IGVuYWJsZWQuXG4gKiBUaGUgbG9nZ2VyIGlzIGEgc2luZ2xldG9uIG9uIHRoZSBjYXJyaWVyLCB0byBlbnN1cmUgdGhhdCBhIGNvbnNpc3RlbnQgbG9nZ2VyIGlzIHVzZWQgdGhyb3VnaG91dCB0aGUgU0RLLlxuICovXG5jb25zdCBsb2dnZXIgPSBnZXRHbG9iYWxTaW5nbGV0b24oJ2xvZ2dlcicsIG1ha2VMb2dnZXIpO1xuXG5leHBvcnQgeyBDT05TT0xFX0xFVkVMUywgY29uc29sZVNhbmRib3gsIGxvZ2dlciwgb3JpZ2luYWxDb25zb2xlTWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js":
/*!******************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/misc.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextToFrame: function() { return /* binding */ addContextToFrame; },\n/* harmony export */   addExceptionMechanism: function() { return /* binding */ addExceptionMechanism; },\n/* harmony export */   addExceptionTypeValue: function() { return /* binding */ addExceptionTypeValue; },\n/* harmony export */   checkOrSetAlreadyCaught: function() { return /* binding */ checkOrSetAlreadyCaught; },\n/* harmony export */   getEventDescription: function() { return /* binding */ getEventDescription; },\n/* harmony export */   parseSemver: function() { return /* binding */ parseSemver; },\n/* harmony export */   uuid4: function() { return /* binding */ uuid4; }\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\n\n\nfunction getCrypto() {\n  const gbl = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n  return gbl.crypto || gbl.msCrypto;\n}\n\n/**\n * UUID4 generator\n * @param crypto Object that provides the crypto API.\n * @returns string Generated UUID4.\n */\nfunction uuid4(crypto = getCrypto()) {\n  let getRandomByte = () => Math.random() * 16;\n  try {\n    if (crypto?.randomUUID) {\n      return crypto.randomUUID().replace(/-/g, '');\n    }\n    if (crypto?.getRandomValues) {\n      getRandomByte = () => {\n        // crypto.getRandomValues might return undefined instead of the typed array\n        // in old Chromium versions (e.g. 23.0.1235.0 (151422))\n        // However, `typedArray` is still filled in-place.\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#typedarray\n        const typedArray = new Uint8Array(1);\n        crypto.getRandomValues(typedArray);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return typedArray[0];\n      };\n    }\n  } catch (_) {\n    // some runtimes can crash invoking crypto\n    // https://github.com/getsentry/sentry-javascript/issues/8935\n  }\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n    // eslint-disable-next-line no-bitwise\n    ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception?.values?.[0];\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\nfunction _parseInt(input) {\n  return parseInt(input || '', 10);\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = _parseInt(match[1]);\n  const minor = _parseInt(match[2]);\n  const patch = _parseInt(match[3]);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping\n  if (frame.lineno === undefined) {\n    return;\n  }\n\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(line, 0));\n\n  // We guard here to ensure this is not larger than the existing number of lines\n  const lineIndex = Math.min(maxLines - 1, sourceLine);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  frame.context_line = (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(lines[lineIndex], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n  if (isAlreadyCaptured(exception)) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    (0,_object_js__WEBPACK_IMPORTED_MODULE_2__.addNonEnumerableProperty)(exception , '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\nfunction isAlreadyCaptured(exception) {\n  try {\n    return (exception ).__sentry_captured__;\n  } catch {} // eslint-disable-line no-empty\n}\n\n\n//# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9taXNjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDaEI7QUFDSzs7QUFFNUM7QUFDQSxjQUFjLHFEQUFVO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQixJQUFJLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvREFBUTs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvREFBUTs7QUFFL0I7QUFDQTtBQUNBLG1CQUFtQixvREFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBd0I7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVM7QUFDYjs7QUFFNkk7QUFDN0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L21pc2MuanM/Y2RlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkgfSBmcm9tICcuL29iamVjdC5qcyc7XG5pbXBvcnQgeyBzbmlwTGluZSB9IGZyb20gJy4vc3RyaW5nLmpzJztcbmltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmZ1bmN0aW9uIGdldENyeXB0bygpIHtcbiAgY29uc3QgZ2JsID0gR0xPQkFMX09CSiA7XG4gIHJldHVybiBnYmwuY3J5cHRvIHx8IGdibC5tc0NyeXB0bztcbn1cblxuLyoqXG4gKiBVVUlENCBnZW5lcmF0b3JcbiAqIEBwYXJhbSBjcnlwdG8gT2JqZWN0IHRoYXQgcHJvdmlkZXMgdGhlIGNyeXB0byBBUEkuXG4gKiBAcmV0dXJucyBzdHJpbmcgR2VuZXJhdGVkIFVVSUQ0LlxuICovXG5mdW5jdGlvbiB1dWlkNChjcnlwdG8gPSBnZXRDcnlwdG8oKSkge1xuICBsZXQgZ2V0UmFuZG9tQnl0ZSA9ICgpID0+IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgdHJ5IHtcbiAgICBpZiAoY3J5cHRvPy5yYW5kb21VVUlEKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2csICcnKTtcbiAgICB9XG4gICAgaWYgKGNyeXB0bz8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICBnZXRSYW5kb21CeXRlID0gKCkgPT4ge1xuICAgICAgICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG1pZ2h0IHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiB0aGUgdHlwZWQgYXJyYXlcbiAgICAgICAgLy8gaW4gb2xkIENocm9taXVtIHZlcnNpb25zIChlLmcuIDIzLjAuMTIzNS4wICgxNTE0MjIpKVxuICAgICAgICAvLyBIb3dldmVyLCBgdHlwZWRBcnJheWAgaXMgc3RpbGwgZmlsbGVkIGluLXBsYWNlLlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzI3R5cGVkYXJyYXlcbiAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHR5cGVkQXJyYXkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXR1cm4gdHlwZWRBcnJheVswXTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gc29tZSBydW50aW1lcyBjYW4gY3Jhc2ggaW52b2tpbmcgY3J5cHRvXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvODkzNVxuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxMTc1MjMjMjExNzUyM1xuICAvLyBDb25jYXRlbmF0aW5nIHRoZSBmb2xsb3dpbmcgbnVtYmVycyBhcyBzdHJpbmdzIHJlc3VsdHMgaW4gJzEwMDAwMDAwMTAwMDQwMDA4MDAwMTAwMDAwMDAwMDAwJ1xuICByZXR1cm4gKChbMWU3XSApICsgMWUzICsgNGUzICsgOGUzICsgMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYyA9PlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgKChjICkgXiAoKGdldFJhbmRvbUJ5dGUoKSAmIDE1KSA+PiAoKGMgKSAvIDQpKSkudG9TdHJpbmcoMTYpLFxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEV4Y2VwdGlvbihldmVudCkge1xuICByZXR1cm4gZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM/LlswXTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBlaXRoZXIgbWVzc2FnZSBvciB0eXBlK3ZhbHVlIGZyb20gYW4gZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdXNlci1mYWNpbmcgbG9nc1xuICogQHJldHVybnMgZXZlbnQncyBkZXNjcmlwdGlvblxuICovXG5mdW5jdGlvbiBnZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSB7XG4gIGNvbnN0IHsgbWVzc2FnZSwgZXZlbnRfaWQ6IGV2ZW50SWQgfSA9IGV2ZW50O1xuICBpZiAobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RFeGNlcHRpb24gPSBnZXRGaXJzdEV4Y2VwdGlvbihldmVudCk7XG4gIGlmIChmaXJzdEV4Y2VwdGlvbikge1xuICAgIGlmIChmaXJzdEV4Y2VwdGlvbi50eXBlICYmIGZpcnN0RXhjZXB0aW9uLnZhbHVlKSB7XG4gICAgICByZXR1cm4gYCR7Zmlyc3RFeGNlcHRpb24udHlwZX06ICR7Zmlyc3RFeGNlcHRpb24udmFsdWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0RXhjZXB0aW9uLnR5cGUgfHwgZmlyc3RFeGNlcHRpb24udmFsdWUgfHwgZXZlbnRJZCB8fCAnPHVua25vd24+JztcbiAgfVxuICByZXR1cm4gZXZlbnRJZCB8fCAnPHVua25vd24+Jztcbn1cblxuLyoqXG4gKiBBZGRzIGV4Y2VwdGlvbiB2YWx1ZXMsIHR5cGUgYW5kIHZhbHVlIHRvIGFuIHN5bnRoZXRpYyBFeGNlcHRpb24uXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiB0aGUgZXhjZXB0aW9uLlxuICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgZXhjZXB0aW9uLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRFeGNlcHRpb25UeXBlVmFsdWUoZXZlbnQsIHZhbHVlLCB0eXBlKSB7XG4gIGNvbnN0IGV4Y2VwdGlvbiA9IChldmVudC5leGNlcHRpb24gPSBldmVudC5leGNlcHRpb24gfHwge30pO1xuICBjb25zdCB2YWx1ZXMgPSAoZXhjZXB0aW9uLnZhbHVlcyA9IGV4Y2VwdGlvbi52YWx1ZXMgfHwgW10pO1xuICBjb25zdCBmaXJzdEV4Y2VwdGlvbiA9ICh2YWx1ZXNbMF0gPSB2YWx1ZXNbMF0gfHwge30pO1xuICBpZiAoIWZpcnN0RXhjZXB0aW9uLnZhbHVlKSB7XG4gICAgZmlyc3RFeGNlcHRpb24udmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgfVxuICBpZiAoIWZpcnN0RXhjZXB0aW9uLnR5cGUpIHtcbiAgICBmaXJzdEV4Y2VwdGlvbi50eXBlID0gdHlwZSB8fCAnRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBleGNlcHRpb24gbWVjaGFuaXNtIGRhdGEgdG8gYSBnaXZlbiBldmVudC4gVXNlcyBkZWZhdWx0cyBpZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLlxuICpcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIG5ld01lY2hhbmlzbSBNZWNoYW5pc20gZGF0YSB0byBhZGQgdG8gdGhlIGV2ZW50LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQsIG5ld01lY2hhbmlzbSkge1xuICBjb25zdCBmaXJzdEV4Y2VwdGlvbiA9IGdldEZpcnN0RXhjZXB0aW9uKGV2ZW50KTtcbiAgaWYgKCFmaXJzdEV4Y2VwdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRNZWNoYW5pc20gPSB7IHR5cGU6ICdnZW5lcmljJywgaGFuZGxlZDogdHJ1ZSB9O1xuICBjb25zdCBjdXJyZW50TWVjaGFuaXNtID0gZmlyc3RFeGNlcHRpb24ubWVjaGFuaXNtO1xuICBmaXJzdEV4Y2VwdGlvbi5tZWNoYW5pc20gPSB7IC4uLmRlZmF1bHRNZWNoYW5pc20sIC4uLmN1cnJlbnRNZWNoYW5pc20sIC4uLm5ld01lY2hhbmlzbSB9O1xuXG4gIGlmIChuZXdNZWNoYW5pc20gJiYgJ2RhdGEnIGluIG5ld01lY2hhbmlzbSkge1xuICAgIGNvbnN0IG1lcmdlZERhdGEgPSB7IC4uLmN1cnJlbnRNZWNoYW5pc20/LmRhdGEsIC4uLm5ld01lY2hhbmlzbS5kYXRhIH07XG4gICAgZmlyc3RFeGNlcHRpb24ubWVjaGFuaXNtLmRhdGEgPSBtZXJnZWREYXRhO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vc2VtdmVyLm9yZy8jaXMtdGhlcmUtYS1zdWdnZXN0ZWQtcmVndWxhci1leHByZXNzaW9uLXJlZ2V4LXRvLWNoZWNrLWEtc2VtdmVyLXN0cmluZ1xuY29uc3QgU0VNVkVSX1JFR0VYUCA9XG4gIC9eKDB8WzEtOV1cXGQqKVxcLigwfFsxLTldXFxkKilcXC4oMHxbMS05XVxcZCopKD86LSgoPzowfFsxLTldXFxkKnxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikoPzpcXC4oPzowfFsxLTldXFxkKnxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikpKikpPyg/OlxcKyhbMC05YS16QS1aLV0rKD86XFwuWzAtOWEtekEtWi1dKykqKSk/JC87XG5cbi8qKlxuICogUmVwcmVzZW50cyBTZW1hbnRpYyBWZXJzaW9uaW5nIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIF9wYXJzZUludChpbnB1dCkge1xuICByZXR1cm4gcGFyc2VJbnQoaW5wdXQgfHwgJycsIDEwKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgaW5wdXQgaW50byBhIFNlbVZlciBpbnRlcmZhY2VcbiAqIEBwYXJhbSBpbnB1dCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZW12ZXIgdmVyc2lvblxuICovXG5mdW5jdGlvbiBwYXJzZVNlbXZlcihpbnB1dCkge1xuICBjb25zdCBtYXRjaCA9IGlucHV0Lm1hdGNoKFNFTVZFUl9SRUdFWFApIHx8IFtdO1xuICBjb25zdCBtYWpvciA9IF9wYXJzZUludChtYXRjaFsxXSk7XG4gIGNvbnN0IG1pbm9yID0gX3BhcnNlSW50KG1hdGNoWzJdKTtcbiAgY29uc3QgcGF0Y2ggPSBfcGFyc2VJbnQobWF0Y2hbM10pO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkbWV0YWRhdGE6IG1hdGNoWzVdLFxuICAgIG1ham9yOiBpc05hTihtYWpvcikgPyB1bmRlZmluZWQgOiBtYWpvcixcbiAgICBtaW5vcjogaXNOYU4obWlub3IpID8gdW5kZWZpbmVkIDogbWlub3IsXG4gICAgcGF0Y2g6IGlzTmFOKHBhdGNoKSA/IHVuZGVmaW5lZCA6IHBhdGNoLFxuICAgIHByZXJlbGVhc2U6IG1hdGNoWzRdLFxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjb250ZXh0IChwcmUvcG9zdC9saW5lKSBsaW5lcyB0byB0aGUgcHJvdmlkZWQgZnJhbWVcbiAqXG4gKiBAcGFyYW0gbGluZXMgc3RyaW5nW10gY29udGFpbmluZyBhbGwgbGluZXNcbiAqIEBwYXJhbSBmcmFtZSBTdGFja0ZyYW1lIHRoYXQgd2lsbCBiZSBtdXRhdGVkXG4gKiBAcGFyYW0gbGluZXNPZkNvbnRleHQgbnVtYmVyIG9mIGNvbnRleHQgbGluZXMgd2Ugd2FudCB0byBhZGQgcHJlL3Bvc3RcbiAqL1xuZnVuY3Rpb24gYWRkQ29udGV4dFRvRnJhbWUobGluZXMsIGZyYW1lLCBsaW5lc09mQ29udGV4dCA9IDUpIHtcbiAgLy8gV2hlbiB0aGVyZSBpcyBubyBsaW5lIG51bWJlciBpbiB0aGUgZnJhbWUsIGF0dGFjaGluZyBjb250ZXh0IGlzIG5vbnNlbnNpY2FsIGFuZCB3aWxsIGV2ZW4gYnJlYWsgZ3JvdXBpbmdcbiAgaWYgKGZyYW1lLmxpbmVubyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbWF4TGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IHNvdXJjZUxpbmUgPSBNYXRoLm1heChNYXRoLm1pbihtYXhMaW5lcyAtIDEsIGZyYW1lLmxpbmVubyAtIDEpLCAwKTtcblxuICBmcmFtZS5wcmVfY29udGV4dCA9IGxpbmVzXG4gICAgLnNsaWNlKE1hdGgubWF4KDAsIHNvdXJjZUxpbmUgLSBsaW5lc09mQ29udGV4dCksIHNvdXJjZUxpbmUpXG4gICAgLm1hcCgobGluZSkgPT4gc25pcExpbmUobGluZSwgMCkpO1xuXG4gIC8vIFdlIGd1YXJkIGhlcmUgdG8gZW5zdXJlIHRoaXMgaXMgbm90IGxhcmdlciB0aGFuIHRoZSBleGlzdGluZyBudW1iZXIgb2YgbGluZXNcbiAgY29uc3QgbGluZUluZGV4ID0gTWF0aC5taW4obWF4TGluZXMgLSAxLCBzb3VyY2VMaW5lKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICBmcmFtZS5jb250ZXh0X2xpbmUgPSBzbmlwTGluZShsaW5lc1tsaW5lSW5kZXhdLCBmcmFtZS5jb2xubyB8fCAwKTtcblxuICBmcmFtZS5wb3N0X2NvbnRleHQgPSBsaW5lc1xuICAgIC5zbGljZShNYXRoLm1pbihzb3VyY2VMaW5lICsgMSwgbWF4TGluZXMpLCBzb3VyY2VMaW5lICsgMSArIGxpbmVzT2ZDb250ZXh0KVxuICAgIC5tYXAoKGxpbmUpID0+IHNuaXBMaW5lKGxpbmUsIDApKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3Qgd2UndmUgYWxyZWFkeSBjYXB0dXJlZCB0aGUgZ2l2ZW4gZXhjZXB0aW9uIChub3RlOiBub3QgYW4gaWRlbnRpY2FsIGV4Y2VwdGlvbiAtIHRoZSB2ZXJ5IG9iamVjdFxuICogaW4gcXVlc3Rpb24pLCBhbmQgbWFya3MgaXQgY2FwdHVyZWQgaWYgbm90LlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBmb3IgYW4gZXJyb3IgdG8gZ2V0IGNhcHR1cmVkIGJ5IG1vcmUgdGhhbiBvbmUgbWVjaGFuaXNtLiBBZnRlciB3ZSBpbnRlcmNlcHQgYW5kXG4gKiByZWNvcmQgYW4gZXJyb3IsIHdlIHJldGhyb3cgaXQgKGFzc3VtaW5nIHdlJ3ZlIGludGVyY2VwdGVkIGl0IGJlZm9yZSBpdCdzIHJlYWNoZWQgdGhlIHRvcC1sZXZlbCBnbG9iYWwgaGFuZGxlcnMpLCBzb1xuICogdGhhdCB3ZSBkb24ndCBpbnRlcmZlcmUgd2l0aCB3aGF0ZXZlciBlZmZlY3RzIHRoZSBlcnJvciBtaWdodCBoYXZlIGhhZCB3ZXJlIHRoZSBTREsgbm90IHRoZXJlLiBBdCB0aGF0IHBvaW50LCBiZWNhdXNlXG4gKiB0aGUgZXJyb3IgaGFzIGJlZW4gcmV0aHJvd24sIGl0J3MgcG9zc2libGUgZm9yIGl0IHRvIGJ1YmJsZSB1cCB0byBzb21lIG90aGVyIGNvZGUgd2UndmUgaW5zdHJ1bWVudGVkLiBJZiBpdCdzIG5vdFxuICogY2F1Z2h0IGFmdGVyIHRoYXQsIGl0IHdpbGwgYnViYmxlIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBnbG9iYWwgaGFuZGxlcnMgKHdoaWNoIG9mIGNvdXJzZSB3ZSBhbHNvIGluc3RydW1lbnQpLiBUaGlzXG4gKiBmdW5jdGlvbiBoZWxwcyB1cyBlbnN1cmUgdGhhdCBldmVuIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZSBlcnJvciBtb3JlIHRoYW4gb25jZSwgd2Ugb25seSByZWNvcmQgaXQgdGhlIGZpcnN0IHRpbWUgd2VcbiAqIHNlZSBpdC5cbiAqXG4gKiBOb3RlOiBJdCB3aWxsIGlnbm9yZSBwcmltaXRpdmVzIChhbHdheXMgcmV0dXJuIGBmYWxzZWAgYW5kIG5vdCBtYXJrIHRoZW0gYXMgc2VlbiksIGFzIHByb3BlcnRpZXMgY2FuJ3QgYmUgc2V0IG9uXG4gKiB0aGVtLiB7QGxpbms6IE9iamVjdC5vYmplY3RpZnl9IGNhbiBiZSB1c2VkIG9uIGV4Y2VwdGlvbnMgdG8gY29udmVydCBhbnkgdGhhdCBhcmUgcHJpbWl0aXZlcyBpbnRvIHRoZWlyIGVxdWl2YWxlbnRcbiAqIG9iamVjdCB3cmFwcGVyIGZvcm1zIHNvIHRoYXQgdGhpcyBjaGVjayB3aWxsIGFsd2F5cyB3b3JrLiBIb3dldmVyLCBiZWNhdXNlIHdlIG5lZWQgdG8gZmxhZyB0aGUgZXhhY3Qgb2JqZWN0IHdoaWNoXG4gKiB3aWxsIGdldCByZXRocm93biwgYW5kIGJlY2F1c2UgdGhhdCByZXRocm93aW5nIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgZXZlbnQgcHJvY2Vzc2luZyBwaXBlbGluZSwgdGhlIG9iamVjdGlmaWNhdGlvblxuICogbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgZXhjZXB0aW9uIGNhcHR1cmVkLlxuICpcbiAqIEBwYXJhbSBBIHRocm93biBleGNlcHRpb24gdG8gY2hlY2sgb3IgZmxhZyBhcyBoYXZpbmcgYmVlbiBzZWVuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV4Y2VwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkLCBgZmFsc2VgIGlmIG5vdCAod2l0aCB0aGUgc2lkZSBlZmZlY3Qgb2YgbWFya2luZyBpdCBzZWVuKVxuICovXG5mdW5jdGlvbiBjaGVja09yU2V0QWxyZWFkeUNhdWdodChleGNlcHRpb24pIHtcbiAgaWYgKGlzQWxyZWFkeUNhcHR1cmVkKGV4Y2VwdGlvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc2V0IGl0IHRoaXMgd2F5IHJhdGhlciB0aGFuIGJ5IGFzc2lnbm1lbnQgc28gdGhhdCBpdCdzIG5vdCBlbm51bWVyYWJsZSBhbmQgdGhlcmVmb3JlIGlzbid0IHJlY29yZGVkIGJ5IHRoZVxuICAgIC8vIGBFeHRyYUVycm9yRGF0YWAgaW50ZWdyYXRpb25cbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoZXhjZXB0aW9uICwgJ19fc2VudHJ5X2NhcHR1cmVkX18nLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gYGV4Y2VwdGlvbmAgaXMgYSBwcmltaXRpdmUsIHNvIHdlIGNhbid0IG1hcmsgaXQgc2VlblxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlDYXB0dXJlZChleGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGV4Y2VwdGlvbiApLl9fc2VudHJ5X2NhcHR1cmVkX187XG4gIH0gY2F0Y2gge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufVxuXG5leHBvcnQgeyBhZGRDb250ZXh0VG9GcmFtZSwgYWRkRXhjZXB0aW9uTWVjaGFuaXNtLCBhZGRFeGNlcHRpb25UeXBlVmFsdWUsIGNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0LCBnZXRFdmVudERlc2NyaXB0aW9uLCBwYXJzZVNlbXZlciwgdXVpZDQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/normalize.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/normalize.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   normalizeToSize: function() { return /* binding */ normalizeToSize; },\n/* harmony export */   normalizeUrlToBase: function() { return /* binding */ normalizeUrlToBase; }\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _stacktrace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stacktrace.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js\");\n\n\n\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normalized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction normalize(input, depth = 100, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (\n    value == null || // this matches null and undefined -> eqeq not eqeqeq\n    ['boolean', 'string'].includes(typeof value) ||\n    (typeof value === 'number' && Number.isFinite(value))\n  ) {\n    return value ;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We can set `__sentry_override_normalization_depth__` on an object to ensure that from there\n  // We keep a certain amount of depth.\n  // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.\n  const remainingDepth =\n    typeof (value )['__sentry_override_normalization_depth__'] === 'number'\n      ? ((value )['__sentry_override_normalization_depth__'] )\n      : depth;\n\n  // We're also done if we've reached the max depth\n  if (remainingDepth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  const valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      const jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, remainingDepth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = (0,_object_js__WEBPACK_IMPORTED_MODULE_0__.convertToPlainObject)(value );\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n\n    numAdded++;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/* eslint-disable complexity */\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isVueViewModel)(value)) {\n      return '[VueViewModel]';\n    }\n\n    // React's SyntheticEvent thingy\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isSyntheticEvent)(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && !Number.isFinite(value)) {\n      return `[${value}]`;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${(0,_stacktrace_js__WEBPACK_IMPORTED_MODULE_2__.getFunctionName)(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    const objName = getConstructorName(value);\n\n    // Handle HTML Elements\n    if (/^HTML(\\w*)Element$/.test(objName)) {\n      return `[HTMLElement: ${objName}]`;\n    }\n\n    return `[object ${objName}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n/* eslint-enable complexity */\n\nfunction getConstructorName(value) {\n  const prototype = Object.getPrototypeOf(value);\n\n  return prototype?.constructor ? prototype.constructor.name : 'null prototype';\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\n/**\n * Normalizes URLs in exceptions and stacktraces to a base path so Sentry can fingerprint\n * across platforms and working directory.\n *\n * @param url The URL to be normalized.\n * @param basePath The application base path.\n * @returns The normalized URL.\n */\nfunction normalizeUrlToBase(url, basePath) {\n  const escapedBase = basePath\n    // Backslash to forward\n    .replace(/\\\\/g, '/')\n    // Escape RegExp special characters\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n\n  let newUrl = url;\n  try {\n    newUrl = decodeURI(url);\n  } catch (_Oo) {\n    // Sometime this breaks\n  }\n  return (\n    newUrl\n      .replace(/\\\\/g, '/')\n      .replace(/webpack:\\/?/g, '') // Remove intermediate base path\n      // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor\n      .replace(new RegExp(`(file://)?/*${escapedBase}/*`, 'ig'), 'app:///')\n  );\n}\n\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  const inner = new WeakSet();\n  function memoize(obj) {\n    if (inner.has(obj)) {\n      return true;\n    }\n    inner.add(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    inner.delete(obj);\n  }\n  return [memoize, unmemoize];\n}\n\n\n//# sourceMappingURL=normalize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9ub3JtYWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJEO0FBQ1I7QUFDRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWEsZ0NBQWdDLElBQUk7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsc0RBQWM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFFBQVEsd0RBQWdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQTtBQUNBLDJCQUEyQiwrREFBZSxRQUFRO0FBQ2xEOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCLElBQUk7QUFDSixvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEQ7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L25vcm1hbGl6ZS5qcz9kMTdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVnVlVmlld01vZGVsLCBpc1N5bnRoZXRpY0V2ZW50IH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9QbGFpbk9iamVjdCB9IGZyb20gJy4vb2JqZWN0LmpzJztcbmltcG9ydCB7IGdldEZ1bmN0aW9uTmFtZSB9IGZyb20gJy4vc3RhY2t0cmFjZS5qcyc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbm9ybWFsaXplcyB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIC0gQ3JlYXRlcyBhIGNvcHkgdG8gcHJldmVudCBvcmlnaW5hbCBpbnB1dCBtdXRhdGlvblxuICogLSBTa2lwcyBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAtIFdoZW4gc3RyaW5naWZ5aW5nLCBjYWxscyBgdG9KU09OYCBpZiBpbXBsZW1lbnRlZFxuICogLSBSZW1vdmVzIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAqIC0gVHJhbnNsYXRlcyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyAoYHVuZGVmaW5lZGAvYE5hTmAvZnVuY3Rpb25zKSB0byBzZXJpYWxpemFibGUgZm9ybWF0XG4gKiAtIFRyYW5zbGF0ZXMga25vd24gZ2xvYmFsIG9iamVjdHMvY2xhc3NlcyB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbnNcbiAqIC0gVGFrZXMgY2FyZSBvZiBgRXJyb3JgIG9iamVjdCBzZXJpYWxpemF0aW9uXG4gKiAtIE9wdGlvbmFsbHkgbGltaXRzIGRlcHRoIG9mIGZpbmFsIG91dHB1dFxuICogLSBPcHRpb25hbGx5IGxpbWl0cyBudW1iZXIgb2YgcHJvcGVydGllcy9lbGVtZW50cyBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIG9iamVjdC9hcnJheVxuICpcbiAqIEBwYXJhbSBpbnB1dCBUaGUgb2JqZWN0IHRvIGJlIG5vcm1hbGl6ZWQuXG4gKiBAcGFyYW0gZGVwdGggVGhlIG1heCBkZXB0aCB0byB3aGljaCB0byBub3JtYWxpemUgdGhlIG9iamVjdC4gKEFueXRoaW5nIGRlZXBlciBzdHJpbmdpZmllZCB3aG9sZS4pXG4gKiBAcGFyYW0gbWF4UHJvcGVydGllcyBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBvciBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBzaW5nbGUgYXJyYXkgb3JcbiAqIG9iamVjdCBpbiB0aGUgbm9ybWFsaXplZCBvdXRwdXQuXG4gKiBAcmV0dXJucyBBIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgb2JqZWN0LCBvciBgXCIqKm5vbi1zZXJpYWxpemFibGUqKlwiYCBpZiBhbnkgZXJyb3JzIGFyZSB0aHJvd24gZHVyaW5nIG5vcm1hbGl6YXRpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQsIGRlcHRoID0gMTAwLCBtYXhQcm9wZXJ0aWVzID0gK0luZmluaXR5KSB7XG4gIHRyeSB7XG4gICAgLy8gc2luY2Ugd2UncmUgYXQgdGhlIG91dGVybW9zdCBsZXZlbCwgd2UgZG9uJ3QgcHJvdmlkZSBhIGtleVxuICAgIHJldHVybiB2aXNpdCgnJywgaW5wdXQsIGRlcHRoLCBtYXhQcm9wZXJ0aWVzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgRVJST1I6IGAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHtlcnJ9KWAgfTtcbiAgfVxufVxuXG4vKiogSlNEb2MgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvU2l6ZShcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgb2JqZWN0LFxuICAvLyBEZWZhdWx0IE5vZGUuanMgUkVQTCBkZXB0aFxuICBkZXB0aCA9IDMsXG4gIC8vIDEwMGtCLCBhcyAyMDBrQiBpcyBtYXggcGF5bG9hZCBzaXplLCBzbyBoYWxmIHNvdW5kcyByZWFzb25hYmxlXG4gIG1heFNpemUgPSAxMDAgKiAxMDI0LFxuKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUob2JqZWN0LCBkZXB0aCk7XG5cbiAgaWYgKGpzb25TaXplKG5vcm1hbGl6ZWQpID4gbWF4U2l6ZSkge1xuICAgIHJldHVybiBub3JtYWxpemVUb1NpemUob2JqZWN0LCBkZXB0aCAtIDEsIG1heFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQgO1xufVxuXG4vKipcbiAqIFZpc2l0cyBhIG5vZGUgdG8gcGVyZm9ybSBub3JtYWxpemF0aW9uIG9uIGl0XG4gKlxuICogQHBhcmFtIGtleSBUaGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIG5vZGVcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbm9kZSB0byBiZSB2aXNpdGVkXG4gKiBAcGFyYW0gZGVwdGggT3B0aW9uYWwgbnVtYmVyIGluZGljYXRpbmcgdGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoXG4gKiBAcGFyYW0gbWF4UHJvcGVydGllcyBPcHRpb25hbCBtYXhpbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzL2VsZW1lbnRzIGluY2x1ZGVkIGluIGFueSBzaW5nbGUgb2JqZWN0L2FycmF5XG4gKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBNZW1vIGNsYXNzIGhhbmRsaW5nIGRlY3ljbGluZ1xuICovXG5mdW5jdGlvbiB2aXNpdChcbiAga2V5LFxuICB2YWx1ZSxcbiAgZGVwdGggPSArSW5maW5pdHksXG4gIG1heFByb3BlcnRpZXMgPSArSW5maW5pdHksXG4gIG1lbW8gPSBtZW1vQnVpbGRlcigpLFxuKSB7XG4gIGNvbnN0IFttZW1vaXplLCB1bm1lbW9pemVdID0gbWVtbztcblxuICAvLyBHZXQgdGhlIHNpbXBsZSBjYXNlcyBvdXQgb2YgdGhlIHdheSBmaXJzdFxuICBpZiAoXG4gICAgdmFsdWUgPT0gbnVsbCB8fCAvLyB0aGlzIG1hdGNoZXMgbnVsbCBhbmQgdW5kZWZpbmVkIC0+IGVxZXEgbm90IGVxZXFlcVxuICAgIFsnYm9vbGVhbicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHZhbHVlIDtcbiAgfVxuXG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5VmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgLy8gQW55dGhpbmcgd2UgY291bGQgcG90ZW50aWFsbHkgZGlnIGludG8gbW9yZSAob2JqZWN0cyBvciBhcnJheXMpIHdpbGwgaGF2ZSBjb21lIGJhY2sgYXMgYFwiW29iamVjdCBYWFhYXVwiYC5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gc2VyaWFsaXplZCwgc28gaWYgd2UgZG9uJ3Qgc2VlIHRoYXQgcGF0dGVybiwgd2UncmUgZG9uZS5cbiAgaWYgKCFzdHJpbmdpZmllZC5zdGFydHNXaXRoKCdbb2JqZWN0ICcpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICB9XG5cbiAgLy8gRnJvbSBoZXJlIG9uLCB3ZSBjYW4gYXNzZXJ0IHRoYXQgYHZhbHVlYCBpcyBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXG4gIC8vIERvIG5vdCBub3JtYWxpemUgb2JqZWN0cyB0aGF0IHdlIGtub3cgaGF2ZSBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC4gQXMgYSBnZW5lcmFsIHJ1bGUsIHRoZVxuICAvLyBcIl9fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fXCIgcHJvcGVydHkgc2hvdWxkIG9ubHkgYmUgdXNlZCBzcGFyaW5nbHkgYW5kIG9ubHkgc2hvdWxkIG9ubHkgYmUgc2V0IG9uIG9iamVjdHMgdGhhdFxuICAvLyBoYXZlIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLlxuICBpZiAoKHZhbHVlIClbJ19fc2VudHJ5X3NraXBfbm9ybWFsaXphdGlvbl9fJ10pIHtcbiAgICByZXR1cm4gdmFsdWUgO1xuICB9XG5cbiAgLy8gV2UgY2FuIHNldCBgX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fYCBvbiBhbiBvYmplY3QgdG8gZW5zdXJlIHRoYXQgZnJvbSB0aGVyZVxuICAvLyBXZSBrZWVwIGEgY2VydGFpbiBhbW91bnQgb2YgZGVwdGguXG4gIC8vIFRoaXMgc2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5LCBlLmcuIHdlIHVzZSBpdCBmb3IgdGhlIHJlZHV4IGludGVncmF0aW9uIHRvIGVuc3VyZSB3ZSBnZXQgYSBjZXJ0YWluIGFtb3VudCBvZiBzdGF0ZS5cbiAgY29uc3QgcmVtYWluaW5nRGVwdGggPVxuICAgIHR5cGVvZiAodmFsdWUgKVsnX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fJ10gPT09ICdudW1iZXInXG4gICAgICA/ICgodmFsdWUgKVsnX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fJ10gKVxuICAgICAgOiBkZXB0aDtcblxuICAvLyBXZSdyZSBhbHNvIGRvbmUgaWYgd2UndmUgcmVhY2hlZCB0aGUgbWF4IGRlcHRoXG4gIGlmIChyZW1haW5pbmdEZXB0aCA9PT0gMCkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBgc2VyaWFsaXplZGAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gYFwiW29iamVjdCBYWFhYXVwiYC4gQ2xlYW4gaXQgdXAgc28gaXQncyBqdXN0IGBcIltYWFhYXVwiYC5cbiAgICByZXR1cm4gc3RyaW5naWZpZWQucmVwbGFjZSgnb2JqZWN0ICcsICcnKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGlzIGJyYW5jaCwgYmFpbCBvdXQsIGFzIGl0J3MgY2lyY3VsYXIgcmVmZXJlbmNlLiBJZiBub3QsIG5vdGUgdGhhdCB3ZSdyZSBzZWVpbmcgaXQgbm93LlxuICBpZiAobWVtb2l6ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gIH1cblxuICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgYHRvSlNPTmAgbWV0aG9kLCB3ZSBjYWxsIGl0IHRvIGV4dHJhY3QgbW9yZSBpbmZvcm1hdGlvblxuICBjb25zdCB2YWx1ZVdpdGhUb0pTT04gPSB2YWx1ZSA7XG4gIGlmICh2YWx1ZVdpdGhUb0pTT04gJiYgdHlwZW9mIHZhbHVlV2l0aFRvSlNPTi50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QganNvblZhbHVlID0gdmFsdWVXaXRoVG9KU09OLnRvSlNPTigpO1xuICAgICAgLy8gV2UgbmVlZCB0byBub3JtYWxpemUgdGhlIHJldHVybiB2YWx1ZSBvZiBgLnRvSlNPTigpYCBpbiBjYXNlIGl0IGhhcyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICByZXR1cm4gdmlzaXQoJycsIGpzb25WYWx1ZSwgcmVtYWluaW5nRGVwdGggLSAxLCBtYXhQcm9wZXJ0aWVzLCBtZW1vKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHBhc3MgKFRoZSBidWlsdC1pbiBgdG9KU09OYCBmYWlsZWQsIGJ1dCB3ZSBjYW4gc3RpbGwgdHJ5IHRvIGRvIGl0IG91cnNlbHZlcylcbiAgICB9XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgd2UgZWl0aGVyIGhhdmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5LCB3ZSBoYXZlbid0IHNlZW4gaXQgYmVmb3JlLCBhbmQgd2UncmUgZ29pbmcgdG8gcmVjdXJzZVxuICAvLyBiZWNhdXNlIHdlIGhhdmVuJ3QgeWV0IHJlYWNoZWQgdGhlIG1heCBkZXB0aC4gQ3JlYXRlIGFuIGFjY3VtdWxhdG9yIHRvIGhvbGQgdGhlIHJlc3VsdHMgb2YgdmlzaXRpbmcgZWFjaFxuICAvLyBwcm9wZXJ0eS9lbnRyeSwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBpdGVtcyB3ZSBhZGQgdG8gaXQuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9KSA7XG4gIGxldCBudW1BZGRlZCA9IDA7XG5cbiAgLy8gQmVmb3JlIHdlIGJlZ2luLCBjb252ZXJ0YEVycm9yYCBhbmRgRXZlbnRgIGluc3RhbmNlcyBpbnRvIHBsYWluIG9iamVjdHMsIHNpbmNlIHNvbWUgb2YgZWFjaCBvZiB0aGVpciByZWxldmFudFxuICAvLyBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSBhbmQgb3RoZXJ3aXNlIHdvdWxkIGdldCBtaXNzZWQuXG4gIGNvbnN0IHZpc2l0YWJsZSA9IGNvbnZlcnRUb1BsYWluT2JqZWN0KHZhbHVlICk7XG5cbiAgZm9yIChjb25zdCB2aXNpdEtleSBpbiB2aXNpdGFibGUpIHtcbiAgICAvLyBBdm9pZCBpdGVyYXRpbmcgb3ZlciBmaWVsZHMgaW4gdGhlIHByb3RvdHlwZSBpZiB0aGV5J3ZlIHNvbWVob3cgYmVlbiBleHBvc2VkIHRvIGVudW1lcmF0aW9uLlxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpc2l0YWJsZSwgdmlzaXRLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobnVtQWRkZWQgPj0gbWF4UHJvcGVydGllcykge1xuICAgICAgbm9ybWFsaXplZFt2aXNpdEtleV0gPSAnW01heFByb3BlcnRpZXMgfl0nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUmVjdXJzaXZlbHkgdmlzaXQgYWxsIHRoZSBjaGlsZCBub2Rlc1xuICAgIGNvbnN0IHZpc2l0VmFsdWUgPSB2aXNpdGFibGVbdmlzaXRLZXldO1xuICAgIG5vcm1hbGl6ZWRbdmlzaXRLZXldID0gdmlzaXQodmlzaXRLZXksIHZpc2l0VmFsdWUsIHJlbWFpbmluZ0RlcHRoIC0gMSwgbWF4UHJvcGVydGllcywgbWVtbyk7XG5cbiAgICBudW1BZGRlZCsrO1xuICB9XG5cbiAgLy8gT25jZSB3ZSd2ZSB2aXNpdGVkIGFsbCB0aGUgYnJhbmNoZXMsIHJlbW92ZSB0aGUgcGFyZW50IGZyb20gbWVtbyBzdG9yYWdlXG4gIHVubWVtb2l6ZSh2YWx1ZSk7XG5cbiAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHZhbHVlc1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIHZhbHVlLiBIYW5kbGVzIHZhcmlvdXMga25vd24gc3BlY2lhbCB2YWx1ZXMgYW5kIHR5cGVzLlxuICpcbiAqIE5vdCBtZWFudCB0byBiZSB1c2VkIG9uIHNpbXBsZSBwcmltaXRpdmVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgYXMgaXQgd2lsbCwgZm9yIGV4YW1wbGUsIHR1cm5cbiAqIHRoZSBudW1iZXIgMTIzMSBpbnRvIFwiW09iamVjdCBOdW1iZXJdXCIsIG5vciBvbiBgbnVsbGAsIGFzIGl0IHdpbGwgdGhyb3cuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnlcbiAqIEByZXR1cm5zIEEgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKFxuICBrZXksXG4gIC8vIHRoaXMgdHlwZSBpcyBhIHRpbnkgYml0IG9mIGEgY2hlYXQsIHNpbmNlIHRoaXMgZnVuY3Rpb24gZG9lcyBoYW5kbGUgTmFOICh3aGljaCBpcyB0ZWNobmljYWxseSBhIG51bWJlciksIGJ1dCBmb3JcbiAgLy8gb3VyIGludGVybmFsIHVzZSwgaXQnbGwgZG9cbiAgdmFsdWUsXG4pIHtcbiAgdHJ5IHtcbiAgICBpZiAoa2V5ID09PSAnZG9tYWluJyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICh2YWx1ZSApLl9ldmVudHMpIHtcbiAgICAgIHJldHVybiAnW0RvbWFpbl0nO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdkb21haW5FbWl0dGVyJykge1xuICAgICAgcmV0dXJuICdbRG9tYWluRW1pdHRlcl0nO1xuICAgIH1cblxuICAgIC8vIEl0J3Mgc2FmZSB0byB1c2UgYGdsb2JhbGAsIGB3aW5kb3dgLCBhbmQgYGRvY3VtZW50YCBoZXJlIGluIHRoaXMgbWFubmVyLCBhcyB3ZSBhcmUgYXNzZXJ0aW5nIHVzaW5nIGB0eXBlb2ZgIGZpcnN0XG4gICAgLy8gd2hpY2ggd29uJ3QgdGhyb3cgaWYgdGhleSBhcmUgbm90IHByZXNlbnQuXG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgPT09IGdsb2JhbCkge1xuICAgICAgcmV0dXJuICdbR2xvYmFsXSc7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gd2luZG93KSB7XG4gICAgICByZXR1cm4gJ1tXaW5kb3ddJztcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgPT09IGRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gJ1tEb2N1bWVudF0nO1xuICAgIH1cblxuICAgIGlmIChpc1Z1ZVZpZXdNb2RlbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnW1Z1ZVZpZXdNb2RlbF0nO1xuICAgIH1cblxuICAgIC8vIFJlYWN0J3MgU3ludGhldGljRXZlbnQgdGhpbmd5XG4gICAgaWYgKGlzU3ludGhldGljRXZlbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ1tTeW50aGV0aWNFdmVudF0nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gYFske3ZhbHVlfV1gO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBgW0Z1bmN0aW9uOiAke2dldEZ1bmN0aW9uTmFtZSh2YWx1ZSl9XWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiBgWyR7U3RyaW5nKHZhbHVlKX1dYDtcbiAgICB9XG5cbiAgICAvLyBzdHJpbmdpZmllZCBCaWdJbnRzIGFyZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIHJlZ3VsYXIgbnVtYmVycywgc28gd2UgbmVlZCB0byBsYWJlbCB0aGVtIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZXR1cm4gYFtCaWdJbnQ6ICR7U3RyaW5nKHZhbHVlKX1dYDtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBrbm9ja2VkIG91dCBhbGwgdGhlIHNwZWNpYWwgY2FzZXMgYW5kIHRoZSBwcmltaXRpdmVzLCBhbGwgd2UgaGF2ZSBsZWZ0IGFyZSBvYmplY3RzLiBTaW1wbHkgY2FzdGluZ1xuICAgIC8vIHRoZW0gdG8gc3RyaW5ncyBtZWFucyB0aGF0IGluc3RhbmNlcyBvZiBjbGFzc2VzIHdoaWNoIGhhdmVuJ3QgZGVmaW5lZCB0aGVpciBgdG9TdHJpbmdUYWdgIHdpbGwganVzdCBjb21lIG91dCBhc1xuICAgIC8vIGBcIltvYmplY3QgT2JqZWN0XVwiYC4gSWYgd2UgaW5zdGVhZCBsb29rIGF0IHRoZSBjb25zdHJ1Y3RvcidzIG5hbWUgKHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyksXG4gICAgLy8gd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IG9ubHkgcGxhaW4gb2JqZWN0cyBjb21lIG91dCB0aGF0IHdheS5cbiAgICBjb25zdCBvYmpOYW1lID0gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKTtcblxuICAgIC8vIEhhbmRsZSBIVE1MIEVsZW1lbnRzXG4gICAgaWYgKC9eSFRNTChcXHcqKUVsZW1lbnQkLy50ZXN0KG9iak5hbWUpKSB7XG4gICAgICByZXR1cm4gYFtIVE1MRWxlbWVudDogJHtvYmpOYW1lfV1gO1xuICAgIH1cblxuICAgIHJldHVybiBgW29iamVjdCAke29iak5hbWV9XWA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBgKipub24tc2VyaWFsaXphYmxlKiogKCR7ZXJyfSlgO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKSB7XG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cbiAgcmV0dXJuIHByb3RvdHlwZT8uY29uc3RydWN0b3IgPyBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSA6ICdudWxsIHByb3RvdHlwZSc7XG59XG5cbi8qKiBDYWxjdWxhdGVzIGJ5dGVzIHNpemUgb2YgaW5wdXQgc3RyaW5nICovXG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIHJldHVybiB+LWVuY29kZVVSSSh2YWx1ZSkuc3BsaXQoLyUuLnwuLykubGVuZ3RoO1xufVxuXG4vKiogQ2FsY3VsYXRlcyBieXRlcyBzaXplIG9mIGlucHV0IG9iamVjdCAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGpzb25TaXplKHZhbHVlKSB7XG4gIHJldHVybiB1dGY4TGVuZ3RoKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBVUkxzIGluIGV4Y2VwdGlvbnMgYW5kIHN0YWNrdHJhY2VzIHRvIGEgYmFzZSBwYXRoIHNvIFNlbnRyeSBjYW4gZmluZ2VycHJpbnRcbiAqIGFjcm9zcyBwbGF0Zm9ybXMgYW5kIHdvcmtpbmcgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIGJhc2VQYXRoIFRoZSBhcHBsaWNhdGlvbiBiYXNlIHBhdGguXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBVUkwuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybFRvQmFzZSh1cmwsIGJhc2VQYXRoKSB7XG4gIGNvbnN0IGVzY2FwZWRCYXNlID0gYmFzZVBhdGhcbiAgICAvLyBCYWNrc2xhc2ggdG8gZm9yd2FyZFxuICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAvLyBFc2NhcGUgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpO1xuXG4gIGxldCBuZXdVcmwgPSB1cmw7XG4gIHRyeSB7XG4gICAgbmV3VXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH0gY2F0Y2ggKF9Pbykge1xuICAgIC8vIFNvbWV0aW1lIHRoaXMgYnJlYWtzXG4gIH1cbiAgcmV0dXJuIChcbiAgICBuZXdVcmxcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAgIC5yZXBsYWNlKC93ZWJwYWNrOlxcLz8vZywgJycpIC8vIFJlbW92ZSBpbnRlcm1lZGlhdGUgYmFzZSBwYXRoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNlbnRyeS1pbnRlcm5hbC9zZGsvbm8tcmVnZXhwLWNvbnN0cnVjdG9yXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2VzY2FwZWRCYXNlfS8qYCwgJ2lnJyksICdhcHA6Ly8vJylcbiAgKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGVjeWNsZSBqc29uIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gbWVtb0J1aWxkZXIoKSB7XG4gIGNvbnN0IGlubmVyID0gbmV3IFdlYWtTZXQoKTtcbiAgZnVuY3Rpb24gbWVtb2l6ZShvYmopIHtcbiAgICBpZiAoaW5uZXIuaGFzKG9iaikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbm5lci5hZGQob2JqKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1lbW9pemUob2JqKSB7XG4gICAgaW5uZXIuZGVsZXRlKG9iaik7XG4gIH1cbiAgcmV0dXJuIFttZW1vaXplLCB1bm1lbW9pemVdO1xufVxuXG5leHBvcnQgeyBub3JtYWxpemUsIG5vcm1hbGl6ZVRvU2l6ZSwgbm9ybWFsaXplVXJsVG9CYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/normalize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/object.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNonEnumerableProperty: function() { return /* binding */ addNonEnumerableProperty; },\n/* harmony export */   convertToPlainObject: function() { return /* binding */ convertToPlainObject; },\n/* harmony export */   dropUndefinedKeys: function() { return /* binding */ dropUndefinedKeys; },\n/* harmony export */   extractExceptionKeysForMessage: function() { return /* binding */ extractExceptionKeysForMessage; },\n/* harmony export */   fill: function() { return /* binding */ fill; },\n/* harmony export */   getOriginalFunction: function() { return /* binding */ getOriginalFunction; },\n/* harmony export */   markFunctionWrapped: function() { return /* binding */ markFunctionWrapped; },\n/* harmony export */   objectify: function() { return /* binding */ objectify; }\n/* harmony export */ });\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./browser.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/browser.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js\");\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js\");\n\n\n\n\n\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * If the method on the passed object is not a function, the wrapper will not be applied.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  // explicitly casting to unknown because we don't know the type of the method initially at all\n  const original = source[name] ;\n\n  if (typeof original !== 'function') {\n    return;\n  }\n\n  const wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    markFunctionWrapped(wrapped, original);\n  }\n\n  try {\n    source[name] = wrapped;\n  } catch {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG_BUILD && _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Failed to replace method \"${name}\" in object`, source);\n  }\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  try {\n    Object.defineProperty(obj, name, {\n      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n      value: value,\n      writable: true,\n      configurable: true,\n    });\n  } catch (o_O) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG_BUILD && _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n  }\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  try {\n    const proto = original.prototype || {};\n    wrapped.prototype = original.prototype = proto;\n    addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n  } catch (o_O) {} // eslint-disable-line no-empty\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(value)\n\n {\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isError)(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isEvent)(value)) {\n    const newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isInstanceOf)(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isElement)(target) ? (0,_browser_js__WEBPACK_IMPORTED_MODULE_3__.htmlTreeAsString)(target) : Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  const firstKey = keys[0];\n\n  if (!firstKey) {\n    return '[object has no keys]';\n  }\n\n  if (firstKey.length >= maxLength) {\n    return (0,_string_js__WEBPACK_IMPORTED_MODULE_4__.truncate)(firstKey, maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return (0,_string_js__WEBPACK_IMPORTED_MODULE_4__.truncate)(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n *\n * @deprecated This function is no longer used by the SDK and will be removed in a future major version.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  const memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  // Early return for primitive values\n  if (inputValue === null || typeof inputValue !== 'object') {\n    return inputValue;\n  }\n\n  // Check memo map first for all object types\n  const memoVal = memoizationMap.get(inputValue);\n  if (memoVal !== undefined) {\n    return memoVal ;\n  }\n\n  // handle arrays\n  if (Array.isArray(inputValue)) {\n    const returnValue = [];\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach(value => {\n      returnValue.push(_dropUndefinedKeys(value, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  if (isPojo(inputValue)) {\n    const returnValue = {};\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    const keys = Object.keys(inputValue);\n\n    keys.forEach(key => {\n      const val = inputValue[key];\n      if (val !== undefined) {\n        returnValue[key] = _dropUndefinedKeys(val, memoizationMap);\n      }\n    });\n\n    return returnValue ;\n  }\n\n  // For other object types, return as is\n  return inputValue;\n}\n\nfunction isPojo(input) {\n  // Plain objects have Object as constructor or no constructor\n  const constructor = (input ).constructor;\n  return constructor === Object || constructor === undefined;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    // this will catch both undefined and null\n    case wat == undefined:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isPrimitive)(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\n\n//# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9vYmplY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNEO0FBQ2tDO0FBQzVDO0FBQ0U7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUksd0RBQVcsSUFBSSw4Q0FBTSxrQ0FBa0MsS0FBSztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLElBQUksd0RBQVcsSUFBSSw4Q0FBTSwrQ0FBK0MsS0FBSztBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sK0NBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsK0NBQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxvREFBWTtBQUMxRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlEQUFTLFdBQVcsNkRBQWdCO0FBQy9DLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjs7QUFFQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtREFBVztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdLO0FBQ3hLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9vYmplY3QuanM/MDNlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBodG1sVHJlZUFzU3RyaW5nIH0gZnJvbSAnLi9icm93c2VyLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBpc0Vycm9yLCBpc0V2ZW50LCBpc0luc3RhbmNlT2YsIGlzUHJpbWl0aXZlLCBpc0VsZW1lbnQgfSBmcm9tICcuL2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLmpzJztcbmltcG9ydCB7IHRydW5jYXRlIH0gZnJvbSAnLi9zdHJpbmcuanMnO1xuXG4vKipcbiAqIFJlcGxhY2UgYSBtZXRob2QgaW4gYW4gb2JqZWN0IHdpdGggYSB3cmFwcGVkIHZlcnNpb24gb2YgaXRzZWxmLlxuICpcbiAqIElmIHRoZSBtZXRob2Qgb24gdGhlIHBhc3NlZCBvYmplY3QgaXMgbm90IGEgZnVuY3Rpb24sIHRoZSB3cmFwcGVyIHdpbGwgbm90IGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHNvdXJjZSBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG1ldGhvZCB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIHJlcGxhY2VtZW50RmFjdG9yeSBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBtZXRob2QgYW5kIHJldHVybnMgYVxuICogd3JhcHBlZCB2ZXJzaW9uLiBOb3RlOiBUaGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYHJlcGxhY2VtZW50RmFjdG9yeWAgbmVlZHMgdG8gYmUgYSBub24tYXJyb3cgZnVuY3Rpb24sIGluIG9yZGVyIHRvXG4gKiBwcmVzZXJ2ZSB0aGUgY29ycmVjdCB2YWx1ZSBvZiBgdGhpc2AsIGFuZCB0aGUgb3JpZ2luYWwgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHVzaW5nIGBvcmlnTWV0aG9kLmNhbGwodGhpcywgPG90aGVyXG4gKiBhcmdzPilgIG9yIGBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIFs8b3RoZXIgYXJncz5dKWAgKHJhdGhlciB0aGFuIGJlaW5nIGNhbGxlZCBkaXJlY3RseSksIGFnYWluIHRvIHByZXNlcnZlIGB0aGlzYC5cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuZnVuY3Rpb24gZmlsbChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50RmFjdG9yeSkge1xuICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBleHBsaWNpdGx5IGNhc3RpbmcgdG8gdW5rbm93biBiZWNhdXNlIHdlIGRvbid0IGtub3cgdGhlIHR5cGUgb2YgdGhlIG1ldGhvZCBpbml0aWFsbHkgYXQgYWxsXG4gIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdIDtcblxuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50RmFjdG9yeShvcmlnaW5hbCkgO1xuXG4gIC8vIE1ha2Ugc3VyZSBpdCdzIGEgZnVuY3Rpb24gZmlyc3QsIGFzIHdlIG5lZWQgdG8gYXR0YWNoIGFuIGVtcHR5IHByb3RvdHlwZSBmb3IgYGRlZmluZVByb3BlcnRpZXNgIHRvIHdvcmtcbiAgLy8gb3RoZXJ3aXNlIGl0J2xsIHRocm93IFwiVHlwZUVycm9yOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyBjYWxsZWQgb24gbm9uLW9iamVjdFwiXG4gIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcmtGdW5jdGlvbldyYXBwZWQod3JhcHBlZCwgb3JpZ2luYWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICB9IGNhdGNoIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nKGBGYWlsZWQgdG8gcmVwbGFjZSBtZXRob2QgXCIke25hbWV9XCIgaW4gb2JqZWN0YCwgc291cmNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgc2V0XG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSwgLy8gdGhlIGRlZmF1bHQsIHNvIHdlIGNhbiBzYXZlIG9uIGJ1bmRsZSBzaXplIGJ5IG5vdCBleHBsaWNpdGx5IHNldHRpbmcgaXRcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICB9IGNhdGNoIChvX08pIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nKGBGYWlsZWQgdG8gYWRkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IFwiJHtuYW1lfVwiIHRvIG9iamVjdGAsIG9iaik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1lbWJlcnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGFuZFxuICogcGF0Y2hlcyB1cCB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIHRoZSB3cmFwcGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb3JpZ2luYWwgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHRoYXQgZ2V0cyB3cmFwcGVkXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbldyYXBwZWQod3JhcHBlZCwgb3JpZ2luYWwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm90byA9IG9yaWdpbmFsLnByb3RvdHlwZSB8fCB7fTtcbiAgICB3cmFwcGVkLnByb3RvdHlwZSA9IG9yaWdpbmFsLnByb3RvdHlwZSA9IHByb3RvO1xuICAgIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSh3cmFwcGVkLCAnX19zZW50cnlfb3JpZ2luYWxfXycsIG9yaWdpbmFsKTtcbiAgfSBjYXRjaCAob19PKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG59XG5cbi8qKlxuICogVGhpcyBleHRyYWN0cyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaWYgYXZhaWxhYmxlLiAgU2VlXG4gKiBgbWFya0Z1bmN0aW9uV3JhcHBlZGAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIGZ1bmMgdGhlIGZ1bmN0aW9uIHRvIHVud3JhcFxuICogQHJldHVybnMgdGhlIHVud3JhcHBlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiBpZiBhdmFpbGFibGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBnZXRPcmlnaW5hbEZ1bmN0aW9uKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMuX19zZW50cnlfb3JpZ2luYWxfXztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFueSBgRXJyb3JgIG9yIGBFdmVudGAgaW50byBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBvZiB0aGVpciBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGFuZCBzb21lIG9mIHRoZWlyXG4gKiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBJbml0aWFsIHNvdXJjZSB0aGF0IHdlIGhhdmUgdG8gdHJhbnNmb3JtIGluIG9yZGVyIGZvciBpdCB0byBiZSB1c2FibGUgYnkgdGhlIHNlcmlhbGl6ZXJcbiAqIEByZXR1cm5zIEFuIEV2ZW50IG9yIEVycm9yIHR1cm5lZCBpbnRvIGFuIG9iamVjdCAtIG9yIHRoZSB2YWx1ZSBhcmd1bWVudCBpdHNlbGYsIHdoZW4gdmFsdWUgaXMgbmVpdGhlciBhbiBFdmVudCBub3JcbiAqICBhbiBFcnJvci5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvUGxhaW5PYmplY3QodmFsdWUpXG5cbiB7XG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLFxuICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgIC4uLmdldE93blByb3BlcnRpZXModmFsdWUpLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNFdmVudCh2YWx1ZSkpIHtcbiAgICBjb25zdCBuZXdPYmpcblxuID0ge1xuICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUudGFyZ2V0KSxcbiAgICAgIGN1cnJlbnRUYXJnZXQ6IHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHZhbHVlLmN1cnJlbnRUYXJnZXQpLFxuICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSksXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGlzSW5zdGFuY2VPZih2YWx1ZSwgQ3VzdG9tRXZlbnQpKSB7XG4gICAgICBuZXdPYmouZGV0YWlsID0gdmFsdWUuZGV0YWlsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmo7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YXJnZXQgb2YgYW4gYEV2ZW50YCBvYmplY3QgKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHRhcmdldCkge1xuICB0cnkge1xuICAgIHJldHVybiBpc0VsZW1lbnQodGFyZ2V0KSA/IGh0bWxUcmVlQXNTdHJpbmcodGFyZ2V0KSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpO1xuICB9IGNhdGNoIChfb08pIHtcbiAgICByZXR1cm4gJzx1bmtub3duPic7XG4gIH1cbn1cblxuLyoqIEZpbHRlcnMgb3V0IGFsbCBidXQgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgKi9cbmZ1bmN0aW9uIGdldE93blByb3BlcnRpZXMob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBjb25zdCBleHRyYWN0ZWRQcm9wcyA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHkpKSB7XG4gICAgICAgIGV4dHJhY3RlZFByb3BzW3Byb3BlcnR5XSA9IChvYmogKVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0ZWRQcm9wcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgY2FwdHVyZWQgZXhjZXB0aW9uLCBleHRyYWN0IGl0cyBrZXlzIGFuZCBjcmVhdGUgYSBzb3J0ZWRcbiAqIGFuZCB0cnVuY2F0ZWQgbGlzdCB0aGF0IHdpbGwgYmUgdXNlZCBpbnNpZGUgdGhlIGV2ZW50IG1lc3NhZ2UuXG4gKiBlZy4gYE5vbi1lcnJvciBleGNlcHRpb24gY2FwdHVyZWQgd2l0aCBrZXlzOiBmb28sIGJhciwgYmF6YFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UoZXhjZXB0aW9uLCBtYXhMZW5ndGggPSA0MCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29udmVydFRvUGxhaW5PYmplY3QoZXhjZXB0aW9uKSk7XG4gIGtleXMuc29ydCgpO1xuXG4gIGNvbnN0IGZpcnN0S2V5ID0ga2V5c1swXTtcblxuICBpZiAoIWZpcnN0S2V5KSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IGhhcyBubyBrZXlzXSc7XG4gIH1cblxuICBpZiAoZmlyc3RLZXkubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHJldHVybiB0cnVuY2F0ZShmaXJzdEtleSwgbWF4TGVuZ3RoKTtcbiAgfVxuXG4gIGZvciAobGV0IGluY2x1ZGVkS2V5cyA9IGtleXMubGVuZ3RoOyBpbmNsdWRlZEtleXMgPiAwOyBpbmNsdWRlZEtleXMtLSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBrZXlzLnNsaWNlKDAsIGluY2x1ZGVkS2V5cykuam9pbignLCAnKTtcbiAgICBpZiAoc2VyaWFsaXplZC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZWRLZXlzID09PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVuY2F0ZShzZXJpYWxpemVkLCBtYXhMZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBvYmplY3QsIHJldHVybiBhIG5ldyBvYmplY3QgaGF2aW5nIHJlbW92ZWQgYWxsIGZpZWxkcyB3aG9zZSB2YWx1ZSB3YXMgYHVuZGVmaW5lZGAuXG4gKiBXb3JrcyByZWN1cnNpdmVseSBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKlxuICogQXR0ZW50aW9uOiBUaGlzIGZ1bmN0aW9uIGtlZXBzIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIHJldHVybmVkIG9iamVjdC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGlzIG5vIGxvbmdlciB1c2VkIGJ5IHRoZSBTREsgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBkcm9wVW5kZWZpbmVkS2V5cyhpbnB1dFZhbHVlKSB7XG4gIC8vIFRoaXMgbWFwIGtlZXBzIHRyYWNrIG9mIHdoYXQgYWxyZWFkeSB2aXNpdGVkIG5vZGVzIG1hcCB0by5cbiAgLy8gT3VyIFNldCAtIGJhc2VkIG1lbW9CdWlsZGVyIGRvZXNuJ3Qgd29yayBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byB0aGUgb3V0cHV0IG9iamVjdCB0byBoYXZlIHRoZSBzYW1lIGNpcmN1bGFyXG4gIC8vIHJlZmVyZW5jZXMgYXMgdGhlIGlucHV0IG9iamVjdC5cbiAgY29uc3QgbWVtb2l6YXRpb25NYXAgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBqdXN0IHByb3hpZXMgYF9kcm9wVW5kZWZpbmVkS2V5c2AgdG8ga2VlcCB0aGUgYG1lbW9CdWlsZGVyYCBvdXQgb2YgdGhpcyBmdW5jdGlvbidzIEFQSVxuICByZXR1cm4gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUsIG1lbW9pemF0aW9uTWFwKTtcbn1cblxuZnVuY3Rpb24gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUsIG1lbW9pemF0aW9uTWFwKSB7XG4gIC8vIEVhcmx5IHJldHVybiBmb3IgcHJpbWl0aXZlIHZhbHVlc1xuICBpZiAoaW5wdXRWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXRWYWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgfVxuXG4gIC8vIENoZWNrIG1lbW8gbWFwIGZpcnN0IGZvciBhbGwgb2JqZWN0IHR5cGVzXG4gIGNvbnN0IG1lbW9WYWwgPSBtZW1vaXphdGlvbk1hcC5nZXQoaW5wdXRWYWx1ZSk7XG4gIGlmIChtZW1vVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbWVtb1ZhbCA7XG4gIH1cblxuICAvLyBoYW5kbGUgYXJyYXlzXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBbXTtcbiAgICAvLyBTdG9yZSBtYXBwaW5nIHRvIGhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgbWVtb2l6YXRpb25NYXAuc2V0KGlucHV0VmFsdWUsIHJldHVyblZhbHVlKTtcblxuICAgIGlucHV0VmFsdWUuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICByZXR1cm5WYWx1ZS5wdXNoKF9kcm9wVW5kZWZpbmVkS2V5cyh2YWx1ZSwgbWVtb2l6YXRpb25NYXApKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZSA7XG4gIH1cblxuICBpZiAoaXNQb2pvKGlucHV0VmFsdWUpKSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSB7fTtcbiAgICAvLyBTdG9yZSBtYXBwaW5nIHRvIGhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgbWVtb2l6YXRpb25NYXAuc2V0KGlucHV0VmFsdWUsIHJldHVyblZhbHVlKTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFZhbHVlKTtcblxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gaW5wdXRWYWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBfZHJvcFVuZGVmaW5lZEtleXModmFsLCBtZW1vaXphdGlvbk1hcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWUgO1xuICB9XG5cbiAgLy8gRm9yIG90aGVyIG9iamVjdCB0eXBlcywgcmV0dXJuIGFzIGlzXG4gIHJldHVybiBpbnB1dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1Bvam8oaW5wdXQpIHtcbiAgLy8gUGxhaW4gb2JqZWN0cyBoYXZlIE9iamVjdCBhcyBjb25zdHJ1Y3RvciBvciBubyBjb25zdHJ1Y3RvclxuICBjb25zdCBjb25zdHJ1Y3RvciA9IChpbnB1dCApLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBjb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogVHVybnMgYHVuZGVmaW5lZGAgYW5kIGBudWxsYCBpbnRvIGBTdHJpbmdgcyBhbmQgYWxsIG90aGVyIHByaW1pdGl2ZXMgaW50byBpbnN0YW5jZXMgb2YgdGhlaXIgcmVzcGVjdGl2ZSB3cmFwcGVyXG4gKiBjbGFzc2VzIChTdHJpbmcsIEJvb2xlYW4sIE51bWJlciwgZXRjLikuIEFjdHMgYXMgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIG9uIG5vbi1wcmltaXRpdmVzLlxuICpcbiAqIEBwYXJhbSB3YXQgVGhlIHN1YmplY3Qgb2YgdGhlIG9iamVjdGlmaWNhdGlvblxuICogQHJldHVybnMgQSB2ZXJzaW9uIG9mIGB3YXRgIHdoaWNoIGNhbiBzYWZlbHkgYmUgdXNlZCB3aXRoIGBPYmplY3RgIGNsYXNzIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gb2JqZWN0aWZ5KHdhdCkge1xuICBsZXQgb2JqZWN0aWZpZWQ7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIC8vIHRoaXMgd2lsbCBjYXRjaCBib3RoIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgIGNhc2Ugd2F0ID09IHVuZGVmaW5lZDpcbiAgICAgIG9iamVjdGlmaWVkID0gbmV3IFN0cmluZyh3YXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBUaG91Z2ggc3ltYm9scyBhbmQgYmlnaW50cyBkbyBoYXZlIHdyYXBwZXIgY2xhc3NlcyAoYFN5bWJvbGAgYW5kIGBCaWdJbnRgLCByZXNwZWN0aXZlbHkpLCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgLy8gdGhvc2UgY2xhc3NlcyBkb24ndCBoYXZlIGNvbnN0cnVjdG9ycyB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLiBXZSB0aGVyZWZvcmUgbmVlZCB0byBjYXN0IGVhY2ggYXNcbiAgICAvLyBhbiBvYmplY3QgaW4gb3JkZXIgdG8gd3JhcCBpdC5cbiAgICBjYXNlIHR5cGVvZiB3YXQgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB3YXQgPT09ICdiaWdpbnQnOlxuICAgICAgb2JqZWN0aWZpZWQgPSBPYmplY3Qod2F0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gdGhpcyB3aWxsIGNhdGNoIHRoZSByZW1haW5pbmcgcHJpbWl0aXZlczogYFN0cmluZ2AsIGBOdW1iZXJgLCBhbmQgYEJvb2xlYW5gXG4gICAgY2FzZSBpc1ByaW1pdGl2ZSh3YXQpOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgb2JqZWN0aWZpZWQgPSBuZXcgKHdhdCApLmNvbnN0cnVjdG9yKHdhdCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIGJ5IHByb2Nlc3Mgb2YgZWxpbWluYXRpb24sIGF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGF0IGB3YXRgIG11c3QgYWxyZWFkeSBiZSBhbiBvYmplY3RcbiAgICBkZWZhdWx0OlxuICAgICAgb2JqZWN0aWZpZWQgPSB3YXQ7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gb2JqZWN0aWZpZWQ7XG59XG5cbmV4cG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSwgY29udmVydFRvUGxhaW5PYmplY3QsIGRyb3BVbmRlZmluZWRLZXlzLCBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UsIGZpbGwsIGdldE9yaWdpbmFsRnVuY3Rpb24sIG1hcmtGdW5jdGlvbldyYXBwZWQsIG9iamVjdGlmeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSpanId: function() { return /* binding */ generateSpanId; },\n/* harmony export */   generateTraceId: function() { return /* binding */ generateTraceId; }\n/* harmony export */ });\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./misc.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n\n\n/**\n * Generate a random, valid trace ID.\n */\nfunction generateTraceId() {\n  return (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.uuid4)();\n}\n\n/**\n * Generate a random, valid span ID.\n */\nfunction generateSpanId() {\n  return (0,_misc_js__WEBPACK_IMPORTED_MODULE_0__.uuid4)().substring(16);\n}\n\n\n//# sourceMappingURL=propagationContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQUs7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQUs7QUFDZDs7QUFFMkM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcz83M2Y4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHV1aWQ0IH0gZnJvbSAnLi9taXNjLmpzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSwgdmFsaWQgdHJhY2UgSUQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVHJhY2VJZCgpIHtcbiAgcmV0dXJuIHV1aWQ0KCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20sIHZhbGlkIHNwYW4gSUQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU3BhbklkKCkge1xuICByZXR1cm4gdXVpZDQoKS5zdWJzdHJpbmcoMTYpO1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVNwYW5JZCwgZ2VuZXJhdGVUcmFjZUlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wYWdhdGlvbkNvbnRleHQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js":
/*!************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNKNOWN_FUNCTION: function() { return /* binding */ UNKNOWN_FUNCTION; },\n/* harmony export */   createStackParser: function() { return /* binding */ createStackParser; },\n/* harmony export */   getFramesFromEvent: function() { return /* binding */ getFramesFromEvent; },\n/* harmony export */   getFunctionName: function() { return /* binding */ getFunctionName; },\n/* harmony export */   stackParserFromStackParserOptions: function() { return /* binding */ stackParserFromStackParserOptions; },\n/* harmony export */   stripSentryFramesAndReverse: function() { return /* binding */ stripSentryFramesAndReverse; }\n/* harmony export */ });\nconst STACKTRACE_FRAME_LIMIT = 50;\nconst UNKNOWN_FUNCTION = '?';\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirstLines = 0, framesToPop = 0) => {\n    const frames = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      const line = lines[i] ;\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames.slice(framesToPop));\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = Array.from(stack);\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n\n    // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n    // is produced within the scope itself, making it:\n    //\n    //   Sentry.captureException()\n    //   scope.captureException()\n    //\n    // instead of just the top `Sentry` call itself.\n    // This forces us to possibly strip an additional frame in the exact same was as above.\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n      localStack.pop();\n    }\n  }\n\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION,\n  }));\n}\n\nfunction getLastStackFrame(arr) {\n  return arr[arr.length - 1] || {};\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Get's stack frames from an event without needing to check for undefined properties.\n */\nfunction getFramesFromEvent(event) {\n  const exception = event.exception;\n\n  if (exception) {\n    const frames = [];\n    try {\n      // @ts-expect-error Object could be undefined\n      exception.values.forEach(value => {\n        // @ts-expect-error Value could be undefined\n        if (value.stacktrace.frames) {\n          // @ts-expect-error Value could be undefined\n          frames.push(...value.stacktrace.frames);\n        }\n      });\n      return frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\n\n//# sourceMappingURL=stacktrace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zdGFja3RyYWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9KO0FBQ3BKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zdGFja3RyYWNlLmpzP2YzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCA9IDUwO1xuY29uc3QgVU5LTk9XTl9GVU5DVElPTiA9ICc/Jztcbi8vIFVzZWQgdG8gc2FuaXRpemUgd2VicGFjayAoZXJyb3I6ICopIHdyYXBwZWQgc3RhY2sgZXJyb3JzXG5jb25zdCBXRUJQQUNLX0VSUk9SX1JFR0VYUCA9IC9cXChlcnJvcjogKC4qKVxcKS87XG5jb25zdCBTVFJJUF9GUkFNRV9SRUdFWFAgPSAvY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIHBhcnNlciB3aXRoIHRoZSBzdXBwbGllZCBsaW5lIHBhcnNlcnNcbiAqXG4gKiBTdGFja0ZyYW1lcyBhcmUgcmV0dXJuZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgZm9yIFNlbnRyeSBFeGNlcHRpb25cbiAqIGZyYW1lcyBhbmQgd2l0aCBTZW50cnkgU0RLIGludGVybmFsIGZyYW1lcyByZW1vdmVkIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGFja1BhcnNlciguLi5wYXJzZXJzKSB7XG4gIGNvbnN0IHNvcnRlZFBhcnNlcnMgPSBwYXJzZXJzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKS5tYXAocCA9PiBwWzFdKTtcblxuICByZXR1cm4gKHN0YWNrLCBza2lwRmlyc3RMaW5lcyA9IDAsIGZyYW1lc1RvUG9wID0gMCkgPT4ge1xuICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgZm9yIChsZXQgaSA9IHNraXBGaXJzdExpbmVzOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXSA7XG4gICAgICAvLyBJZ25vcmUgbGluZXMgb3ZlciAxa2IgYXMgdGhleSBhcmUgdW5saWtlbHkgdG8gYmUgc3RhY2sgZnJhbWVzLlxuICAgICAgLy8gTWFueSBvZiB0aGUgcmVndWxhciBleHByZXNzaW9ucyB1c2UgYmFja3RyYWNraW5nIHdoaWNoIHJlc3VsdHMgaW4gcnVuIHRpbWUgdGhhdCBpbmNyZWFzZXMgZXhwb25lbnRpYWxseSB3aXRoXG4gICAgICAvLyBpbnB1dCBzaXplLiBIdWdlIHN0cmluZ3MgY2FuIHJlc3VsdCBpbiBoYW5ncy9EZW5pYWwgb2YgU2VydmljZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzIyODZcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzU0NTlcbiAgICAgIC8vIFJlbW92ZSB3ZWJwYWNrIChlcnJvcjogKikgd3JhcHBlcnNcbiAgICAgIGNvbnN0IGNsZWFuZWRMaW5lID0gV0VCUEFDS19FUlJPUl9SRUdFWFAudGVzdChsaW5lKSA/IGxpbmUucmVwbGFjZShXRUJQQUNLX0VSUk9SX1JFR0VYUCwgJyQxJykgOiBsaW5lO1xuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy83ODEzXG4gICAgICAvLyBTa2lwIEVycm9yOiBsaW5lc1xuICAgICAgaWYgKGNsZWFuZWRMaW5lLm1hdGNoKC9cXFMqRXJyb3I6IC8pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHBhcnNlciBvZiBzb3J0ZWRQYXJzZXJzKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gcGFyc2VyKGNsZWFuZWRMaW5lKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lcy5sZW5ndGggPj0gU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCArIGZyYW1lc1RvUG9wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2UoZnJhbWVzLnNsaWNlKGZyYW1lc1RvUG9wKSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyBhIHN0YWNrIHBhcnNlciBpbXBsZW1lbnRhdGlvbiBmcm9tIE9wdGlvbnMuc3RhY2tQYXJzZXJcbiAqIEBzZWUgT3B0aW9uc1xuICpcbiAqIElmIG9wdGlvbnMgY29udGFpbnMgYW4gYXJyYXkgb2YgbGluZSBwYXJzZXJzLCBpdCBpcyBjb252ZXJ0ZWQgaW50byBhIHBhcnNlclxuICovXG5mdW5jdGlvbiBzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMoc3RhY2tQYXJzZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhY2tQYXJzZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0YWNrUGFyc2VyKC4uLnN0YWNrUGFyc2VyKTtcbiAgfVxuICByZXR1cm4gc3RhY2tQYXJzZXI7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBTZW50cnkgZnJhbWVzIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBzdGFjayBpZiBwcmVzZW50IGFuZCBlbmZvcmNlcyBhIGxpbWl0IG9mIG1heCBudW1iZXIgb2YgZnJhbWVzLlxuICogQXNzdW1lcyBzdGFjayBpbnB1dCBpcyBvcmRlcmVkIGZyb20gdG9wIHRvIGJvdHRvbSBhbmQgcmV0dXJucyB0aGUgcmV2ZXJzZSByZXByZXNlbnRhdGlvbiBzbyBjYWxsIHNpdGUgb2YgdGhlXG4gKiBmdW5jdGlvbiB0aGF0IGNhdXNlZCB0aGUgY3Jhc2ggaXMgdGhlIGxhc3QgZnJhbWUgaW4gdGhlIGFycmF5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2Uoc3RhY2spIHtcbiAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb2NhbFN0YWNrID0gQXJyYXkuZnJvbShzdGFjayk7XG5cbiAgLy8gSWYgc3RhY2sgc3RhcnRzIHdpdGggb25lIG9mIG91ciBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoc3RhcnRzLCBtZWFuaW5nIGl0J3MgdGhlIHRvcCBvZiB0aGUgc3RhY2sgLSBha2EgbGFzdCBjYWxsKVxuICBpZiAoL3NlbnRyeVdyYXBwZWQvLnRlc3QoZ2V0TGFzdFN0YWNrRnJhbWUobG9jYWxTdGFjaykuZnVuY3Rpb24gfHwgJycpKSB7XG4gICAgbG9jYWxTdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIFJldmVyc2luZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9jZWR1cmUgYWxsb3dzIHVzIHRvIGp1c3QgcG9wIHRoZSB2YWx1ZXMgb2ZmIHRoZSBzdGFja1xuICBsb2NhbFN0YWNrLnJldmVyc2UoKTtcblxuICAvLyBJZiBzdGFjayBlbmRzIHdpdGggb25lIG9mIG91ciBpbnRlcm5hbCBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoZW5kcywgbWVhbmluZyBpdCdzIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIC0gYWthIHRvcC1tb3N0IGNhbGwpXG4gIGlmIChTVFJJUF9GUkFNRV9SRUdFWFAudGVzdChnZXRMYXN0U3RhY2tGcmFtZShsb2NhbFN0YWNrKS5mdW5jdGlvbiB8fCAnJykpIHtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBzeW50aGV0aWMgZXZlbnRzLCB3ZSB3aWxsIGhhdmUgYSAyIGxldmVscyBkZWVwIHN0YWNrLCBhcyBgbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJylgXG4gICAgLy8gaXMgcHJvZHVjZWQgd2l0aGluIHRoZSBzY29wZSBpdHNlbGYsIG1ha2luZyBpdDpcbiAgICAvL1xuICAgIC8vICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oKVxuICAgIC8vICAgc2NvcGUuY2FwdHVyZUV4Y2VwdGlvbigpXG4gICAgLy9cbiAgICAvLyBpbnN0ZWFkIG9mIGp1c3QgdGhlIHRvcCBgU2VudHJ5YCBjYWxsIGl0c2VsZi5cbiAgICAvLyBUaGlzIGZvcmNlcyB1cyB0byBwb3NzaWJseSBzdHJpcCBhbiBhZGRpdGlvbmFsIGZyYW1lIGluIHRoZSBleGFjdCBzYW1lIHdhcyBhcyBhYm92ZS5cbiAgICBpZiAoU1RSSVBfRlJBTUVfUkVHRVhQLnRlc3QoZ2V0TGFzdFN0YWNrRnJhbWUobG9jYWxTdGFjaykuZnVuY3Rpb24gfHwgJycpKSB7XG4gICAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0YWNrLnNsaWNlKDAsIFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQpLm1hcChmcmFtZSA9PiAoe1xuICAgIC4uLmZyYW1lLFxuICAgIGZpbGVuYW1lOiBmcmFtZS5maWxlbmFtZSB8fCBnZXRMYXN0U3RhY2tGcmFtZShsb2NhbFN0YWNrKS5maWxlbmFtZSxcbiAgICBmdW5jdGlvbjogZnJhbWUuZnVuY3Rpb24gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0U3RhY2tGcmFtZShhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV0gfHwge307XG59XG5cbmNvbnN0IGRlZmF1bHRGdW5jdGlvbk5hbWUgPSAnPGFub255bW91cz4nO1xuXG4vKipcbiAqIFNhZmVseSBleHRyYWN0IGZ1bmN0aW9uIG5hbWUgZnJvbSBpdHNlbGZcbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb25OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZm4ubmFtZSB8fCBkZWZhdWx0RnVuY3Rpb25OYW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSnVzdCBhY2Nlc3NpbmcgY3VzdG9tIHByb3BzIGluIHNvbWUgU2VsZW5pdW0gZW52aXJvbm1lbnRzXG4gICAgLy8gY2FuIGNhdXNlIGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGV4Y2VwdGlvbiAoc2VlIHJhdmVuLWpzIzQ5NSkuXG4gICAgcmV0dXJuIGRlZmF1bHRGdW5jdGlvbk5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQncyBzdGFjayBmcmFtZXMgZnJvbSBhbiBldmVudCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRGcmFtZXNGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZXhjZXB0aW9uID0gZXZlbnQuZXhjZXB0aW9uO1xuXG4gIGlmIChleGNlcHRpb24pIHtcbiAgICBjb25zdCBmcmFtZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBPYmplY3QgY291bGQgYmUgdW5kZWZpbmVkXG4gICAgICBleGNlcHRpb24udmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFZhbHVlIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICBpZiAodmFsdWUuc3RhY2t0cmFjZS5mcmFtZXMpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFZhbHVlIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgIGZyYW1lcy5wdXNoKC4uLnZhbHVlLnN0YWNrdHJhY2UuZnJhbWVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnJhbWVzO1xuICAgIH0gY2F0Y2ggKF9vTykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgVU5LTk9XTl9GVU5DVElPTiwgY3JlYXRlU3RhY2tQYXJzZXIsIGdldEZyYW1lc0Zyb21FdmVudCwgZ2V0RnVuY3Rpb25OYW1lLCBzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMsIHN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2t0cmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/stacktrace.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/string.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isMatchingPattern: function() { return /* binding */ isMatchingPattern; },\n/* harmony export */   safeJoin: function() { return /* binding */ safeJoin; },\n/* harmony export */   snipLine: function() { return /* binding */ snipLine; },\n/* harmony export */   stringMatchesSomePattern: function() { return /* binding */ stringMatchesSomePattern; },\n/* harmony export */   truncate: function() { return /* binding */ truncate; }\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n      // console warnings. This happens when a Vue template is rendered with\n      // an undeclared variable, which we try to stringify, ultimately causing\n      // Vue to issue another warning which repeats indefinitely.\n      // see: https://github.com/getsentry/sentry-javascript/pull/8981\n      if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isVueViewModel)(value)) {\n        output.push('[VueViewModel]');\n      } else {\n        output.push(String(value));\n      }\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nfunction isMatchingPattern(\n  value,\n  pattern,\n  requireExactStringMatch = false,\n) {\n  if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) {\n    return false;\n  }\n\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(pattern)) {\n    return pattern.test(value);\n  }\n  if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nfunction stringMatchesSomePattern(\n  testString,\n  patterns = [],\n  requireExactStringMatch = false,\n) {\n  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n\n\n//# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNLEVBQUUsUUFBUTtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQWM7QUFDeEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQVE7QUFDZjtBQUNBOztBQUVBLE1BQU0sZ0RBQVE7QUFDZDtBQUNBO0FBQ0EsTUFBTSxnREFBUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRjtBQUNyRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzPzkwNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcsIGlzUmVnRXhwLCBpc1Z1ZVZpZXdNb2RlbCB9IGZyb20gJy4vaXMuanMnO1xuXG4vKipcbiAqIFRydW5jYXRlcyBnaXZlbiBzdHJpbmcgdG8gdGhlIG1heGltdW0gY2hhcmFjdGVycyBjb3VudFxuICpcbiAqIEBwYXJhbSBzdHIgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc2VyaWFsaXphYmxlIHZhbHVlc1xuICogQHBhcmFtIG1heCBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRydW5jYXRlZCBzdHJpbmcgKDAgPSB1bmxpbWl0ZWQpXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiB0cnVuY2F0ZShzdHIsIG1heCA9IDApIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IG1heCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gbWF4ID8gc3RyIDogYCR7c3RyLnNsaWNlKDAsIG1heCl9Li4uYDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IGB0cmltX2xpbmVgIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5L2Jsb2IvbWFzdGVyL3NyYy9zZW50cnkvbGFuZy9qYXZhc2NyaXB0L3Byb2Nlc3Nvci5weSNMNjdcbiAqXG4gKiBAcGFyYW0gc3RyIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNlcmlhbGl6YWJsZSB2YWx1ZXNcbiAqIEBwYXJhbSBtYXggTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0cnVuY2F0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiBzbmlwTGluZShsaW5lLCBjb2xubykge1xuICBsZXQgbmV3TGluZSA9IGxpbmU7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBuZXdMaW5lLmxlbmd0aDtcbiAgaWYgKGxpbmVMZW5ndGggPD0gMTUwKSB7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH1cbiAgaWYgKGNvbG5vID4gbGluZUxlbmd0aCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNvbG5vID0gbGluZUxlbmd0aDtcbiAgfVxuXG4gIGxldCBzdGFydCA9IE1hdGgubWF4KGNvbG5vIC0gNjAsIDApO1xuICBpZiAoc3RhcnQgPCA1KSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgbGV0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgMTQwLCBsaW5lTGVuZ3RoKTtcbiAgaWYgKGVuZCA+IGxpbmVMZW5ndGggLSA1KSB7XG4gICAgZW5kID0gbGluZUxlbmd0aDtcbiAgfVxuICBpZiAoZW5kID09PSBsaW5lTGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBNYXRoLm1heChlbmQgLSAxNDAsIDApO1xuICB9XG5cbiAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBuZXdMaW5lID0gYCd7c25pcH0gJHtuZXdMaW5lfWA7XG4gIH1cbiAgaWYgKGVuZCA8IGxpbmVMZW5ndGgpIHtcbiAgICBuZXdMaW5lICs9ICcge3NuaXB9JztcbiAgfVxuXG4gIHJldHVybiBuZXdMaW5lO1xufVxuXG4vKipcbiAqIEpvaW4gdmFsdWVzIGluIGFycmF5XG4gKiBAcGFyYW0gaW5wdXQgYXJyYXkgb2YgdmFsdWVzIHRvIGJlIGpvaW5lZCB0b2dldGhlclxuICogQHBhcmFtIGRlbGltaXRlciBzdHJpbmcgdG8gYmUgcGxhY2VkIGluLWJldHdlZW4gdmFsdWVzXG4gKiBAcmV0dXJucyBKb2luZWQgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNhZmVKb2luKGlucHV0LCBkZWxpbWl0ZXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRbaV07XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIGZpeCBhIFZ1ZTMtc3BlY2lmaWMgYnVnIHRoYXQgY2F1c2VzIGFuIGluZmluaXRlIGxvb3Agb2ZcbiAgICAgIC8vIGNvbnNvbGUgd2FybmluZ3MuIFRoaXMgaGFwcGVucyB3aGVuIGEgVnVlIHRlbXBsYXRlIGlzIHJlbmRlcmVkIHdpdGhcbiAgICAgIC8vIGFuIHVuZGVjbGFyZWQgdmFyaWFibGUsIHdoaWNoIHdlIHRyeSB0byBzdHJpbmdpZnksIHVsdGltYXRlbHkgY2F1c2luZ1xuICAgICAgLy8gVnVlIHRvIGlzc3VlIGFub3RoZXIgd2FybmluZyB3aGljaCByZXBlYXRzIGluZGVmaW5pdGVseS5cbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9wdWxsLzg5ODFcbiAgICAgIGlmIChpc1Z1ZVZpZXdNb2RlbCh2YWx1ZSkpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJ1tWdWVWaWV3TW9kZWxdJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvdXRwdXQucHVzaCgnW3ZhbHVlIGNhbm5vdCBiZSBzZXJpYWxpemVkXScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbihkZWxpbWl0ZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgbWF0Y2hlcyBhIHJlZ2V4IG9yIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIHRlc3RcbiAqIEBwYXJhbSBwYXR0ZXJuIEVpdGhlciBhIHJlZ2V4IG9yIGEgc3RyaW5nIGFnYWluc3Qgd2hpY2ggYHZhbHVlYCB3aWxsIGJlIG1hdGNoZWRcbiAqIEBwYXJhbSByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCBJZiB0cnVlLCBgdmFsdWVgIG11c3QgbWF0Y2ggYHBhdHRlcm5gIGV4YWN0bHkuIElmIGZhbHNlLCBgdmFsdWVgIHdpbGwgbWF0Y2hcbiAqIGBwYXR0ZXJuYCBpZiBpdCBjb250YWlucyBgcGF0dGVybmAuIE9ubHkgYXBwbGllcyB0byBzdHJpbmctdHlwZSBwYXR0ZXJucy5cbiAqL1xuZnVuY3Rpb24gaXNNYXRjaGluZ1BhdHRlcm4oXG4gIHZhbHVlLFxuICBwYXR0ZXJuLFxuICByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCA9IGZhbHNlLFxuKSB7XG4gIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdCh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoID8gdmFsdWUgPT09IHBhdHRlcm4gOiB2YWx1ZS5pbmNsdWRlcyhwYXR0ZXJuKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUZXN0IHRoZSBnaXZlbiBzdHJpbmcgYWdhaW5zdCBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZWdleGVzLiBCeSBkZWZhdWx0LCBzdHJpbmcgbWF0Y2hpbmcgaXMgZG9uZSBvbiBhXG4gKiBzdWJzdHJpbmctaW5jbHVzaW9uIGJhc2lzIHJhdGhlciB0aGFuIGEgc3RyaWN0IGVxdWFsaXR5IGJhc2lzXG4gKlxuICogQHBhcmFtIHRlc3RTdHJpbmcgVGhlIHN0cmluZyB0byB0ZXN0XG4gKiBAcGFyYW0gcGF0dGVybnMgVGhlIHBhdHRlcm5zIGFnYWluc3Qgd2hpY2ggdG8gdGVzdCB0aGUgc3RyaW5nXG4gKiBAcGFyYW0gcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggSWYgdHJ1ZSwgYHRlc3RTdHJpbmdgIG11c3QgbWF0Y2ggb25lIG9mIHRoZSBnaXZlbiBzdHJpbmcgcGF0dGVybnMgZXhhY3RseSBpbiBvcmRlciB0b1xuICogY291bnQuIElmIGZhbHNlLCBgdGVzdFN0cmluZ2Agd2lsbCBtYXRjaCBhIHN0cmluZyBwYXR0ZXJuIGlmIGl0IGNvbnRhaW5zIHRoYXQgcGF0dGVybi5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ01hdGNoZXNTb21lUGF0dGVybihcbiAgdGVzdFN0cmluZyxcbiAgcGF0dGVybnMgPSBbXSxcbiAgcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggPSBmYWxzZSxcbikge1xuICByZXR1cm4gcGF0dGVybnMuc29tZShwYXR0ZXJuID0+IGlzTWF0Y2hpbmdQYXR0ZXJuKHRlc3RTdHJpbmcsIHBhdHRlcm4sIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoKSk7XG59XG5cbmV4cG9ydCB7IGlzTWF0Y2hpbmdQYXR0ZXJuLCBzYWZlSm9pbiwgc25pcExpbmUsIHN0cmluZ01hdGNoZXNTb21lUGF0dGVybiwgdHJ1bmNhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SyncPromise: function() { return /* binding */ SyncPromise; },\n/* harmony export */   rejectedSyncPromise: function() { return /* binding */ rejectedSyncPromise; },\n/* harmony export */   resolvedSyncPromise: function() { return /* binding */ resolvedSyncPromise; }\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nvar States; (function (States) {\n  /** Pending */\n  const PENDING = 0; States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n  /** Resolved / OK */\n  const RESOLVED = 1; States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n  /** Rejected / Error */\n  const REJECTED = 2; States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n\n   constructor(executor) {\n    this._state = States.PENDING;\n    this._handlers = [];\n\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: \\_()_/\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n   _executeHandlers() {\n    if (this._state === States.PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === States.RESOLVED) {\n        handler[1](this._value );\n      }\n\n      if (this._state === States.REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n   _runExecutor(executor) {\n    const setResult = (state, value) => {\n      if (this._state !== States.PENDING) {\n        return;\n      }\n\n      if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(value)) {\n        void (value ).then(resolve, reject);\n        return;\n      }\n\n      this._state = state;\n      this._value = value;\n\n      this._executeHandlers();\n    };\n\n    const resolve = (value) => {\n      setResult(States.RESOLVED, value);\n    };\n\n    const reject = (reason) => {\n      setResult(States.REJECTED, reason);\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n\n\n//# sourceMappingURL=syncpromise.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zeW5jcHJvbWlzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFDOztBQUVyQzs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QixDQUFDLHdCQUF3Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxrREFBVTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7QUFDakUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzPzg0YWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4vaXMuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qKiBTeW5jUHJvbWlzZSBpbnRlcm5hbCBzdGF0ZXMgKi9cbnZhciBTdGF0ZXM7IChmdW5jdGlvbiAoU3RhdGVzKSB7XG4gIC8qKiBQZW5kaW5nICovXG4gIGNvbnN0IFBFTkRJTkcgPSAwOyBTdGF0ZXNbU3RhdGVzW1wiUEVORElOR1wiXSA9IFBFTkRJTkddID0gXCJQRU5ESU5HXCI7XG4gIC8qKiBSZXNvbHZlZCAvIE9LICovXG4gIGNvbnN0IFJFU09MVkVEID0gMTsgU3RhdGVzW1N0YXRlc1tcIlJFU09MVkVEXCJdID0gUkVTT0xWRURdID0gXCJSRVNPTFZFRFwiO1xuICAvKiogUmVqZWN0ZWQgLyBFcnJvciAqL1xuICBjb25zdCBSRUpFQ1RFRCA9IDI7IFN0YXRlc1tTdGF0ZXNbXCJSRUpFQ1RFRFwiXSA9IFJFSkVDVEVEXSA9IFwiUkVKRUNURURcIjtcbn0pKFN0YXRlcyB8fCAoU3RhdGVzID0ge30pKTtcblxuLy8gT3ZlcmxvYWRzIHNvIHdlIGNhbiBjYWxsIHJlc29sdmVkU3luY1Byb21pc2Ugd2l0aG91dCBhcmd1bWVudHMgYW5kIGdlbmVyaWMgYXJndW1lbnRcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVzb2x2ZWQgc3luYyBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoXG4gKiBAcmV0dXJucyB0aGUgcmVzb2x2ZWQgc3luYyBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVkU3luY1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlamVjdGVkIHN5bmMgcHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoXG4gKiBAcmV0dXJucyB0aGUgcmVqZWN0ZWQgc3luYyBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIHJlamVjdGVkU3luY1Byb21pc2UocmVhc29uKSB7XG4gIHJldHVybiBuZXcgU3luY1Byb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGVuYWJsZSBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIFByb21pc2UgYW5kIGZvbGxvd3MgaXQncyBpbnRlcmZhY2VcbiAqIGJ1dCBpcyBub3QgYXN5bmMgaW50ZXJuYWxseVxuICovXG5jbGFzcyBTeW5jUHJvbWlzZSB7XG5cbiAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZXMuUEVORElORztcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fcnVuRXhlY3V0b3IoZXhlY3V0b3IpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICB0aGVuKFxuICAgIG9uZnVsZmlsbGVkLFxuICAgIG9ucmVqZWN0ZWQsXG4gICkge1xuICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlcnMucHVzaChbXG4gICAgICAgIGZhbHNlLFxuICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgIGlmICghb25mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IMKvXFxfKOODhClfL8KvXG4gICAgICAgICAgICAvLyBUT0RPOiBGSVhNRVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShvbmZ1bGZpbGxlZChyZXN1bHQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgICBpZiAoIW9ucmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNvbHZlKG9ucmVqZWN0ZWQocmVhc29uKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX2V4ZWN1dGVIYW5kbGVycygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBjYXRjaChcbiAgICBvbnJlamVjdGVkLFxuICApIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZhbCA9PiB2YWwsIG9ucmVqZWN0ZWQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBmaW5hbGx5KG9uZmluYWxseSkge1xuICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHZhbDtcbiAgICAgIGxldCBpc1JlamVjdGVkO1xuXG4gICAgICByZXR1cm4gdGhpcy50aGVuKFxuICAgICAgICB2YWx1ZSA9PiB7XG4gICAgICAgICAgaXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICAgIGlmIChvbmZpbmFsbHkpIHtcbiAgICAgICAgICAgIG9uZmluYWxseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgICBpc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWwgPSByZWFzb247XG4gICAgICAgICAgaWYgKG9uZmluYWxseSkge1xuICAgICAgICAgICAgb25maW5hbGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUmVqZWN0ZWQpIHtcbiAgICAgICAgICByZWplY3QodmFsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKHZhbCApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogRXhjdXRlIHRoZSByZXNvbHZlL3JlamVjdCBoYW5kbGVycy4gKi9cbiAgIF9leGVjdXRlSGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBTdGF0ZXMuUEVORElORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlZEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMuc2xpY2UoKTtcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuXG4gICAgY2FjaGVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgIGlmIChoYW5kbGVyWzBdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTdGF0ZXMuUkVTT0xWRUQpIHtcbiAgICAgICAgaGFuZGxlclsxXSh0aGlzLl92YWx1ZSApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFN0YXRlcy5SRUpFQ1RFRCkge1xuICAgICAgICBoYW5kbGVyWzJdKHRoaXMuX3ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlclswXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICAvKiogUnVuIHRoZSBleGVjdXRvciBmb3IgdGhlIFN5bmNQcm9taXNlLiAqL1xuICAgX3J1bkV4ZWN1dG9yKGV4ZWN1dG9yKSB7XG4gICAgY29uc3Qgc2V0UmVzdWx0ID0gKHN0YXRlLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBTdGF0ZXMuUEVORElORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgICB2b2lkICh2YWx1ZSApLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgIHNldFJlc3VsdChTdGF0ZXMuUkVTT0xWRUQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgc2V0UmVzdWx0KFN0YXRlcy5SRUpFQ1RFRCwgcmVhc29uKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBTeW5jUHJvbWlzZSwgcmVqZWN0ZWRTeW5jUHJvbWlzZSwgcmVzb2x2ZWRTeW5jUHJvbWlzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3luY3Byb21pc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/syncpromise.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js":
/*!******************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/time.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserPerformanceTimeOrigin: function() { return /* binding */ browserPerformanceTimeOrigin; },\n/* harmony export */   dateTimestampInSeconds: function() { return /* binding */ dateTimestampInSeconds; },\n/* harmony export */   timestampInSeconds: function() { return /* binding */ timestampInSeconds; }\n/* harmony export */ });\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nfunction dateTimestampInSeconds() {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return dateTimestampInSeconds;\n  }\n\n  // Some browser and environments don't have a timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  const approxStartingTimeOrigin = Date.now() - performance.now();\n  const timeOrigin = performance.timeOrigin == undefined ? approxStartingTimeOrigin : performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nconst timestampInSeconds = createUnixTimestampInSecondsFunc();\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin;\n\n/**\n * Gets the time origin and the mode used to determine it.\n */\nfunction getBrowserTimeOrigin() {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return [undefined, 'none'];\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      return [performance.timeOrigin, 'timeOrigin'];\n    } else {\n      return [navigationStart, 'navigationStart'];\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  return [dateNow, 'dateNow'];\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nfunction browserPerformanceTimeOrigin() {\n  if (!cachedTimeOrigin) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n\n  return cachedTimeOrigin[0];\n}\n\n\n//# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC90aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7O0FBRTVDOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjLEVBQUUscURBQVU7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYyxFQUFFLHFEQUFVO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVvRjtBQUNwRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvdGltZS5qcz9kNjljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmNvbnN0IE9ORV9TRUNPTkRfSU5fTVMgPSAxMDAwO1xuXG4vKipcbiAqIEEgcGFydGlhbCBkZWZpbml0aW9uIG9mIHRoZSBbUGVyZm9ybWFuY2UgV2ViIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlfVxuICogZm9yIGFjY2Vzc2luZyBhIGhpZ2gtcmVzb2x1dGlvbiBtb25vdG9uaWMgY2xvY2suXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgdGltZXN0YW1wIGluIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2ggdXNpbmcgdGhlIERhdGUgQVBJLlxuICovXG5mdW5jdGlvbiBkYXRlVGltZXN0YW1wSW5TZWNvbmRzKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKSAvIE9ORV9TRUNPTkRfSU5fTVM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgUGVyZm9ybWFuY2UgQVBJIGJyb3dzZXIgaW1wbGVtZW50YXRpb24sIG9yIHVuZGVmaW5lZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3RcbiAqIHN1cHBvcnQgdGhlIEFQSS5cbiAqXG4gKiBXcmFwcGluZyB0aGUgbmF0aXZlIEFQSSB3b3JrcyBhcm91bmQgZGlmZmVyZW5jZXMgaW4gYmVoYXZpb3IgZnJvbSBkaWZmZXJlbnQgYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaXhUaW1lc3RhbXBJblNlY29uZHNGdW5jKCkge1xuICBjb25zdCB7IHBlcmZvcm1hbmNlIH0gPSBHTE9CQUxfT0JKIDtcbiAgaWYgKCFwZXJmb3JtYW5jZT8ubm93KSB7XG4gICAgcmV0dXJuIGRhdGVUaW1lc3RhbXBJblNlY29uZHM7XG4gIH1cblxuICAvLyBTb21lIGJyb3dzZXIgYW5kIGVudmlyb25tZW50cyBkb24ndCBoYXZlIGEgdGltZU9yaWdpbiwgc28gd2UgZmFsbGJhY2sgdG9cbiAgLy8gdXNpbmcgRGF0ZS5ub3coKSB0byBjb21wdXRlIHRoZSBzdGFydGluZyB0aW1lLlxuICBjb25zdCBhcHByb3hTdGFydGluZ1RpbWVPcmlnaW4gPSBEYXRlLm5vdygpIC0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IHRpbWVPcmlnaW4gPSBwZXJmb3JtYW5jZS50aW1lT3JpZ2luID09IHVuZGVmaW5lZCA/IGFwcHJveFN0YXJ0aW5nVGltZU9yaWdpbiA6IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XG5cbiAgLy8gcGVyZm9ybWFuY2Uubm93KCkgaXMgYSBtb25vdG9uaWMgY2xvY2ssIHdoaWNoIG1lYW5zIGl0IHN0YXJ0cyBhdCAwIHdoZW4gdGhlIHByb2Nlc3MgYmVnaW5zLiBUbyBnZXQgdGhlIGN1cnJlbnRcbiAgLy8gd2FsbCBjbG9jayB0aW1lIChhY3R1YWwgVU5JWCB0aW1lc3RhbXApLCB3ZSBuZWVkIHRvIGFkZCB0aGUgc3RhcnRpbmcgdGltZSBvcmlnaW4gYW5kIHRoZSBjdXJyZW50IHRpbWUgZWxhcHNlZC5cbiAgLy9cbiAgLy8gVE9ETzogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgbW9ub3RvbmljIGNsb2NrIHRoYXQgcG93ZXJzIHBlcmZvcm1hbmNlLm5vdygpIGRyaWZ0cyBmcm9tIHRoZVxuICAvLyB3YWxsIGNsb2NrIHRpbWUsIHdoaWNoIGNhdXNlcyB0aGUgcmV0dXJuZWQgdGltZXN0YW1wIHRvIGJlIGluYWNjdXJhdGUuIFdlIHNob3VsZCBpbnZlc3RpZ2F0ZSBob3cgdG8gZGV0ZWN0IGFuZFxuICAvLyBjb3JyZWN0IGZvciB0aGlzLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1OTBcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWRuL2NvbnRlbnQvaXNzdWVzLzQ3MTNcbiAgLy8gU2VlOiBodHRwczovL2Rldi50by9ub2Ftci93aGVuLWEtbWlsbGlzZWNvbmQtaXMtbm90LWEtbWlsbGlzZWNvbmQtM2g2XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmV0dXJuICh0aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCkpIC8gT05FX1NFQ09ORF9JTl9NUztcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdGltZXN0YW1wIGluIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2ggdXNpbmcgZWl0aGVyIHRoZSBQZXJmb3JtYW5jZSBvciBEYXRlIEFQSXMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIGF2YWlsYWJpbGl0eSBvZiB0aGUgUGVyZm9ybWFuY2UgQVBJLlxuICpcbiAqIEJVRzogTm90ZSB0aGF0IGJlY2F1c2Ugb2YgaG93IGJyb3dzZXJzIGltcGxlbWVudCB0aGUgUGVyZm9ybWFuY2UgQVBJLCB0aGUgY2xvY2sgbWlnaHQgc3RvcCB3aGVuIHRoZSBjb21wdXRlciBpc1xuICogYXNsZWVwLiBUaGlzIGNyZWF0ZXMgYSBza2V3IGJldHdlZW4gYGRhdGVUaW1lc3RhbXBJblNlY29uZHNgIGFuZCBgdGltZXN0YW1wSW5TZWNvbmRzYC4gVGhlXG4gKiBza2V3IGNhbiBncm93IHRvIGFyYml0cmFyeSBhbW91bnRzIGxpa2UgZGF5cywgd2Vla3Mgb3IgbW9udGhzLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1OTAuXG4gKi9cbmNvbnN0IHRpbWVzdGFtcEluU2Vjb25kcyA9IGNyZWF0ZVVuaXhUaW1lc3RhbXBJblNlY29uZHNGdW5jKCk7XG5cbi8qKlxuICogQ2FjaGVkIHJlc3VsdCBvZiBnZXRCcm93c2VyVGltZU9yaWdpbi5cbiAqL1xubGV0IGNhY2hlZFRpbWVPcmlnaW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZSBvcmlnaW4gYW5kIHRoZSBtb2RlIHVzZWQgdG8gZGV0ZXJtaW5lIGl0LlxuICovXG5mdW5jdGlvbiBnZXRCcm93c2VyVGltZU9yaWdpbigpIHtcbiAgLy8gVW5mb3J0dW5hdGVseSBicm93c2VycyBtYXkgcmVwb3J0IGFuIGluYWNjdXJhdGUgdGltZSBvcmlnaW4gZGF0YSwgdGhyb3VnaCBlaXRoZXIgcGVyZm9ybWFuY2UudGltZU9yaWdpbiBvclxuICAvLyBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0LCB3aGljaCByZXN1bHRzIGluIHBvb3IgcmVzdWx0cyBpbiBwZXJmb3JtYW5jZSBkYXRhLiBXZSBvbmx5IHRyZWF0IHRpbWUgb3JpZ2luXG4gIC8vIGRhdGEgYXMgcmVsaWFibGUgaWYgdGhleSBhcmUgd2l0aGluIGEgcmVhc29uYWJsZSB0aHJlc2hvbGQgb2YgdGhlIGN1cnJlbnQgdGltZS5cblxuICBjb25zdCB7IHBlcmZvcm1hbmNlIH0gPSBHTE9CQUxfT0JKIDtcbiAgaWYgKCFwZXJmb3JtYW5jZT8ubm93KSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsICdub25lJ107XG4gIH1cblxuICBjb25zdCB0aHJlc2hvbGQgPSAzNjAwICogMTAwMDtcbiAgY29uc3QgcGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgZGF0ZU5vdyA9IERhdGUubm93KCk7XG5cbiAgLy8gaWYgdGltZU9yaWdpbiBpc24ndCBhdmFpbGFibGUgc2V0IGRlbHRhIHRvIHRocmVzaG9sZCBzbyBpdCBpc24ndCB1c2VkXG4gIGNvbnN0IHRpbWVPcmlnaW5EZWx0YSA9IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW5cbiAgICA/IE1hdGguYWJzKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBwZXJmb3JtYW5jZU5vdyAtIGRhdGVOb3cpXG4gICAgOiB0aHJlc2hvbGQ7XG4gIGNvbnN0IHRpbWVPcmlnaW5Jc1JlbGlhYmxlID0gdGltZU9yaWdpbkRlbHRhIDwgdGhyZXNob2xkO1xuXG4gIC8vIFdoaWxlIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luLCBwZXJmb3JtYW5jZS50aW1lT3JpZ2luXG4gIC8vIGlzIG5vdCBhcyB3aWRlbHkgc3VwcG9ydGVkLiBOYW1lbHksIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gaXMgdW5kZWZpbmVkIGluIFNhZmFyaSBhcyBvZiB3cml0aW5nLlxuICAvLyBBbHNvIGFzIG9mIHdyaXRpbmcsIHBlcmZvcm1hbmNlLnRpbWluZyBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzIGluIG1haW5zdHJlYW0gYnJvd3NlcnMsIHNvIGl0IGlzIG5vdCBhbHdheXNcbiAgLy8gYSB2YWxpZCBmYWxsYmFjay4gSW4gdGhlIGFic2VuY2Ugb2YgYW4gaW5pdGlhbCB0aW1lIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLCBmYWxsYmFjayB0byB0aGUgY3VycmVudCB0aW1lIGZyb20gdGhlXG4gIC8vIERhdGUgQVBJLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2UudGltaW5nPy5uYXZpZ2F0aW9uU3RhcnQ7XG4gIGNvbnN0IGhhc05hdmlnYXRpb25TdGFydCA9IHR5cGVvZiBuYXZpZ2F0aW9uU3RhcnQgPT09ICdudW1iZXInO1xuICAvLyBpZiBuYXZpZ2F0aW9uU3RhcnQgaXNuJ3QgYXZhaWxhYmxlIHNldCBkZWx0YSB0byB0aHJlc2hvbGQgc28gaXQgaXNuJ3QgdXNlZFxuICBjb25zdCBuYXZpZ2F0aW9uU3RhcnREZWx0YSA9IGhhc05hdmlnYXRpb25TdGFydCA/IE1hdGguYWJzKG5hdmlnYXRpb25TdGFydCArIHBlcmZvcm1hbmNlTm93IC0gZGF0ZU5vdykgOiB0aHJlc2hvbGQ7XG4gIGNvbnN0IG5hdmlnYXRpb25TdGFydElzUmVsaWFibGUgPSBuYXZpZ2F0aW9uU3RhcnREZWx0YSA8IHRocmVzaG9sZDtcblxuICBpZiAodGltZU9yaWdpbklzUmVsaWFibGUgfHwgbmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSkge1xuICAgIC8vIFVzZSB0aGUgbW9yZSByZWxpYWJsZSB0aW1lIG9yaWdpblxuICAgIGlmICh0aW1lT3JpZ2luRGVsdGEgPD0gbmF2aWdhdGlvblN0YXJ0RGVsdGEpIHtcbiAgICAgIHJldHVybiBbcGVyZm9ybWFuY2UudGltZU9yaWdpbiwgJ3RpbWVPcmlnaW4nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtuYXZpZ2F0aW9uU3RhcnQsICduYXZpZ2F0aW9uU3RhcnQnXTtcbiAgICB9XG4gIH1cblxuICAvLyBFaXRoZXIgYm90aCB0aW1lT3JpZ2luIGFuZCBuYXZpZ2F0aW9uU3RhcnQgYXJlIHNrZXdlZCBvciBuZWl0aGVyIGlzIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gRGF0ZS5cbiAgcmV0dXJuIFtkYXRlTm93LCAnZGF0ZU5vdyddO1xufVxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLiBUaGlzIHZhbHVlIGlzIG9ubHkgdXNhYmxlIGluIGEgYnJvd3NlciwgYW5kIG9ubHkgd2hlbiB0aGVcbiAqIHBlcmZvcm1hbmNlIEFQSSBpcyBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4oKSB7XG4gIGlmICghY2FjaGVkVGltZU9yaWdpbikge1xuICAgIGNhY2hlZFRpbWVPcmlnaW4gPSBnZXRCcm93c2VyVGltZU9yaWdpbigpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlZFRpbWVPcmlnaW5bMF07XG59XG5cbmV4cG9ydCB7IGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4sIGRhdGVUaW1lc3RhbXBJblNlY29uZHMsIHRpbWVzdGFtcEluU2Vjb25kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/tracing.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/tracing.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACEPARENT_REGEXP: function() { return /* binding */ TRACEPARENT_REGEXP; },\n/* harmony export */   extractTraceparentData: function() { return /* binding */ extractTraceparentData; },\n/* harmony export */   generateSentryTraceHeader: function() { return /* binding */ generateSentryTraceHeader; },\n/* harmony export */   propagationContextFromHeaders: function() { return /* binding */ propagationContextFromHeaders; }\n/* harmony export */ });\n/* harmony import */ var _utils_parseSampleRate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/parseSampleRate.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js\");\n/* harmony import */ var _baggage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baggage.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/baggage.js\");\n/* harmony import */ var _propagationContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./propagationContext.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js\");\n\n\n\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  if (!traceparent) {\n    return undefined;\n  }\n\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n  if (!matches) {\n    return undefined;\n  }\n\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\n/**\n * Create a propagation context from incoming headers or\n * creates a minimal new one if the headers are undefined.\n */\nfunction propagationContextFromHeaders(\n  sentryTrace,\n  baggage,\n) {\n  const traceparentData = extractTraceparentData(sentryTrace);\n  const dynamicSamplingContext = (0,_baggage_js__WEBPACK_IMPORTED_MODULE_0__.baggageHeaderToDynamicSamplingContext)(baggage);\n\n  if (!traceparentData?.traceId) {\n    return {\n      traceId: (0,_propagationContext_js__WEBPACK_IMPORTED_MODULE_1__.generateTraceId)(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  const sampleRand = getSampleRandFromTraceparentAndDsc(traceparentData, dynamicSamplingContext);\n\n  // The sample_rand on the DSC needs to be generated based on traceparent + baggage.\n  if (dynamicSamplingContext) {\n    dynamicSamplingContext.sample_rand = sampleRand.toString();\n  }\n\n  const { traceId, parentSpanId, parentSampled } = traceparentData;\n\n  return {\n    traceId,\n    parentSpanId,\n    sampled: parentSampled,\n    dsc: dynamicSamplingContext || {}, // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n    sampleRand,\n  };\n}\n\n/**\n * Create sentry-trace header from span context values.\n */\nfunction generateSentryTraceHeader(\n  traceId = (0,_propagationContext_js__WEBPACK_IMPORTED_MODULE_1__.generateTraceId)(),\n  spanId = (0,_propagationContext_js__WEBPACK_IMPORTED_MODULE_1__.generateSpanId)(),\n  sampled,\n) {\n  let sampledString = '';\n  if (sampled !== undefined) {\n    sampledString = sampled ? '-1' : '-0';\n  }\n  return `${traceId}-${spanId}${sampledString}`;\n}\n\n/**\n * Given any combination of an incoming trace, generate a sample rand based on its defined semantics.\n *\n * Read more: https://develop.sentry.dev/sdk/telemetry/traces/#propagated-random-value\n */\nfunction getSampleRandFromTraceparentAndDsc(\n  traceparentData,\n  dsc,\n) {\n  // When there is an incoming sample rand use it.\n  const parsedSampleRand = (0,_utils_parseSampleRate_js__WEBPACK_IMPORTED_MODULE_2__.parseSampleRate)(dsc?.sample_rand);\n  if (parsedSampleRand !== undefined) {\n    return parsedSampleRand;\n  }\n\n  // Otherwise, if there is an incoming sampling decision + sample rate, generate a sample rand that would lead to the same sampling decision.\n  const parsedSampleRate = (0,_utils_parseSampleRate_js__WEBPACK_IMPORTED_MODULE_2__.parseSampleRate)(dsc?.sample_rate);\n  if (parsedSampleRate && traceparentData?.parentSampled !== undefined) {\n    return traceparentData.parentSampled\n      ? // Returns a sample rand with positive sampling decision [0, sampleRate)\n        Math.random() * parsedSampleRate\n      : // Returns a sample rand with negative sampling decision [sampleRate, 1)\n        parsedSampleRate + Math.random() * (1 - parsedSampleRate);\n  } else {\n    // If nothing applies, return a random sample rand.\n    return Math.random();\n  }\n}\n\n\n//# sourceMappingURL=tracing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC90cmFjaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEQ7QUFDTztBQUNLOztBQUUxRTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRkFBcUM7O0FBRXRFO0FBQ0E7QUFDQSxlQUFlLHVFQUFlO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHVDQUF1Qzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RUFBZTtBQUMzQixXQUFXLHNFQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxHQUFHLE9BQU8sRUFBRSxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBFQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwwRUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRWdIO0FBQ2hIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC90cmFjaW5nLmpzPzIyNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VTYW1wbGVSYXRlIH0gZnJvbSAnLi4vdXRpbHMvcGFyc2VTYW1wbGVSYXRlLmpzJztcbmltcG9ydCB7IGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQgfSBmcm9tICcuL2JhZ2dhZ2UuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUcmFjZUlkLCBnZW5lcmF0ZVNwYW5JZCB9IGZyb20gJy4vcHJvcGFnYXRpb25Db250ZXh0LmpzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzZW50cnktaW50ZXJuYWwvc2RrL25vLXJlZ2V4cC1jb25zdHJ1Y3RvciAtLSBSZWdFeHAgaXMgdXNlZCBmb3IgcmVhZGFiaWxpdHkgaGVyZVxuY29uc3QgVFJBQ0VQQVJFTlRfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ15bIFxcXFx0XSonICsgLy8gd2hpdGVzcGFjZVxuICAgICcoWzAtOWEtZl17MzJ9KT8nICsgLy8gdHJhY2VfaWRcbiAgICAnLT8oWzAtOWEtZl17MTZ9KT8nICsgLy8gc3Bhbl9pZFxuICAgICctPyhbMDFdKT8nICsgLy8gc2FtcGxlZFxuICAgICdbIFxcXFx0XSokJywgLy8gd2hpdGVzcGFjZVxuKTtcblxuLyoqXG4gKiBFeHRyYWN0IHRyYW5zYWN0aW9uIGNvbnRleHQgZGF0YSBmcm9tIGEgYHNlbnRyeS10cmFjZWAgaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB0cmFjZXBhcmVudCBUcmFjZXBhcmVudCBzdHJpbmdcbiAqXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBkYXRhIGZyb20gdGhlIGhlYWRlciwgb3IgdW5kZWZpbmVkIGlmIHRyYWNlcGFyZW50IHN0cmluZyBpcyBtYWxmb3JtZWRcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFRyYWNlcGFyZW50RGF0YSh0cmFjZXBhcmVudCkge1xuICBpZiAoIXRyYWNlcGFyZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSB0cmFjZXBhcmVudC5tYXRjaChUUkFDRVBBUkVOVF9SRUdFWFApO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IHBhcmVudFNhbXBsZWQ7XG4gIGlmIChtYXRjaGVzWzNdID09PSAnMScpIHtcbiAgICBwYXJlbnRTYW1wbGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtYXRjaGVzWzNdID09PSAnMCcpIHtcbiAgICBwYXJlbnRTYW1wbGVkID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRyYWNlSWQ6IG1hdGNoZXNbMV0sXG4gICAgcGFyZW50U2FtcGxlZCxcbiAgICBwYXJlbnRTcGFuSWQ6IG1hdGNoZXNbMl0sXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJvcGFnYXRpb24gY29udGV4dCBmcm9tIGluY29taW5nIGhlYWRlcnMgb3JcbiAqIGNyZWF0ZXMgYSBtaW5pbWFsIG5ldyBvbmUgaWYgdGhlIGhlYWRlcnMgYXJlIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gcHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoXG4gIHNlbnRyeVRyYWNlLFxuICBiYWdnYWdlLFxuKSB7XG4gIGNvbnN0IHRyYWNlcGFyZW50RGF0YSA9IGV4dHJhY3RUcmFjZXBhcmVudERhdGEoc2VudHJ5VHJhY2UpO1xuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChiYWdnYWdlKTtcblxuICBpZiAoIXRyYWNlcGFyZW50RGF0YT8udHJhY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFjZUlkOiBnZW5lcmF0ZVRyYWNlSWQoKSxcbiAgICAgIHNhbXBsZVJhbmQ6IE1hdGgucmFuZG9tKCksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHNhbXBsZVJhbmQgPSBnZXRTYW1wbGVSYW5kRnJvbVRyYWNlcGFyZW50QW5kRHNjKHRyYWNlcGFyZW50RGF0YSwgZHluYW1pY1NhbXBsaW5nQ29udGV4dCk7XG5cbiAgLy8gVGhlIHNhbXBsZV9yYW5kIG9uIHRoZSBEU0MgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkIGJhc2VkIG9uIHRyYWNlcGFyZW50ICsgYmFnZ2FnZS5cbiAgaWYgKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpIHtcbiAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LnNhbXBsZV9yYW5kID0gc2FtcGxlUmFuZC50b1N0cmluZygpO1xuICB9XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBwYXJlbnRTcGFuSWQsIHBhcmVudFNhbXBsZWQgfSA9IHRyYWNlcGFyZW50RGF0YTtcblxuICByZXR1cm4ge1xuICAgIHRyYWNlSWQsXG4gICAgcGFyZW50U3BhbklkLFxuICAgIHNhbXBsZWQ6IHBhcmVudFNhbXBsZWQsXG4gICAgZHNjOiBkeW5hbWljU2FtcGxpbmdDb250ZXh0IHx8IHt9LCAvLyBJZiB3ZSBoYXZlIHRyYWNlcGFyZW50IGRhdGEgYnV0IG5vIERTQyBpdCBtZWFucyB3ZSBhcmUgbm90IGhlYWQgb2YgdHJhY2UgYW5kIHdlIG11c3QgZnJlZXplIGl0XG4gICAgc2FtcGxlUmFuZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgc2VudHJ5LXRyYWNlIGhlYWRlciBmcm9tIHNwYW4gY29udGV4dCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIoXG4gIHRyYWNlSWQgPSBnZW5lcmF0ZVRyYWNlSWQoKSxcbiAgc3BhbklkID0gZ2VuZXJhdGVTcGFuSWQoKSxcbiAgc2FtcGxlZCxcbikge1xuICBsZXQgc2FtcGxlZFN0cmluZyA9ICcnO1xuICBpZiAoc2FtcGxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2FtcGxlZFN0cmluZyA9IHNhbXBsZWQgPyAnLTEnIDogJy0wJztcbiAgfVxuICByZXR1cm4gYCR7dHJhY2VJZH0tJHtzcGFuSWR9JHtzYW1wbGVkU3RyaW5nfWA7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IGNvbWJpbmF0aW9uIG9mIGFuIGluY29taW5nIHRyYWNlLCBnZW5lcmF0ZSBhIHNhbXBsZSByYW5kIGJhc2VkIG9uIGl0cyBkZWZpbmVkIHNlbWFudGljcy5cbiAqXG4gKiBSZWFkIG1vcmU6IGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay90ZWxlbWV0cnkvdHJhY2VzLyNwcm9wYWdhdGVkLXJhbmRvbS12YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRTYW1wbGVSYW5kRnJvbVRyYWNlcGFyZW50QW5kRHNjKFxuICB0cmFjZXBhcmVudERhdGEsXG4gIGRzYyxcbikge1xuICAvLyBXaGVuIHRoZXJlIGlzIGFuIGluY29taW5nIHNhbXBsZSByYW5kIHVzZSBpdC5cbiAgY29uc3QgcGFyc2VkU2FtcGxlUmFuZCA9IHBhcnNlU2FtcGxlUmF0ZShkc2M/LnNhbXBsZV9yYW5kKTtcbiAgaWYgKHBhcnNlZFNhbXBsZVJhbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwYXJzZWRTYW1wbGVSYW5kO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhbiBpbmNvbWluZyBzYW1wbGluZyBkZWNpc2lvbiArIHNhbXBsZSByYXRlLCBnZW5lcmF0ZSBhIHNhbXBsZSByYW5kIHRoYXQgd291bGQgbGVhZCB0byB0aGUgc2FtZSBzYW1wbGluZyBkZWNpc2lvbi5cbiAgY29uc3QgcGFyc2VkU2FtcGxlUmF0ZSA9IHBhcnNlU2FtcGxlUmF0ZShkc2M/LnNhbXBsZV9yYXRlKTtcbiAgaWYgKHBhcnNlZFNhbXBsZVJhdGUgJiYgdHJhY2VwYXJlbnREYXRhPy5wYXJlbnRTYW1wbGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJhY2VwYXJlbnREYXRhLnBhcmVudFNhbXBsZWRcbiAgICAgID8gLy8gUmV0dXJucyBhIHNhbXBsZSByYW5kIHdpdGggcG9zaXRpdmUgc2FtcGxpbmcgZGVjaXNpb24gWzAsIHNhbXBsZVJhdGUpXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiBwYXJzZWRTYW1wbGVSYXRlXG4gICAgICA6IC8vIFJldHVybnMgYSBzYW1wbGUgcmFuZCB3aXRoIG5lZ2F0aXZlIHNhbXBsaW5nIGRlY2lzaW9uIFtzYW1wbGVSYXRlLCAxKVxuICAgICAgICBwYXJzZWRTYW1wbGVSYXRlICsgTWF0aC5yYW5kb20oKSAqICgxIC0gcGFyc2VkU2FtcGxlUmF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbm90aGluZyBhcHBsaWVzLCByZXR1cm4gYSByYW5kb20gc2FtcGxlIHJhbmQuXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgVFJBQ0VQQVJFTlRfUkVHRVhQLCBleHRyYWN0VHJhY2VwYXJlbnREYXRhLCBnZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyLCBwcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2luZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/tracing.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/version.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/version.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SDK_VERSION: function() { return /* binding */ SDK_VERSION; }\n/* harmony export */ });\n// This is a magic string replaced by rollup\n\nconst SDK_VERSION = \"9.15.0\" ;\n\n\n//# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L3ZlcnNpb24uanM/NThjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGlzIGEgbWFnaWMgc3RyaW5nIHJlcGxhY2VkIGJ5IHJvbGx1cFxuXG5jb25zdCBTREtfVkVSU0lPTiA9IFwiOS4xNS4wXCIgO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLOBAL_OBJ: function() { return /* binding */ GLOBAL_OBJ; }\n/* harmony export */ });\n/** Internal global with common properties and Sentry extensions  */\n\n/** Get's the global object for the current JavaScript runtime */\nconst GLOBAL_OBJ = globalThis ;\n\n\n//# sourceMappingURL=worldwide.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC93b3JsZHdpZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBQ0E7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC93b3JsZHdpZGUuanM/NWY5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogSW50ZXJuYWwgZ2xvYmFsIHdpdGggY29tbW9uIHByb3BlcnRpZXMgYW5kIFNlbnRyeSBleHRlbnNpb25zICAqL1xuXG4vKiogR2V0J3MgdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgcnVudGltZSAqL1xuY29uc3QgR0xPQkFMX09CSiA9IGdsb2JhbFRoaXMgO1xuXG5leHBvcnQgeyBHTE9CQUxfT0JKIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JsZHdpZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyScopeDataToEvent: function() { return /* binding */ applyScopeDataToEvent; },\n/* harmony export */   mergeAndOverwriteScopeData: function() { return /* binding */ mergeAndOverwriteScopeData; },\n/* harmony export */   mergeScopeData: function() { return /* binding */ mergeScopeData; }\n/* harmony export */ });\n/* harmony import */ var _tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tracing/dynamicSamplingContext.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js\");\n/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./merge.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/merge.js\");\n/* harmony import */ var _spanUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spanUtils.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanUtils.js\");\n\n\n\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */\nfunction applyScopeDataToEvent(event, data) {\n  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n\n  // Apply general data\n  applyDataToEvent(event, data);\n\n  // We want to set the trace context for normal events only if there isn't already\n  // a trace context on the event. There is a product feature in place where we link\n  // errors with transaction and it relies on that.\n  if (span) {\n    applySpanToEvent(event, span);\n  }\n\n  applyFingerprintToEvent(event, fingerprint);\n  applyBreadcrumbsToEvent(event, breadcrumbs);\n  applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n\n/** Merge data of two scopes together. */\nfunction mergeScopeData(data, mergeData) {\n  const {\n    extra,\n    tags,\n    user,\n    contexts,\n    level,\n    sdkProcessingMetadata,\n    breadcrumbs,\n    fingerprint,\n    eventProcessors,\n    attachments,\n    propagationContext,\n    transactionName,\n    span,\n  } = mergeData;\n\n  mergeAndOverwriteScopeData(data, 'extra', extra);\n  mergeAndOverwriteScopeData(data, 'tags', tags);\n  mergeAndOverwriteScopeData(data, 'user', user);\n  mergeAndOverwriteScopeData(data, 'contexts', contexts);\n\n  data.sdkProcessingMetadata = (0,_merge_js__WEBPACK_IMPORTED_MODULE_0__.merge)(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);\n\n  if (level) {\n    data.level = level;\n  }\n\n  if (transactionName) {\n    data.transactionName = transactionName;\n  }\n\n  if (span) {\n    data.span = span;\n  }\n\n  if (breadcrumbs.length) {\n    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n  }\n\n  if (fingerprint.length) {\n    data.fingerprint = [...data.fingerprint, ...fingerprint];\n  }\n\n  if (eventProcessors.length) {\n    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n  }\n\n  if (attachments.length) {\n    data.attachments = [...data.attachments, ...attachments];\n  }\n\n  data.propagationContext = { ...data.propagationContext, ...propagationContext };\n}\n\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */\nfunction mergeAndOverwriteScopeData\n\n(data, prop, mergeVal) {\n  data[prop] = (0,_merge_js__WEBPACK_IMPORTED_MODULE_0__.merge)(data[prop], mergeVal, 1);\n}\n\nfunction applyDataToEvent(event, data) {\n  const { extra, tags, user, contexts, level, transactionName } = data;\n\n  if (Object.keys(extra).length) {\n    event.extra = { ...extra, ...event.extra };\n  }\n\n  if (Object.keys(tags).length) {\n    event.tags = { ...tags, ...event.tags };\n  }\n\n  if (Object.keys(user).length) {\n    event.user = { ...user, ...event.user };\n  }\n\n  if (Object.keys(contexts).length) {\n    event.contexts = { ...contexts, ...event.contexts };\n  }\n\n  if (level) {\n    event.level = level;\n  }\n\n  // transaction events get their `transaction` from the root span name\n  if (transactionName && event.type !== 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n  const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];\n  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\n\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n  event.sdkProcessingMetadata = {\n    ...event.sdkProcessingMetadata,\n    ...sdkProcessingMetadata,\n  };\n}\n\nfunction applySpanToEvent(event, span) {\n  event.contexts = {\n    trace: (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_1__.spanToTraceContext)(span),\n    ...event.contexts,\n  };\n\n  event.sdkProcessingMetadata = {\n    dynamicSamplingContext: (0,_tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_2__.getDynamicSamplingContextFromSpan)(span),\n    ...event.sdkProcessingMetadata,\n  };\n\n  const rootSpan = (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_1__.getRootSpan)(span);\n  const transactionName = (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_1__.spanToJSON)(rootSpan).description;\n  if (transactionName && !event.transaction && event.type === 'transaction') {\n    event.transaction = transactionName;\n  }\n}\n\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */\nfunction applyFingerprintToEvent(event, fingerprint) {\n  // Make sure it's an array first and we actually have something in place\n  event.fingerprint = event.fingerprint\n    ? Array.isArray(event.fingerprint)\n      ? event.fingerprint\n      : [event.fingerprint]\n    : [];\n\n  // If we have something on the scope, then merge it with event\n  if (fingerprint) {\n    event.fingerprint = event.fingerprint.concat(fingerprint);\n  }\n\n  // If we have no data at all, remove empty array default\n  if (!event.fingerprint.length) {\n    delete event.fingerprint;\n  }\n}\n\n\n//# sourceMappingURL=applyScopeDataToEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9hcHBseVNjb3BlRGF0YVRvRXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlGO0FBQ3REO0FBQzBDOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQXdEOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGdEQUFLOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGdEQUFLO0FBQ3BCOztBQUVBO0FBQ0EsVUFBVSxzREFBc0Q7O0FBRWhFO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpRUFBa0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixxR0FBaUM7QUFDN0Q7QUFDQTs7QUFFQSxtQkFBbUIsMERBQVc7QUFDOUIsMEJBQTBCLHlEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkU7QUFDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2FwcGx5U2NvcGVEYXRhVG9FdmVudC5qcz80NTQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiB9IGZyb20gJy4uL3RyYWNpbmcvZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJy4vbWVyZ2UuanMnO1xuaW1wb3J0IHsgc3BhblRvVHJhY2VDb250ZXh0LCBnZXRSb290U3Bhbiwgc3BhblRvSlNPTiB9IGZyb20gJy4vc3BhblV0aWxzLmpzJztcblxuLyoqXG4gKiBBcHBsaWVzIGRhdGEgZnJvbSB0aGUgc2NvcGUgdG8gdGhlIGV2ZW50IGFuZCBydW5zIGFsbCBldmVudCBwcm9jZXNzb3JzIG9uIGl0LlxuICovXG5mdW5jdGlvbiBhcHBseVNjb3BlRGF0YVRvRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgY29uc3QgeyBmaW5nZXJwcmludCwgc3BhbiwgYnJlYWRjcnVtYnMsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSB9ID0gZGF0YTtcblxuICAvLyBBcHBseSBnZW5lcmFsIGRhdGFcbiAgYXBwbHlEYXRhVG9FdmVudChldmVudCwgZGF0YSk7XG5cbiAgLy8gV2Ugd2FudCB0byBzZXQgdGhlIHRyYWNlIGNvbnRleHQgZm9yIG5vcm1hbCBldmVudHMgb25seSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5XG4gIC8vIGEgdHJhY2UgY29udGV4dCBvbiB0aGUgZXZlbnQuIFRoZXJlIGlzIGEgcHJvZHVjdCBmZWF0dXJlIGluIHBsYWNlIHdoZXJlIHdlIGxpbmtcbiAgLy8gZXJyb3JzIHdpdGggdHJhbnNhY3Rpb24gYW5kIGl0IHJlbGllcyBvbiB0aGF0LlxuICBpZiAoc3Bhbikge1xuICAgIGFwcGx5U3BhblRvRXZlbnQoZXZlbnQsIHNwYW4pO1xuICB9XG5cbiAgYXBwbHlGaW5nZXJwcmludFRvRXZlbnQoZXZlbnQsIGZpbmdlcnByaW50KTtcbiAgYXBwbHlCcmVhZGNydW1ic1RvRXZlbnQoZXZlbnQsIGJyZWFkY3J1bWJzKTtcbiAgYXBwbHlTZGtNZXRhZGF0YVRvRXZlbnQoZXZlbnQsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSk7XG59XG5cbi8qKiBNZXJnZSBkYXRhIG9mIHR3byBzY29wZXMgdG9nZXRoZXIuICovXG5mdW5jdGlvbiBtZXJnZVNjb3BlRGF0YShkYXRhLCBtZXJnZURhdGEpIHtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIHRhZ3MsXG4gICAgdXNlcixcbiAgICBjb250ZXh0cyxcbiAgICBsZXZlbCxcbiAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgYnJlYWRjcnVtYnMsXG4gICAgZmluZ2VycHJpbnQsXG4gICAgZXZlbnRQcm9jZXNzb3JzLFxuICAgIGF0dGFjaG1lbnRzLFxuICAgIHByb3BhZ2F0aW9uQ29udGV4dCxcbiAgICB0cmFuc2FjdGlvbk5hbWUsXG4gICAgc3BhbixcbiAgfSA9IG1lcmdlRGF0YTtcblxuICBtZXJnZUFuZE92ZXJ3cml0ZVNjb3BlRGF0YShkYXRhLCAnZXh0cmEnLCBleHRyYSk7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICd0YWdzJywgdGFncyk7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICd1c2VyJywgdXNlcik7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICdjb250ZXh0cycsIGNvbnRleHRzKTtcblxuICBkYXRhLnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IG1lcmdlKGRhdGEuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLCBzZGtQcm9jZXNzaW5nTWV0YWRhdGEsIDIpO1xuXG4gIGlmIChsZXZlbCkge1xuICAgIGRhdGEubGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIGlmICh0cmFuc2FjdGlvbk5hbWUpIHtcbiAgICBkYXRhLnRyYW5zYWN0aW9uTmFtZSA9IHRyYW5zYWN0aW9uTmFtZTtcbiAgfVxuXG4gIGlmIChzcGFuKSB7XG4gICAgZGF0YS5zcGFuID0gc3BhbjtcbiAgfVxuXG4gIGlmIChicmVhZGNydW1icy5sZW5ndGgpIHtcbiAgICBkYXRhLmJyZWFkY3J1bWJzID0gWy4uLmRhdGEuYnJlYWRjcnVtYnMsIC4uLmJyZWFkY3J1bWJzXTtcbiAgfVxuXG4gIGlmIChmaW5nZXJwcmludC5sZW5ndGgpIHtcbiAgICBkYXRhLmZpbmdlcnByaW50ID0gWy4uLmRhdGEuZmluZ2VycHJpbnQsIC4uLmZpbmdlcnByaW50XTtcbiAgfVxuXG4gIGlmIChldmVudFByb2Nlc3NvcnMubGVuZ3RoKSB7XG4gICAgZGF0YS5ldmVudFByb2Nlc3NvcnMgPSBbLi4uZGF0YS5ldmVudFByb2Nlc3NvcnMsIC4uLmV2ZW50UHJvY2Vzc29yc107XG4gIH1cblxuICBpZiAoYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgZGF0YS5hdHRhY2htZW50cyA9IFsuLi5kYXRhLmF0dGFjaG1lbnRzLCAuLi5hdHRhY2htZW50c107XG4gIH1cblxuICBkYXRhLnByb3BhZ2F0aW9uQ29udGV4dCA9IHsgLi4uZGF0YS5wcm9wYWdhdGlvbkNvbnRleHQsIC4uLnByb3BhZ2F0aW9uQ29udGV4dCB9O1xufVxuXG4vKipcbiAqIE1lcmdlcyBjZXJ0YWluIHNjb3BlIGRhdGEuIFVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIHZhbHVlcy5cbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFuZE92ZXJ3cml0ZVNjb3BlRGF0YVxuXG4oZGF0YSwgcHJvcCwgbWVyZ2VWYWwpIHtcbiAgZGF0YVtwcm9wXSA9IG1lcmdlKGRhdGFbcHJvcF0sIG1lcmdlVmFsLCAxKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEYXRhVG9FdmVudChldmVudCwgZGF0YSkge1xuICBjb25zdCB7IGV4dHJhLCB0YWdzLCB1c2VyLCBjb250ZXh0cywgbGV2ZWwsIHRyYW5zYWN0aW9uTmFtZSB9ID0gZGF0YTtcblxuICBpZiAoT2JqZWN0LmtleXMoZXh0cmEpLmxlbmd0aCkge1xuICAgIGV2ZW50LmV4dHJhID0geyAuLi5leHRyYSwgLi4uZXZlbnQuZXh0cmEgfTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh0YWdzKS5sZW5ndGgpIHtcbiAgICBldmVudC50YWdzID0geyAuLi50YWdzLCAuLi5ldmVudC50YWdzIH07XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModXNlcikubGVuZ3RoKSB7XG4gICAgZXZlbnQudXNlciA9IHsgLi4udXNlciwgLi4uZXZlbnQudXNlciB9O1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHRzKS5sZW5ndGgpIHtcbiAgICBldmVudC5jb250ZXh0cyA9IHsgLi4uY29udGV4dHMsIC4uLmV2ZW50LmNvbnRleHRzIH07XG4gIH1cblxuICBpZiAobGV2ZWwpIHtcbiAgICBldmVudC5sZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLy8gdHJhbnNhY3Rpb24gZXZlbnRzIGdldCB0aGVpciBgdHJhbnNhY3Rpb25gIGZyb20gdGhlIHJvb3Qgc3BhbiBuYW1lXG4gIGlmICh0cmFuc2FjdGlvbk5hbWUgJiYgZXZlbnQudHlwZSAhPT0gJ3RyYW5zYWN0aW9uJykge1xuICAgIGV2ZW50LnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25OYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5QnJlYWRjcnVtYnNUb0V2ZW50KGV2ZW50LCBicmVhZGNydW1icykge1xuICBjb25zdCBtZXJnZWRCcmVhZGNydW1icyA9IFsuLi4oZXZlbnQuYnJlYWRjcnVtYnMgfHwgW10pLCAuLi5icmVhZGNydW1ic107XG4gIGV2ZW50LmJyZWFkY3J1bWJzID0gbWVyZ2VkQnJlYWRjcnVtYnMubGVuZ3RoID8gbWVyZ2VkQnJlYWRjcnVtYnMgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U2RrTWV0YWRhdGFUb0V2ZW50KGV2ZW50LCBzZGtQcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge1xuICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICAuLi5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3BhblRvRXZlbnQoZXZlbnQsIHNwYW4pIHtcbiAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgdHJhY2U6IHNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSxcbiAgICAuLi5ldmVudC5jb250ZXh0cyxcbiAgfTtcblxuICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pLFxuICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgfTtcblxuICBjb25zdCByb290U3BhbiA9IGdldFJvb3RTcGFuKHNwYW4pO1xuICBjb25zdCB0cmFuc2FjdGlvbk5hbWUgPSBzcGFuVG9KU09OKHJvb3RTcGFuKS5kZXNjcmlwdGlvbjtcbiAgaWYgKHRyYW5zYWN0aW9uTmFtZSAmJiAhZXZlbnQudHJhbnNhY3Rpb24gJiYgZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJykge1xuICAgIGV2ZW50LnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25OYW1lO1xuICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBmaW5nZXJwcmludCBmcm9tIHRoZSBzY29wZSB0byB0aGUgZXZlbnQgaWYgdGhlcmUncyBvbmUsXG4gKiB1c2VzIG1lc3NhZ2UgaWYgdGhlcmUncyBvbmUgaW5zdGVhZCBvciBnZXQgcmlkIG9mIGVtcHR5IGZpbmdlcnByaW50XG4gKi9cbmZ1bmN0aW9uIGFwcGx5RmluZ2VycHJpbnRUb0V2ZW50KGV2ZW50LCBmaW5nZXJwcmludCkge1xuICAvLyBNYWtlIHN1cmUgaXQncyBhbiBhcnJheSBmaXJzdCBhbmQgd2UgYWN0dWFsbHkgaGF2ZSBzb21ldGhpbmcgaW4gcGxhY2VcbiAgZXZlbnQuZmluZ2VycHJpbnQgPSBldmVudC5maW5nZXJwcmludFxuICAgID8gQXJyYXkuaXNBcnJheShldmVudC5maW5nZXJwcmludClcbiAgICAgID8gZXZlbnQuZmluZ2VycHJpbnRcbiAgICAgIDogW2V2ZW50LmZpbmdlcnByaW50XVxuICAgIDogW107XG5cbiAgLy8gSWYgd2UgaGF2ZSBzb21ldGhpbmcgb24gdGhlIHNjb3BlLCB0aGVuIG1lcmdlIGl0IHdpdGggZXZlbnRcbiAgaWYgKGZpbmdlcnByaW50KSB7XG4gICAgZXZlbnQuZmluZ2VycHJpbnQgPSBldmVudC5maW5nZXJwcmludC5jb25jYXQoZmluZ2VycHJpbnQpO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBubyBkYXRhIGF0IGFsbCwgcmVtb3ZlIGVtcHR5IGFycmF5IGRlZmF1bHRcbiAgaWYgKCFldmVudC5maW5nZXJwcmludC5sZW5ndGgpIHtcbiAgICBkZWxldGUgZXZlbnQuZmluZ2VycHJpbnQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgYXBwbHlTY29wZURhdGFUb0V2ZW50LCBtZXJnZUFuZE92ZXJ3cml0ZVNjb3BlRGF0YSwgbWVyZ2VTY29wZURhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5U2NvcGVEYXRhVG9FdmVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasSpansEnabled: function() { return /* binding */ hasSpansEnabled; },\n/* harmony export */   hasTracingEnabled: function() { return /* binding */ hasTracingEnabled; }\n/* harmony export */ });\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../currentScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\");\n\n\n// Treeshakable guard to remove all code related to tracing\n\n/**\n * Determines if span recording is currently enabled.\n *\n * Spans are recorded when at least one of `tracesSampleRate` and `tracesSampler`\n * is defined in the SDK config. This function does not make any assumption about\n * sampling decisions, it only checks if the SDK is configured to record spans.\n *\n * Important: This function only determines if span recording is enabled. Trace\n * continuation and propagation is separately controlled and not covered by this function.\n * If this function returns `false`, traces can still be propagated (which is what\n * we refer to by \"Tracing without Performance\")\n * @see https://develop.sentry.dev/sdk/telemetry/traces/tracing-without-performance/\n *\n * @param maybeOptions An SDK options object to be passed to this function.\n * If this option is not provided, the function will use the current client's options.\n */\nfunction hasSpansEnabled(\n  maybeOptions,\n) {\n  if (typeof __SENTRY_TRACING__ === 'boolean' && !__SENTRY_TRACING__) {\n    return false;\n  }\n\n  const options = maybeOptions || (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)()?.getOptions();\n  return (\n    !!options &&\n    // Note: This check is `!= null`, meaning \"nullish\". `0` is not \"nullish\", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)\n    (options.tracesSampleRate != null || !!options.tracesSampler)\n  );\n}\n\n/**\n * @see JSDoc of `hasSpansEnabled`\n * @deprecated Use `hasSpansEnabled` instead, which is a more accurately named version of this function.\n * This function will be removed in the next major version of the SDK.\n */\n// TODO(v10): Remove this export\nconst hasTracingEnabled = hasSpansEnabled;\n\n\n//# sourceMappingURL=hasSpansEnabled.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsNERBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzP2Q2NTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Q2xpZW50IH0gZnJvbSAnLi4vY3VycmVudFNjb3Blcy5qcyc7XG5cbi8vIFRyZWVzaGFrYWJsZSBndWFyZCB0byByZW1vdmUgYWxsIGNvZGUgcmVsYXRlZCB0byB0cmFjaW5nXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBzcGFuIHJlY29yZGluZyBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAqXG4gKiBTcGFucyBhcmUgcmVjb3JkZWQgd2hlbiBhdCBsZWFzdCBvbmUgb2YgYHRyYWNlc1NhbXBsZVJhdGVgIGFuZCBgdHJhY2VzU2FtcGxlcmBcbiAqIGlzIGRlZmluZWQgaW4gdGhlIFNESyBjb25maWcuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBhbnkgYXNzdW1wdGlvbiBhYm91dFxuICogc2FtcGxpbmcgZGVjaXNpb25zLCBpdCBvbmx5IGNoZWNrcyBpZiB0aGUgU0RLIGlzIGNvbmZpZ3VyZWQgdG8gcmVjb3JkIHNwYW5zLlxuICpcbiAqIEltcG9ydGFudDogVGhpcyBmdW5jdGlvbiBvbmx5IGRldGVybWluZXMgaWYgc3BhbiByZWNvcmRpbmcgaXMgZW5hYmxlZC4gVHJhY2VcbiAqIGNvbnRpbnVhdGlvbiBhbmQgcHJvcGFnYXRpb24gaXMgc2VwYXJhdGVseSBjb250cm9sbGVkIGFuZCBub3QgY292ZXJlZCBieSB0aGlzIGZ1bmN0aW9uLlxuICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAsIHRyYWNlcyBjYW4gc3RpbGwgYmUgcHJvcGFnYXRlZCAod2hpY2ggaXMgd2hhdFxuICogd2UgcmVmZXIgdG8gYnkgXCJUcmFjaW5nIHdpdGhvdXQgUGVyZm9ybWFuY2VcIilcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL3RlbGVtZXRyeS90cmFjZXMvdHJhY2luZy13aXRob3V0LXBlcmZvcm1hbmNlL1xuICpcbiAqIEBwYXJhbSBtYXliZU9wdGlvbnMgQW4gU0RLIG9wdGlvbnMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLlxuICogSWYgdGhpcyBvcHRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gd2lsbCB1c2UgdGhlIGN1cnJlbnQgY2xpZW50J3Mgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaGFzU3BhbnNFbmFibGVkKFxuICBtYXliZU9wdGlvbnMsXG4pIHtcbiAgaWYgKHR5cGVvZiBfX1NFTlRSWV9UUkFDSU5HX18gPT09ICdib29sZWFuJyAmJiAhX19TRU5UUllfVFJBQ0lOR19fKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IG1heWJlT3B0aW9ucyB8fCBnZXRDbGllbnQoKT8uZ2V0T3B0aW9ucygpO1xuICByZXR1cm4gKFxuICAgICEhb3B0aW9ucyAmJlxuICAgIC8vIE5vdGU6IFRoaXMgY2hlY2sgaXMgYCE9IG51bGxgLCBtZWFuaW5nIFwibnVsbGlzaFwiLiBgMGAgaXMgbm90IFwibnVsbGlzaFwiLCBgdW5kZWZpbmVkYCBhbmQgYG51bGxgIGFyZS4gKFRoaXMgY29tbWVudCB3YXMgYnJvdWdodCB0byB5b3UgYnkgMTUgbWludXRlcyBvZiBxdWVzdGlvbmluZyBsaWZlKVxuICAgIChvcHRpb25zLnRyYWNlc1NhbXBsZVJhdGUgIT0gbnVsbCB8fCAhIW9wdGlvbnMudHJhY2VzU2FtcGxlcilcbiAgKTtcbn1cblxuLyoqXG4gKiBAc2VlIEpTRG9jIG9mIGBoYXNTcGFuc0VuYWJsZWRgXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGhhc1NwYW5zRW5hYmxlZGAgaW5zdGVhZCwgd2hpY2ggaXMgYSBtb3JlIGFjY3VyYXRlbHkgbmFtZWQgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB0aGUgU0RLLlxuICovXG4vLyBUT0RPKHYxMCk6IFJlbW92ZSB0aGlzIGV4cG9ydFxuY29uc3QgaGFzVHJhY2luZ0VuYWJsZWQgPSBoYXNTcGFuc0VuYWJsZWQ7XG5cbmV4cG9ydCB7IGhhc1NwYW5zRW5hYmxlZCwgaGFzVHJhY2luZ0VuYWJsZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc1NwYW5zRW5hYmxlZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/merge.js":
/*!*************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/merge.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   merge: function() { return /* binding */ merge; }\n/* harmony export */ });\n/**\n * Shallow merge two objects.\n * Does not mutate the passed in objects.\n * Undefined/empty values in the merge object will overwrite existing values.\n *\n * By default, this merges 2 levels deep.\n */\nfunction merge(initialObj, mergeObj, levels = 2) {\n  // If the merge value is not an object, or we have no merge levels left,\n  // we just set the value to the merge value\n  if (!mergeObj || typeof mergeObj !== 'object' || levels <= 0) {\n    return mergeObj;\n  }\n\n  // If the merge object is an empty object, and the initial object is not undefined, we return the initial object\n  if (initialObj && Object.keys(mergeObj).length === 0) {\n    return initialObj;\n  }\n\n  // Clone object\n  const output = { ...initialObj };\n\n  // Merge values into output, resursively\n  for (const key in mergeObj) {\n    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {\n      output[key] = merge(output[key], mergeObj[key], levels - 1);\n    }\n  }\n\n  return output;\n}\n\n\n//# sourceMappingURL=merge.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9tZXJnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvbWVyZ2UuanM/MjVjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNoYWxsb3cgbWVyZ2UgdHdvIG9iamVjdHMuXG4gKiBEb2VzIG5vdCBtdXRhdGUgdGhlIHBhc3NlZCBpbiBvYmplY3RzLlxuICogVW5kZWZpbmVkL2VtcHR5IHZhbHVlcyBpbiB0aGUgbWVyZ2Ugb2JqZWN0IHdpbGwgb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlcy5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIG1lcmdlcyAyIGxldmVscyBkZWVwLlxuICovXG5mdW5jdGlvbiBtZXJnZShpbml0aWFsT2JqLCBtZXJnZU9iaiwgbGV2ZWxzID0gMikge1xuICAvLyBJZiB0aGUgbWVyZ2UgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgb3Igd2UgaGF2ZSBubyBtZXJnZSBsZXZlbHMgbGVmdCxcbiAgLy8gd2UganVzdCBzZXQgdGhlIHZhbHVlIHRvIHRoZSBtZXJnZSB2YWx1ZVxuICBpZiAoIW1lcmdlT2JqIHx8IHR5cGVvZiBtZXJnZU9iaiAhPT0gJ29iamVjdCcgfHwgbGV2ZWxzIDw9IDApIHtcbiAgICByZXR1cm4gbWVyZ2VPYmo7XG4gIH1cblxuICAvLyBJZiB0aGUgbWVyZ2Ugb2JqZWN0IGlzIGFuIGVtcHR5IG9iamVjdCwgYW5kIHRoZSBpbml0aWFsIG9iamVjdCBpcyBub3QgdW5kZWZpbmVkLCB3ZSByZXR1cm4gdGhlIGluaXRpYWwgb2JqZWN0XG4gIGlmIChpbml0aWFsT2JqICYmIE9iamVjdC5rZXlzKG1lcmdlT2JqKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaW5pdGlhbE9iajtcbiAgfVxuXG4gIC8vIENsb25lIG9iamVjdFxuICBjb25zdCBvdXRwdXQgPSB7IC4uLmluaXRpYWxPYmogfTtcblxuICAvLyBNZXJnZSB2YWx1ZXMgaW50byBvdXRwdXQsIHJlc3Vyc2l2ZWx5XG4gIGZvciAoY29uc3Qga2V5IGluIG1lcmdlT2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXJnZU9iaiwga2V5KSkge1xuICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZShvdXRwdXRba2V5XSwgbWVyZ2VPYmpba2V5XSwgbGV2ZWxzIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IHsgbWVyZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/merge.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseSampleRate: function() { return /* binding */ parseSampleRate; }\n/* harmony export */ });\n/**\n * Parse a sample rate from a given value.\n * This will either return a boolean or number sample rate, if the sample rate is valid (between 0 and 1).\n * If a string is passed, we try to convert it to a number.\n *\n * Any invalid sample rate will return `undefined`.\n */\nfunction parseSampleRate(sampleRate) {\n  if (typeof sampleRate === 'boolean') {\n    return Number(sampleRate);\n  }\n\n  const rate = typeof sampleRate === 'string' ? parseFloat(sampleRate) : sampleRate;\n  if (typeof rate !== 'number' || isNaN(rate) || rate < 0 || rate > 1) {\n    return undefined;\n  }\n\n  return rate;\n}\n\n\n//# sourceMappingURL=parseSampleRate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3BhcnNlU2FtcGxlUmF0ZS5qcz8xNGMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFyc2UgYSBzYW1wbGUgcmF0ZSBmcm9tIGEgZ2l2ZW4gdmFsdWUuXG4gKiBUaGlzIHdpbGwgZWl0aGVyIHJldHVybiBhIGJvb2xlYW4gb3IgbnVtYmVyIHNhbXBsZSByYXRlLCBpZiB0aGUgc2FtcGxlIHJhdGUgaXMgdmFsaWQgKGJldHdlZW4gMCBhbmQgMSkuXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIHdlIHRyeSB0byBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyLlxuICpcbiAqIEFueSBpbnZhbGlkIHNhbXBsZSByYXRlIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBwYXJzZVNhbXBsZVJhdGUoc2FtcGxlUmF0ZSkge1xuICBpZiAodHlwZW9mIHNhbXBsZVJhdGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBOdW1iZXIoc2FtcGxlUmF0ZSk7XG4gIH1cblxuICBjb25zdCByYXRlID0gdHlwZW9mIHNhbXBsZVJhdGUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdChzYW1wbGVSYXRlKSA6IHNhbXBsZVJhdGU7XG4gIGlmICh0eXBlb2YgcmF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4ocmF0ZSkgfHwgcmF0ZSA8IDAgfHwgcmF0ZSA+IDEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHJhdGU7XG59XG5cbmV4cG9ydCB7IHBhcnNlU2FtcGxlUmF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VTYW1wbGVSYXRlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/parseSampleRate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/prepareEvent.js":
/*!********************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/prepareEvent.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyClientOptions: function() { return /* binding */ applyClientOptions; },\n/* harmony export */   applyDebugIds: function() { return /* binding */ applyDebugIds; },\n/* harmony export */   applyDebugMeta: function() { return /* binding */ applyDebugMeta; },\n/* harmony export */   parseEventHintOrCaptureContext: function() { return /* binding */ parseEventHintOrCaptureContext; },\n/* harmony export */   prepareEvent: function() { return /* binding */ prepareEvent; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/constants.js\");\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../currentScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../eventProcessors.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/eventProcessors.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../scope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/scope.js\");\n/* harmony import */ var _utils_hoist_debug_ids_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils-hoist/debug-ids.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/debug-ids.js\");\n/* harmony import */ var _utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils-hoist/misc.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n/* harmony import */ var _utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils-hoist/normalize.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/normalize.js\");\n/* harmony import */ var _utils_hoist_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils-hoist/string.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/string.js\");\n/* harmony import */ var _utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils-hoist/time.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n/* harmony import */ var _applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./applyScopeDataToEvent.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/applyScopeDataToEvent.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_0__.uuid4)(),\n    timestamp: event.timestamp || (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_1__.dateTimestampInSeconds)(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    (0,_utils_hoist_misc_js__WEBPACK_IMPORTED_MODULE_0__.addExceptionMechanism)(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getGlobalScope)().getScopeData();\n\n  if (isolationScope) {\n    const isolationData = isolationScope.getScopeData();\n    (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.mergeScopeData)(data, isolationData);\n  }\n\n  if (finalScope) {\n    const finalScopeData = finalScope.getScopeData();\n    (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.mergeScopeData)(data, finalScopeData);\n  }\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.applyScopeDataToEvent)(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  const result = (0,_eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__.notifyEventProcessors)(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || _constants_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url) {\n    request.url = (0,_utils_hoist_string_js__WEBPACK_IMPORTED_MODULE_6__.truncate)(request.url, maxValueLength);\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = (0,_utils_hoist_debug_ids_js__WEBPACK_IMPORTED_MODULE_7__.getFilenameToDebugIdMap)(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = (0,_utils_hoist_normalize_js__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new _scope_js__WEBPACK_IMPORTED_MODULE_9__.Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof _scope_js__WEBPACK_IMPORTED_MODULE_9__.Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\n\n//# sourceMappingURL=prepareEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9wcmVwYXJlRXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ0Q7QUFDUztBQUMxQjtBQUNrQztBQUNBO0FBQ2Q7QUFDSjtBQUNZO0FBQ21COztBQUVuRjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVEsV0FBVyxlQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRDtBQUNBO0FBQ0EsaURBQWlELDJEQUFLO0FBQ3RELGtDQUFrQyw0RUFBc0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDJFQUFxQjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0EsZUFBZSxpRUFBYzs7QUFFN0I7QUFDQTtBQUNBLElBQUkseUVBQWM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLElBQUkseUVBQWM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnRkFBcUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDBFQUFxQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQW1EOztBQUU3RDtBQUNBO0FBQ0EsMERBQTBELDhEQUFtQjs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrRkFBdUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBUztBQUN6QixTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLFlBQVksb0VBQVM7QUFDckIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLG9FQUFTO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLGFBQWEsb0VBQVM7QUFDdEIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLG9FQUFTO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFTO0FBQ3pCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9FQUFTO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDRDQUFLO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qiw0Q0FBSztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUyRztBQUMzRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvcHJlcGFyZUV2ZW50LmpzPzU1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxTY29wZSB9IGZyb20gJy4uL2N1cnJlbnRTY29wZXMuanMnO1xuaW1wb3J0IHsgbm90aWZ5RXZlbnRQcm9jZXNzb3JzIH0gZnJvbSAnLi4vZXZlbnRQcm9jZXNzb3JzLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi4vc2NvcGUuanMnO1xuaW1wb3J0IHsgZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAgfSBmcm9tICcuLi91dGlscy1ob2lzdC9kZWJ1Zy1pZHMuanMnO1xuaW1wb3J0IHsgdXVpZDQsIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L21pc2MuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvbm9ybWFsaXplLmpzJztcbmltcG9ydCB7IHRydW5jYXRlIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJztcbmltcG9ydCB7IGRhdGVUaW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuLi91dGlscy1ob2lzdC90aW1lLmpzJztcbmltcG9ydCB7IG1lcmdlU2NvcGVEYXRhLCBhcHBseVNjb3BlRGF0YVRvRXZlbnQgfSBmcm9tICcuL2FwcGx5U2NvcGVEYXRhVG9FdmVudC5qcyc7XG5cbi8qKlxuICogVGhpcyB0eXBlIG1ha2VzIHN1cmUgdGhhdCB3ZSBnZXQgZWl0aGVyIGEgQ2FwdHVyZUNvbnRleHQsIE9SIGFuIEV2ZW50SGludC5cbiAqIEl0IGRvZXMgbm90IGFsbG93IG1peGluZyB0aGVtLCB3aGljaCBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgb3V0Y29tZXMsIGUuZy4gdGhpcyBpcyBkaXNhbGxvd2VkOlxuICogeyB1c2VyOiB7IGlkOiAnMTIzJyB9LCBtZWNoYW5pc206IHsgaGFuZGxlZDogZmFsc2UgfSB9XG4gKi9cblxuLyoqXG4gKiBBZGRzIGNvbW1vbiBpbmZvcm1hdGlvbiB0byBldmVudHMuXG4gKlxuICogVGhlIGluZm9ybWF0aW9uIGluY2x1ZGVzIHJlbGVhc2UgYW5kIGVudmlyb25tZW50IGZyb20gYG9wdGlvbnNgLFxuICogYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgKGV4dHJhLCB0YWdzIGFuZCB1c2VyKSBmcm9tIHRoZSBzY29wZS5cbiAqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZXZlbnQgaXMgbmV2ZXIgb3ZlcndyaXR0ZW4uIEZvclxuICogbmVzdGVkIG9iamVjdHMsIHN1Y2ggYXMgdGhlIGNvbnRleHQsIGtleXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHBhcmFtIGhpbnQgTWF5IGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuICogQHBhcmFtIHNjb3BlIEEgc2NvcGUgY29udGFpbmluZyBldmVudCBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIEEgbmV3IGV2ZW50IHdpdGggbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUV2ZW50KFxuICBvcHRpb25zLFxuICBldmVudCxcbiAgaGludCxcbiAgc2NvcGUsXG4gIGNsaWVudCxcbiAgaXNvbGF0aW9uU2NvcGUsXG4pIHtcbiAgY29uc3QgeyBub3JtYWxpemVEZXB0aCA9IDMsIG5vcm1hbGl6ZU1heEJyZWFkdGggPSAxMDAwIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVwYXJlZCA9IHtcbiAgICAuLi5ldmVudCxcbiAgICBldmVudF9pZDogZXZlbnQuZXZlbnRfaWQgfHwgaGludC5ldmVudF9pZCB8fCB1dWlkNCgpLFxuICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wIHx8IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgfTtcbiAgY29uc3QgaW50ZWdyYXRpb25zID0gaGludC5pbnRlZ3JhdGlvbnMgfHwgb3B0aW9ucy5pbnRlZ3JhdGlvbnMubWFwKGkgPT4gaS5uYW1lKTtcblxuICBhcHBseUNsaWVudE9wdGlvbnMocHJlcGFyZWQsIG9wdGlvbnMpO1xuICBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKHByZXBhcmVkLCBpbnRlZ3JhdGlvbnMpO1xuXG4gIGlmIChjbGllbnQpIHtcbiAgICBjbGllbnQuZW1pdCgnYXBwbHlGcmFtZU1ldGFkYXRhJywgZXZlbnQpO1xuICB9XG5cbiAgLy8gT25seSBwdXQgZGVidWcgSURzIG9udG8gZnJhbWVzIGZvciBlcnJvciBldmVudHMuXG4gIGlmIChldmVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBhcHBseURlYnVnSWRzKHByZXBhcmVkLCBvcHRpb25zLnN0YWNrUGFyc2VyKTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgc2NvcGUgZ2l2ZW4gdG8gdXMsIHVzZSBpdCBhcyB0aGUgYmFzZSBmb3IgZnVydGhlciBtb2RpZmljYXRpb25zLlxuICAvLyBUaGlzIGFsbG93cyB1cyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IGNvcHlpbmcgb2YgZGF0YSBpZiBgY2FwdHVyZUNvbnRleHRgIGlzIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgZmluYWxTY29wZSA9IGdldEZpbmFsU2NvcGUoc2NvcGUsIGhpbnQuY2FwdHVyZUNvbnRleHQpO1xuXG4gIGlmIChoaW50Lm1lY2hhbmlzbSkge1xuICAgIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbShwcmVwYXJlZCwgaGludC5tZWNoYW5pc20pO1xuICB9XG5cbiAgY29uc3QgY2xpZW50RXZlbnRQcm9jZXNzb3JzID0gY2xpZW50ID8gY2xpZW50LmdldEV2ZW50UHJvY2Vzc29ycygpIDogW107XG5cbiAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIGxhc3QgdGhpbmcgY2FsbGVkLCBzaW5jZSB3ZSB3YW50IHRoYXRcbiAgLy8ge0BsaW5rIFNjb3BlLmFkZEV2ZW50UHJvY2Vzc29yfSBnZXRzIHRoZSBmaW5pc2hlZCBwcmVwYXJlZCBldmVudC5cbiAgLy8gTWVyZ2Ugc2NvcGUgZGF0YSB0b2dldGhlclxuICBjb25zdCBkYXRhID0gZ2V0R2xvYmFsU2NvcGUoKS5nZXRTY29wZURhdGEoKTtcblxuICBpZiAoaXNvbGF0aW9uU2NvcGUpIHtcbiAgICBjb25zdCBpc29sYXRpb25EYXRhID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2NvcGVEYXRhKCk7XG4gICAgbWVyZ2VTY29wZURhdGEoZGF0YSwgaXNvbGF0aW9uRGF0YSk7XG4gIH1cblxuICBpZiAoZmluYWxTY29wZSkge1xuICAgIGNvbnN0IGZpbmFsU2NvcGVEYXRhID0gZmluYWxTY29wZS5nZXRTY29wZURhdGEoKTtcbiAgICBtZXJnZVNjb3BlRGF0YShkYXRhLCBmaW5hbFNjb3BlRGF0YSk7XG4gIH1cblxuICBjb25zdCBhdHRhY2htZW50cyA9IFsuLi4oaGludC5hdHRhY2htZW50cyB8fCBbXSksIC4uLmRhdGEuYXR0YWNobWVudHNdO1xuICBpZiAoYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgaGludC5hdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzO1xuICB9XG5cbiAgYXBwbHlTY29wZURhdGFUb0V2ZW50KHByZXBhcmVkLCBkYXRhKTtcblxuICBjb25zdCBldmVudFByb2Nlc3NvcnMgPSBbXG4gICAgLi4uY2xpZW50RXZlbnRQcm9jZXNzb3JzLFxuICAgIC8vIFJ1biBzY29wZSBldmVudCBwcm9jZXNzb3JzIF9hZnRlcl8gYWxsIG90aGVyIHByb2Nlc3NvcnNcbiAgICAuLi5kYXRhLmV2ZW50UHJvY2Vzc29ycyxcbiAgXTtcblxuICBjb25zdCByZXN1bHQgPSBub3RpZnlFdmVudFByb2Nlc3NvcnMoZXZlbnRQcm9jZXNzb3JzLCBwcmVwYXJlZCwgaGludCk7XG5cbiAgcmV0dXJuIHJlc3VsdC50aGVuKGV2dCA9PiB7XG4gICAgaWYgKGV2dCkge1xuICAgICAgLy8gV2UgYXBwbHkgdGhlIGRlYnVnX21ldGEgZmllbGQgb25seSBhZnRlciBhbGwgZXZlbnQgcHJvY2Vzc29ycyBoYXZlIHJhbiwgc28gdGhhdCBpZiBhbnkgZXZlbnQgcHJvY2Vzc29ycyBtb2RpZmllZFxuICAgICAgLy8gZmlsZSBuYW1lcyAoZS5nLnRoZSBSZXdyaXRlRnJhbWVzIGludGVncmF0aW9uKSB0aGUgZmlsZW5hbWUgLT4gZGVidWcgSUQgcmVsYXRpb25zaGlwIGlzbid0IGRlc3Ryb3llZC5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBjYXVzZSBhbnkgUElJIGlzc3Vlcywgc2luY2Ugd2UncmUgb25seSBtb3ZpbmcgZGF0YSB0aGF0IGlzIGFscmVhZHkgb24gdGhlIGV2ZW50IGFuZCBub3QgYWRkaW5nXG4gICAgICAvLyBhbnkgbmV3IGRhdGFcbiAgICAgIGFwcGx5RGVidWdNZXRhKGV2dCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBub3JtYWxpemVEZXB0aCA9PT0gJ251bWJlcicgJiYgbm9ybWFsaXplRGVwdGggPiAwKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplRXZlbnQoZXZ0LCBub3JtYWxpemVEZXB0aCwgbm9ybWFsaXplTWF4QnJlYWR0aCk7XG4gICAgfVxuICAgIHJldHVybiBldnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVuaGFuY2VzIGV2ZW50IHVzaW5nIHRoZSBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqIEl0IHRha2VzIGNhcmUgb2YgYWxsIFwic3RhdGljXCIgdmFsdWVzIGxpa2UgZW52aXJvbm1lbnQsIHJlbGVhc2UgYW5kIGBkaXN0YCxcbiAqIGFzIHdlbGwgYXMgdHJ1bmNhdGluZyBvdmVybHkgbG9uZyB2YWx1ZXMuXG4gKlxuICogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuXG4gKlxuICogQHBhcmFtIGV2ZW50IGV2ZW50IGluc3RhbmNlIHRvIGJlIGVuaGFuY2VkXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q2xpZW50T3B0aW9ucyhldmVudCwgb3B0aW9ucykge1xuICBjb25zdCB7IGVudmlyb25tZW50LCByZWxlYXNlLCBkaXN0LCBtYXhWYWx1ZUxlbmd0aCA9IDI1MCB9ID0gb3B0aW9ucztcblxuICAvLyBlbXB0eSBzdHJpbmdzIGRvIG5vdCBtYWtlIHNlbnNlIGZvciBlbnZpcm9ubWVudCwgcmVsZWFzZSwgYW5kIGRpc3RcbiAgLy8gc28gd2UgaGFuZGxlIHRoZW0gdGhlIHNhbWUgYXMgaWYgdGhleSB3ZXJlIG5vdCBwcm92aWRlZFxuICBldmVudC5lbnZpcm9ubWVudCA9IGV2ZW50LmVudmlyb25tZW50IHx8IGVudmlyb25tZW50IHx8IERFRkFVTFRfRU5WSVJPTk1FTlQ7XG5cbiAgaWYgKCFldmVudC5yZWxlYXNlICYmIHJlbGVhc2UpIHtcbiAgICBldmVudC5yZWxlYXNlID0gcmVsZWFzZTtcbiAgfVxuXG4gIGlmICghZXZlbnQuZGlzdCAmJiBkaXN0KSB7XG4gICAgZXZlbnQuZGlzdCA9IGRpc3Q7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0gZXZlbnQucmVxdWVzdDtcbiAgaWYgKHJlcXVlc3Q/LnVybCkge1xuICAgIHJlcXVlc3QudXJsID0gdHJ1bmNhdGUocmVxdWVzdC51cmwsIG1heFZhbHVlTGVuZ3RoKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1dHMgZGVidWcgSURzIGludG8gdGhlIHN0YWNrIGZyYW1lcyBvZiBhbiBlcnJvciBldmVudC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWJ1Z0lkcyhldmVudCwgc3RhY2tQYXJzZXIpIHtcbiAgLy8gQnVpbGQgYSBtYXAgb2YgZmlsZW5hbWUgLT4gZGVidWdfaWRcbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0gZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAoc3RhY2tQYXJzZXIpO1xuXG4gIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5mb3JFYWNoKGV4Y2VwdGlvbiA9PiB7XG4gICAgZXhjZXB0aW9uLnN0YWNrdHJhY2U/LmZyYW1lcz8uZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICBpZiAoZnJhbWUuZmlsZW5hbWUpIHtcbiAgICAgICAgZnJhbWUuZGVidWdfaWQgPSBmaWxlbmFtZURlYnVnSWRNYXBbZnJhbWUuZmlsZW5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNb3ZlcyBkZWJ1ZyBJRHMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9mIGFuIGVycm9yIGV2ZW50IGludG8gdGhlIGRlYnVnX21ldGEgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVidWdNZXRhKGV2ZW50KSB7XG4gIC8vIEV4dHJhY3QgZGVidWcgSURzIGFuZCBmaWxlbmFtZXMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9uIHRoZSBldmVudC5cbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0ge307XG4gIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5mb3JFYWNoKGV4Y2VwdGlvbiA9PiB7XG4gICAgZXhjZXB0aW9uLnN0YWNrdHJhY2U/LmZyYW1lcz8uZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICBpZiAoZnJhbWUuZGVidWdfaWQpIHtcbiAgICAgICAgaWYgKGZyYW1lLmFic19wYXRoKSB7XG4gICAgICAgICAgZmlsZW5hbWVEZWJ1Z0lkTWFwW2ZyYW1lLmFic19wYXRoXSA9IGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLmZpbGVuYW1lKSB7XG4gICAgICAgICAgZmlsZW5hbWVEZWJ1Z0lkTWFwW2ZyYW1lLmZpbGVuYW1lXSA9IGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBmcmFtZS5kZWJ1Z19pZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGZpbGVuYW1lRGVidWdJZE1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmlsbCBkZWJ1Z19tZXRhIGluZm9ybWF0aW9uXG4gIGV2ZW50LmRlYnVnX21ldGEgPSBldmVudC5kZWJ1Z19tZXRhIHx8IHt9O1xuICBldmVudC5kZWJ1Z19tZXRhLmltYWdlcyA9IGV2ZW50LmRlYnVnX21ldGEuaW1hZ2VzIHx8IFtdO1xuICBjb25zdCBpbWFnZXMgPSBldmVudC5kZWJ1Z19tZXRhLmltYWdlcztcbiAgT2JqZWN0LmVudHJpZXMoZmlsZW5hbWVEZWJ1Z0lkTWFwKS5mb3JFYWNoKChbZmlsZW5hbWUsIGRlYnVnX2lkXSkgPT4ge1xuICAgIGltYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdzb3VyY2VtYXAnLFxuICAgICAgY29kZV9maWxlOiBmaWxlbmFtZSxcbiAgICAgIGRlYnVnX2lkLFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWxsIHVzZWQgaW50ZWdyYXRpb25zIHRvIHRoZSBTREsgaW5mbyBpbiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBhbGwgaW50ZWdyYXRpb25zLlxuICovXG5mdW5jdGlvbiBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKGV2ZW50LCBpbnRlZ3JhdGlvbk5hbWVzKSB7XG4gIGlmIChpbnRlZ3JhdGlvbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBldmVudC5zZGsgPSBldmVudC5zZGsgfHwge307XG4gICAgZXZlbnQuc2RrLmludGVncmF0aW9ucyA9IFsuLi4oZXZlbnQuc2RrLmludGVncmF0aW9ucyB8fCBbXSksIC4uLmludGVncmF0aW9uTmFtZXNdO1xuICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBgbm9ybWFsaXplYCBmdW5jdGlvbiBvbiBuZWNlc3NhcnkgYEV2ZW50YCBhdHRyaWJ1dGVzIHRvIG1ha2UgdGhlbSBzYWZlIGZvciBzZXJpYWxpemF0aW9uLlxuICogTm9ybWFsaXplZCBrZXlzOlxuICogLSBgYnJlYWRjcnVtYnMuZGF0YWBcbiAqIC0gYHVzZXJgXG4gKiAtIGBjb250ZXh0c2BcbiAqIC0gYGV4dHJhYFxuICogQHBhcmFtIGV2ZW50IEV2ZW50XG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGV2ZW50LCBkZXB0aCwgbWF4QnJlYWR0aCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIC4uLmV2ZW50LFxuICAgIC4uLihldmVudC5icmVhZGNydW1icyAmJiB7XG4gICAgICBicmVhZGNydW1iczogZXZlbnQuYnJlYWRjcnVtYnMubWFwKGIgPT4gKHtcbiAgICAgICAgLi4uYixcbiAgICAgICAgLi4uKGIuZGF0YSAmJiB7XG4gICAgICAgICAgZGF0YTogbm9ybWFsaXplKGIuZGF0YSwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgICAgICB9KSxcbiAgICAgIH0pKSxcbiAgICB9KSxcbiAgICAuLi4oZXZlbnQudXNlciAmJiB7XG4gICAgICB1c2VyOiBub3JtYWxpemUoZXZlbnQudXNlciwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgIH0pLFxuICAgIC4uLihldmVudC5jb250ZXh0cyAmJiB7XG4gICAgICBjb250ZXh0czogbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLCBkZXB0aCwgbWF4QnJlYWR0aCksXG4gICAgfSksXG4gICAgLi4uKGV2ZW50LmV4dHJhICYmIHtcbiAgICAgIGV4dHJhOiBub3JtYWxpemUoZXZlbnQuZXh0cmEsIGRlcHRoLCBtYXhCcmVhZHRoKSxcbiAgICB9KSxcbiAgfTtcblxuICAvLyBldmVudC5jb250ZXh0cy50cmFjZSBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBUcmFuc2FjdGlvbi4gU2ltaWxhcmx5LFxuICAvLyBldmVudC5zcGFuc1tdIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBjaGlsZCBTcGFucy4gR2l2ZW4gdGhhdCBhXG4gIC8vIFRyYW5zYWN0aW9uIGlzIGNvbmNlcHR1YWxseSBhIFNwYW4sIG5vcm1hbGl6YXRpb24gc2hvdWxkIGFwcGx5IHRvIGJvdGhcbiAgLy8gVHJhbnNhY3Rpb25zIGFuZCBTcGFucyBjb25zaXN0ZW50bHkuXG4gIC8vIEZvciBub3cgdGhlIGRlY2lzaW9uIGlzIHRvIHNraXAgbm9ybWFsaXphdGlvbiBvZiBUcmFuc2FjdGlvbnMgYW5kIFNwYW5zLFxuICAvLyBzbyB0aGlzIGJsb2NrIG92ZXJ3cml0ZXMgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgdG8gYWRkIGJhY2sgdGhlIG9yaWdpbmFsXG4gIC8vIFRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIHByaW9yIHRvIG5vcm1hbGl6YXRpb24uXG4gIGlmIChldmVudC5jb250ZXh0cz8udHJhY2UgJiYgbm9ybWFsaXplZC5jb250ZXh0cykge1xuICAgIG5vcm1hbGl6ZWQuY29udGV4dHMudHJhY2UgPSBldmVudC5jb250ZXh0cy50cmFjZTtcblxuICAgIC8vIGV2ZW50LmNvbnRleHRzLnRyYWNlLmRhdGEgbWF5IGNvbnRhaW4gY2lyY3VsYXIvZGFuZ2Vyb3VzIGRhdGEgc28gd2UgbmVlZCB0byBub3JtYWxpemUgaXRcbiAgICBpZiAoZXZlbnQuY29udGV4dHMudHJhY2UuZGF0YSkge1xuICAgICAgbm9ybWFsaXplZC5jb250ZXh0cy50cmFjZS5kYXRhID0gbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLnRyYWNlLmRhdGEsIGRlcHRoLCBtYXhCcmVhZHRoKTtcbiAgICB9XG4gIH1cblxuICAvLyBldmVudC5zcGFuc1tdLmRhdGEgbWF5IGNvbnRhaW4gY2lyY3VsYXIvZGFuZ2Vyb3VzIGRhdGEgc28gd2UgbmVlZCB0byBub3JtYWxpemUgaXRcbiAgaWYgKGV2ZW50LnNwYW5zKSB7XG4gICAgbm9ybWFsaXplZC5zcGFucyA9IGV2ZW50LnNwYW5zLm1hcChzcGFuID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNwYW4sXG4gICAgICAgIC4uLihzcGFuLmRhdGEgJiYge1xuICAgICAgICAgIGRhdGE6IG5vcm1hbGl6ZShzcGFuLmRhdGEsIGRlcHRoLCBtYXhCcmVhZHRoKSxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZXZlbnQuY29udGV4dHMuZmxhZ3MgKEZlYXR1cmVGbGFnQ29udGV4dCkgc3RvcmVzIGNvbnRleHQgZm9yIG91ciBmZWF0dXJlXG4gIC8vIGZsYWcgaW50ZWdyYXRpb25zLiBJdCBoYXMgYSBncmVhdGVyIG5lc3RpbmcgZGVwdGggdGhhbiBvdXIgb3RoZXIgdHlwZWRcbiAgLy8gQ29udGV4dHMsIHNvIHdlIHJlLW5vcm1hbGl6ZSB3aXRoIGEgZml4ZWQgZGVwdGggb2YgMyBoZXJlLiBXZSBkbyBub3Qgd2FudFxuICAvLyB0byBza2lwIHRoaXMgaW4gY2FzZSBvZiBjb25mbGljdGluZywgdXNlci1wcm92aWRlZCBjb250ZXh0LlxuICBpZiAoZXZlbnQuY29udGV4dHM/LmZsYWdzICYmIG5vcm1hbGl6ZWQuY29udGV4dHMpIHtcbiAgICBub3JtYWxpemVkLmNvbnRleHRzLmZsYWdzID0gbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLmZsYWdzLCAzLCBtYXhCcmVhZHRoKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBnZXRGaW5hbFNjb3BlKHNjb3BlLCBjYXB0dXJlQ29udGV4dCkge1xuICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgY29uc3QgZmluYWxTY29wZSA9IHNjb3BlID8gc2NvcGUuY2xvbmUoKSA6IG5ldyBTY29wZSgpO1xuICBmaW5hbFNjb3BlLnVwZGF0ZShjYXB0dXJlQ29udGV4dCk7XG4gIHJldHVybiBmaW5hbFNjb3BlO1xufVxuXG4vKipcbiAqIFBhcnNlIGVpdGhlciBhbiBgRXZlbnRIaW50YCBkaXJlY3RseSwgb3IgY29udmVydCBhIGBDYXB0dXJlQ29udGV4dGAgdG8gYW4gYEV2ZW50SGludGAuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxsb3cgdG8gdXBkYXRlIG1ldGhvZCBzaWduYXR1cmVzIHRoYXQgdXNlZCB0byBhY2NlcHQgYSBgQ2FwdHVyZUNvbnRleHRgIGJ1dCBzaG91bGQgbm93IGFjY2VwdCBhbiBgRXZlbnRIaW50YC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0KFxuICBoaW50LFxuKSB7XG4gIGlmICghaGludCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiB5b3UgcGFzcyBhIFNjb3BlIG9yIGAoKSA9PiBTY29wZWAgYXMgQ2FwdHVyZUNvbnRleHQsIHdlIGp1c3QgcmV0dXJuIHRoaXMgYXMgY2FwdHVyZUNvbnRleHRcbiAgaWYgKGhpbnRJc1Njb3BlT3JGdW5jdGlvbihoaW50KSkge1xuICAgIHJldHVybiB7IGNhcHR1cmVDb250ZXh0OiBoaW50IH07XG4gIH1cblxuICBpZiAoaGludElzU2NvcGVDb250ZXh0KGhpbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmVDb250ZXh0OiBoaW50LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGludDtcbn1cblxuZnVuY3Rpb24gaGludElzU2NvcGVPckZ1bmN0aW9uKGhpbnQpIHtcbiAgcmV0dXJuIGhpbnQgaW5zdGFuY2VvZiBTY29wZSB8fCB0eXBlb2YgaGludCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY29uc3QgY2FwdHVyZUNvbnRleHRLZXlzID0gW1xuICAndXNlcicsXG4gICdsZXZlbCcsXG4gICdleHRyYScsXG4gICdjb250ZXh0cycsXG4gICd0YWdzJyxcbiAgJ2ZpbmdlcnByaW50JyxcbiAgJ3Byb3BhZ2F0aW9uQ29udGV4dCcsXG5dIDtcblxuZnVuY3Rpb24gaGludElzU2NvcGVDb250ZXh0KGhpbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhpbnQpLnNvbWUoa2V5ID0+IGNhcHR1cmVDb250ZXh0S2V5cy5pbmNsdWRlcyhrZXkgKSk7XG59XG5cbmV4cG9ydCB7IGFwcGx5Q2xpZW50T3B0aW9ucywgYXBwbHlEZWJ1Z0lkcywgYXBwbHlEZWJ1Z01ldGEsIHBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dCwgcHJlcGFyZUV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVwYXJlRXZlbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/prepareEvent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanOnScope.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/spanOnScope.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getSpanForScope: function() { return /* binding */ _getSpanForScope; },\n/* harmony export */   _setSpanForScope: function() { return /* binding */ _setSpanForScope; }\n/* harmony export */ });\n/* harmony import */ var _utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils-hoist/object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n\n\nconst SCOPE_SPAN_FIELD = '_sentrySpan';\n\n/**\n * Set the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _setSpanForScope(scope, span) {\n  if (span) {\n    (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_0__.addNonEnumerableProperty)(scope , SCOPE_SPAN_FIELD, span);\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete (scope )[SCOPE_SPAN_FIELD];\n  }\n}\n\n/**\n * Get the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _getSpanForScope(scope) {\n  return scope[SCOPE_SPAN_FIELD];\n}\n\n\n//# sourceMappingURL=spanOnScope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9zcGFuT25TY29wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0U7O0FBRXBFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0ZBQXdCO0FBQzVCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEM7QUFDOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3NwYW5PblNjb3BlLmpzPzBhYWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5IH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJztcblxuY29uc3QgU0NPUEVfU1BBTl9GSUVMRCA9ICdfc2VudHJ5U3Bhbic7XG5cbi8qKlxuICogU2V0IHRoZSBhY3RpdmUgc3BhbiBmb3IgYSBnaXZlbiBzY29wZS5cbiAqIE5PVEU6IFRoaXMgc2hvdWxkIE5PVCBiZSB1c2VkIGRpcmVjdGx5LCBidXQgaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHRyYWNlIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIF9zZXRTcGFuRm9yU2NvcGUoc2NvcGUsIHNwYW4pIHtcbiAgaWYgKHNwYW4pIHtcbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc2NvcGUgLCBTQ09QRV9TUEFOX0ZJRUxELCBzcGFuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgZGVsZXRlIChzY29wZSApW1NDT1BFX1NQQU5fRklFTERdO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBhY3RpdmUgc3BhbiBmb3IgYSBnaXZlbiBzY29wZS5cbiAqIE5PVEU6IFRoaXMgc2hvdWxkIE5PVCBiZSB1c2VkIGRpcmVjdGx5LCBidXQgaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHRyYWNlIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIF9nZXRTcGFuRm9yU2NvcGUoc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlW1NDT1BFX1NQQU5fRklFTERdO1xufVxuXG5leHBvcnQgeyBfZ2V0U3BhbkZvclNjb3BlLCBfc2V0U3BhbkZvclNjb3BlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGFuT25TY29wZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanOnScope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanUtils.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@sentry/core/build/esm/utils/spanUtils.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACE_FLAG_NONE: function() { return /* binding */ TRACE_FLAG_NONE; },\n/* harmony export */   TRACE_FLAG_SAMPLED: function() { return /* binding */ TRACE_FLAG_SAMPLED; },\n/* harmony export */   addChildSpanToSpan: function() { return /* binding */ addChildSpanToSpan; },\n/* harmony export */   convertSpanLinksForEnvelope: function() { return /* binding */ convertSpanLinksForEnvelope; },\n/* harmony export */   getActiveSpan: function() { return /* binding */ getActiveSpan; },\n/* harmony export */   getRootSpan: function() { return /* binding */ getRootSpan; },\n/* harmony export */   getSpanDescendants: function() { return /* binding */ getSpanDescendants; },\n/* harmony export */   getStatusMessage: function() { return /* binding */ getStatusMessage; },\n/* harmony export */   removeChildSpanFromSpan: function() { return /* binding */ removeChildSpanFromSpan; },\n/* harmony export */   showSpanDropWarning: function() { return /* binding */ showSpanDropWarning; },\n/* harmony export */   spanIsSampled: function() { return /* binding */ spanIsSampled; },\n/* harmony export */   spanTimeInputToSeconds: function() { return /* binding */ spanTimeInputToSeconds; },\n/* harmony export */   spanToJSON: function() { return /* binding */ spanToJSON; },\n/* harmony export */   spanToTraceContext: function() { return /* binding */ spanToTraceContext; },\n/* harmony export */   spanToTraceHeader: function() { return /* binding */ spanToTraceHeader; },\n/* harmony export */   spanToTransactionTraceContext: function() { return /* binding */ spanToTransactionTraceContext; },\n/* harmony export */   updateSpanName: function() { return /* binding */ updateSpanName; }\n/* harmony export */ });\n/* harmony import */ var _asyncContext_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asyncContext/index.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/asyncContext/index.js\");\n/* harmony import */ var _carrier_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../carrier.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/carrier.js\");\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../currentScopes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../semanticAttributes.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/semanticAttributes.js\");\n/* harmony import */ var _tracing_spanstatus_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tracing/spanstatus.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/spanstatus.js\");\n/* harmony import */ var _tracing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tracing/utils.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/tracing/utils.js\");\n/* harmony import */ var _utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils-hoist/logger.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils-hoist/object.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils-hoist/propagationContext.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js\");\n/* harmony import */ var _utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils-hoist/time.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n/* harmony import */ var _utils_hoist_tracing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils-hoist/tracing.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils-hoist/tracing.js\");\n/* harmony import */ var _spanOnScope_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./spanOnScope.js */ \"(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanOnScope.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\n\nlet hasShownSpanDropWarning = false;\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n * By default, this will only include trace_id, span_id & parent_span_id.\n * If `includeAllData` is true, it will also include data, op, status & origin.\n */\nfunction spanToTransactionTraceContext(span) {\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n  const { data, op, parent_span_id, status, origin, links } = spanToJSON(span);\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data,\n    op,\n    status,\n    origin,\n    links,\n  };\n}\n\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.\n */\nfunction spanToTraceContext(span) {\n  const { spanId, traceId: trace_id, isRemote } = span.spanContext();\n\n  // If the span is remote, we use a random/virtual span as span_id to the trace context,\n  // and the remote span as parent_span_id\n  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;\n  const scope = (0,_tracing_utils_js__WEBPACK_IMPORTED_MODULE_0__.getCapturedScopesOnSpan)(span).scope;\n\n  const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || (0,_utils_hoist_propagationContext_js__WEBPACK_IMPORTED_MODULE_1__.generateSpanId)() : spanId;\n\n  return {\n    parent_span_id,\n    span_id,\n    trace_id,\n  };\n}\n\n/**\n * Convert a Span to a Sentry trace header.\n */\nfunction spanToTraceHeader(span) {\n  const { traceId, spanId } = span.spanContext();\n  const sampled = spanIsSampled(span);\n  return (0,_utils_hoist_tracing_js__WEBPACK_IMPORTED_MODULE_2__.generateSentryTraceHeader)(traceId, spanId, sampled);\n}\n\n/**\n *  Converts the span links array to a flattened version to be sent within an envelope.\n *\n *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.\n */\nfunction convertSpanLinksForEnvelope(links) {\n  if (links && links.length > 0) {\n    return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({\n      span_id: spanId,\n      trace_id: traceId,\n      sampled: traceFlags === TRACE_FLAG_SAMPLED,\n      attributes,\n      ...restContext,\n    }));\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convert a span time input into a timestamp in seconds.\n */\nfunction spanTimeInputToSeconds(input) {\n  if (typeof input === 'number') {\n    return ensureTimestampInSeconds(input);\n  }\n\n  if (Array.isArray(input)) {\n    // See {@link HrTime} for the array-based time format\n    return input[0] + input[1] / 1e9;\n  }\n\n  if (input instanceof Date) {\n    return ensureTimestampInSeconds(input.getTime());\n  }\n\n  return (0,_utils_hoist_time_js__WEBPACK_IMPORTED_MODULE_3__.timestampInSeconds)();\n}\n\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */\nfunction ensureTimestampInSeconds(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Convert a span to a JSON representation.\n */\n// Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n// This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n// And `spanToJSON` needs the Span class from `span.ts` to check here.\nfunction spanToJSON(span) {\n  if (spanIsSentrySpan(span)) {\n    return span.getSpanJSON();\n  }\n\n  const { spanId: span_id, traceId: trace_id } = span.spanContext();\n\n  // Handle a span from @opentelemetry/sdk-base-trace's `Span` class\n  if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n    const { attributes, startTime, name, endTime, parentSpanId, status, links } = span;\n\n    return {\n      span_id,\n      trace_id,\n      data: attributes,\n      description: name,\n      parent_span_id: parentSpanId,\n      start_timestamp: spanTimeInputToSeconds(startTime),\n      // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n      timestamp: spanTimeInputToSeconds(endTime) || undefined,\n      status: getStatusMessage(status),\n      op: attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_OP],\n      origin: attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,\n      links: convertSpanLinksForEnvelope(links),\n    };\n  }\n\n  // Finally, at least we have `spanContext()`....\n  // This should not actually happen in reality, but we need to handle it for type safety.\n  return {\n    span_id,\n    trace_id,\n    start_timestamp: 0,\n    data: {},\n  };\n}\n\nfunction spanIsOpenTelemetrySdkTraceBaseSpan(span) {\n  const castSpan = span ;\n  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n}\n\n/** Exported only for tests. */\n\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */\nfunction spanIsSentrySpan(span) {\n  return typeof (span ).getSpanJSON === 'function';\n}\n\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */\nfunction spanIsSampled(span) {\n  // We align our trace flags with the ones OpenTelemetry use\n  // So we also check for sampled the same way they do.\n  const { traceFlags } = span.spanContext();\n  return traceFlags === TRACE_FLAG_SAMPLED;\n}\n\n/** Get the status message to use for a JSON representation of a span. */\nfunction getStatusMessage(status) {\n  if (!status || status.code === _tracing_spanstatus_js__WEBPACK_IMPORTED_MODULE_5__.SPAN_STATUS_UNSET) {\n    return undefined;\n  }\n\n  if (status.code === _tracing_spanstatus_js__WEBPACK_IMPORTED_MODULE_5__.SPAN_STATUS_OK) {\n    return 'ok';\n  }\n\n  return status.message || 'unknown_error';\n}\n\nconst CHILD_SPANS_FIELD = '_sentryChildSpans';\nconst ROOT_SPAN_FIELD = '_sentryRootSpan';\n\n/**\n * Adds an opaque child span reference to a span.\n */\nfunction addChildSpanToSpan(span, childSpan) {\n  // We store the root span reference on the child span\n  // We need this for `getRootSpan()` to work\n  const rootSpan = span[ROOT_SPAN_FIELD] || span;\n  (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_6__.addNonEnumerableProperty)(childSpan , ROOT_SPAN_FIELD, rootSpan);\n\n  // We store a list of child spans on the parent span\n  // We need this for `getSpanDescendants()` to work\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].add(childSpan);\n  } else {\n    (0,_utils_hoist_object_js__WEBPACK_IMPORTED_MODULE_6__.addNonEnumerableProperty)(span, CHILD_SPANS_FIELD, new Set([childSpan]));\n  }\n}\n\n/** This is only used internally by Idle Spans. */\nfunction removeChildSpanFromSpan(span, childSpan) {\n  if (span[CHILD_SPANS_FIELD]) {\n    span[CHILD_SPANS_FIELD].delete(childSpan);\n  }\n}\n\n/**\n * Returns an array of the given span and all of its descendants.\n */\nfunction getSpanDescendants(span) {\n  const resultSet = new Set();\n\n  function addSpanChildren(span) {\n    // This exit condition is required to not infinitely loop in case of a circular dependency.\n    if (resultSet.has(span)) {\n      return;\n      // We want to ignore unsampled spans (e.g. non recording spans)\n    } else if (spanIsSampled(span)) {\n      resultSet.add(span);\n      const childSpans = span[CHILD_SPANS_FIELD] ? Array.from(span[CHILD_SPANS_FIELD]) : [];\n      for (const childSpan of childSpans) {\n        addSpanChildren(childSpan);\n      }\n    }\n  }\n\n  addSpanChildren(span);\n\n  return Array.from(resultSet);\n}\n\n/**\n * Returns the root span of a given span.\n */\nfunction getRootSpan(span) {\n  return span[ROOT_SPAN_FIELD] || span;\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  const carrier = (0,_carrier_js__WEBPACK_IMPORTED_MODULE_7__.getMainCarrier)();\n  const acs = (0,_asyncContext_index_js__WEBPACK_IMPORTED_MODULE_8__.getAsyncContextStrategy)(carrier);\n  if (acs.getActiveSpan) {\n    return acs.getActiveSpan();\n  }\n\n  return (0,_spanOnScope_js__WEBPACK_IMPORTED_MODULE_9__._getSpanForScope)((0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_10__.getCurrentScope)());\n}\n\n/**\n * Logs a warning once if `beforeSendSpan` is used to drop spans.\n */\nfunction showSpanDropWarning() {\n  if (!hasShownSpanDropWarning) {\n    (0,_utils_hoist_logger_js__WEBPACK_IMPORTED_MODULE_11__.consoleSandbox)(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.',\n      );\n    });\n    hasShownSpanDropWarning = true;\n  }\n}\n\n/**\n * Updates the name of the given span and ensures that the span name is not\n * overwritten by the Sentry SDK.\n *\n * Use this function instead of `span.updateName()` if you want to make sure that\n * your name is kept. For some spans, for example root `http.server` spans the\n * Sentry SDK would otherwise overwrite the span name with a high-quality name\n * it infers when the span ends.\n *\n * Use this function in server code or when your span is started on the server\n * and on the client (browser). If you only update a span name on the client,\n * you can also use `span.updateName()` the SDK does not overwrite the name.\n *\n * @param span - The span to update the name of.\n * @param name - The name to set on the span.\n */\nfunction updateSpanName(span, name) {\n  span.updateName(name);\n  span.setAttributes({\n    [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n    [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_4__.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: name,\n  });\n}\n\n\n//# sourceMappingURL=spanUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9zcGFuVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDcEI7QUFDTztBQUNrSTtBQUMzRztBQUNmO0FBQ0o7QUFDVTtBQUNFO0FBQ1Y7QUFDVTtBQUNsQjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUsa0RBQWtEOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwRUFBdUI7O0FBRXZDLGlGQUFpRixrRkFBYzs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQSxTQUFTLGtGQUF5QjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLDZDQUE2QyxjQUFjO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHdFQUFrQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTtBQUNBLFlBQVksb0VBQW9FOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRkFBNEI7QUFDakQseUJBQXlCLG9GQUFnQztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxxRUFBaUI7QUFDbEQ7QUFDQTs7QUFFQSxzQkFBc0Isa0VBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdGQUF3Qjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSxnRkFBd0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFjO0FBQ2hDLGNBQWMsK0VBQXVCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlFQUFnQixDQUFDLG1FQUFlO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0ZBQWdDO0FBQ3JDLEtBQUssOEZBQTBDO0FBQy9DLEdBQUc7QUFDSDs7QUFFeVY7QUFDelYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3NwYW5VdGlscy5qcz9lODljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5IH0gZnJvbSAnLi4vYXN5bmNDb250ZXh0L2luZGV4LmpzJztcbmltcG9ydCB7IGdldE1haW5DYXJyaWVyIH0gZnJvbSAnLi4vY2Fycmllci5qcyc7XG5pbXBvcnQgeyBnZXRDdXJyZW50U2NvcGUgfSBmcm9tICcuLi9jdXJyZW50U2NvcGVzLmpzJztcbmltcG9ydCB7IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFIH0gZnJvbSAnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IFNQQU5fU1RBVFVTX1VOU0VULCBTUEFOX1NUQVRVU19PSyB9IGZyb20gJy4uL3RyYWNpbmcvc3BhbnN0YXR1cy5qcyc7XG5pbXBvcnQgeyBnZXRDYXB0dXJlZFNjb3Blc09uU3BhbiB9IGZyb20gJy4uL3RyYWNpbmcvdXRpbHMuanMnO1xuaW1wb3J0IHsgY29uc29sZVNhbmRib3ggfSBmcm9tICcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnO1xuaW1wb3J0IHsgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5IH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvb2JqZWN0LmpzJztcbmltcG9ydCB7IGdlbmVyYXRlU3BhbklkIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJztcbmltcG9ydCB7IHRpbWVzdGFtcEluU2Vjb25kcyB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlciB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgX2dldFNwYW5Gb3JTY29wZSB9IGZyb20gJy4vc3Bhbk9uU2NvcGUuanMnO1xuXG4vLyBUaGVzZSBhcmUgYWxpZ25lZCB3aXRoIE9wZW5UZWxlbWV0cnkgdHJhY2UgZmxhZ3NcbmNvbnN0IFRSQUNFX0ZMQUdfTk9ORSA9IDB4MDtcbmNvbnN0IFRSQUNFX0ZMQUdfU0FNUExFRCA9IDB4MTtcblxubGV0IGhhc1Nob3duU3BhbkRyb3BXYXJuaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQ29udmVydCBhIHNwYW4gdG8gYSB0cmFjZSBjb250ZXh0LCB3aGljaCBjYW4gYmUgc2VudCBhcyB0aGUgYHRyYWNlYCBjb250ZXh0IGluIGFuIGV2ZW50LlxuICogQnkgZGVmYXVsdCwgdGhpcyB3aWxsIG9ubHkgaW5jbHVkZSB0cmFjZV9pZCwgc3Bhbl9pZCAmIHBhcmVudF9zcGFuX2lkLlxuICogSWYgYGluY2x1ZGVBbGxEYXRhYCBpcyB0cnVlLCBpdCB3aWxsIGFsc28gaW5jbHVkZSBkYXRhLCBvcCwgc3RhdHVzICYgb3JpZ2luLlxuICovXG5mdW5jdGlvbiBzcGFuVG9UcmFuc2FjdGlvblRyYWNlQ29udGV4dChzcGFuKSB7XG4gIGNvbnN0IHsgc3BhbklkOiBzcGFuX2lkLCB0cmFjZUlkOiB0cmFjZV9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCB7IGRhdGEsIG9wLCBwYXJlbnRfc3Bhbl9pZCwgc3RhdHVzLCBvcmlnaW4sIGxpbmtzIH0gPSBzcGFuVG9KU09OKHNwYW4pO1xuXG4gIHJldHVybiB7XG4gICAgcGFyZW50X3NwYW5faWQsXG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgICBkYXRhLFxuICAgIG9wLFxuICAgIHN0YXR1cyxcbiAgICBvcmlnaW4sXG4gICAgbGlua3MsXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNwYW4gdG8gYSB0cmFjZSBjb250ZXh0LCB3aGljaCBjYW4gYmUgc2VudCBhcyB0aGUgYHRyYWNlYCBjb250ZXh0IGluIGEgbm9uLXRyYW5zYWN0aW9uIGV2ZW50LlxuICovXG5mdW5jdGlvbiBzcGFuVG9UcmFjZUNvbnRleHQoc3Bhbikge1xuICBjb25zdCB7IHNwYW5JZCwgdHJhY2VJZDogdHJhY2VfaWQsIGlzUmVtb3RlIH0gPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gSWYgdGhlIHNwYW4gaXMgcmVtb3RlLCB3ZSB1c2UgYSByYW5kb20vdmlydHVhbCBzcGFuIGFzIHNwYW5faWQgdG8gdGhlIHRyYWNlIGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgcmVtb3RlIHNwYW4gYXMgcGFyZW50X3NwYW5faWRcbiAgY29uc3QgcGFyZW50X3NwYW5faWQgPSBpc1JlbW90ZSA/IHNwYW5JZCA6IHNwYW5Ub0pTT04oc3BhbikucGFyZW50X3NwYW5faWQ7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbikuc2NvcGU7XG5cbiAgY29uc3Qgc3Bhbl9pZCA9IGlzUmVtb3RlID8gc2NvcGU/LmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLnByb3BhZ2F0aW9uU3BhbklkIHx8IGdlbmVyYXRlU3BhbklkKCkgOiBzcGFuSWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJlbnRfc3Bhbl9pZCxcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTcGFuIHRvIGEgU2VudHJ5IHRyYWNlIGhlYWRlci5cbiAqL1xuZnVuY3Rpb24gc3BhblRvVHJhY2VIZWFkZXIoc3Bhbikge1xuICBjb25zdCB7IHRyYWNlSWQsIHNwYW5JZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCBzYW1wbGVkID0gc3BhbklzU2FtcGxlZChzcGFuKTtcbiAgcmV0dXJuIGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIodHJhY2VJZCwgc3BhbklkLCBzYW1wbGVkKTtcbn1cblxuLyoqXG4gKiAgQ29udmVydHMgdGhlIHNwYW4gbGlua3MgYXJyYXkgdG8gYSBmbGF0dGVuZWQgdmVyc2lvbiB0byBiZSBzZW50IHdpdGhpbiBhbiBlbnZlbG9wZS5cbiAqXG4gKiAgSWYgdGhlIGxpbmtzIGFycmF5IGlzIGVtcHR5LCBpdCByZXR1cm5zIGB1bmRlZmluZWRgIHNvIHRoZSBlbXB0eSB2YWx1ZSBjYW4gYmUgZHJvcHBlZCBiZWZvcmUgaXQncyBzZW50LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpIHtcbiAgaWYgKGxpbmtzICYmIGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbGlua3MubWFwKCh7IGNvbnRleHQ6IHsgc3BhbklkLCB0cmFjZUlkLCB0cmFjZUZsYWdzLCAuLi5yZXN0Q29udGV4dCB9LCBhdHRyaWJ1dGVzIH0pID0+ICh7XG4gICAgICBzcGFuX2lkOiBzcGFuSWQsXG4gICAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICAgIHNhbXBsZWQ6IHRyYWNlRmxhZ3MgPT09IFRSQUNFX0ZMQUdfU0FNUExFRCxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAuLi5yZXN0Q29udGV4dCxcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzcGFuIHRpbWUgaW5wdXQgaW50byBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBzcGFuVGltZUlucHV0VG9TZWNvbmRzKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGVuc3VyZVRpbWVzdGFtcEluU2Vjb25kcyhpbnB1dCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAvLyBTZWUge0BsaW5rIEhyVGltZX0gZm9yIHRoZSBhcnJheS1iYXNlZCB0aW1lIGZvcm1hdFxuICAgIHJldHVybiBpbnB1dFswXSArIGlucHV0WzFdIC8gMWU5O1xuICB9XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBlbnN1cmVUaW1lc3RhbXBJblNlY29uZHMoaW5wdXQuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIHJldHVybiB0aW1lc3RhbXBJblNlY29uZHMoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRpbWVzdGFtcCB0byBzZWNvbmQsIGlmIGl0IHdhcyBpbiBtaWxsaXNlY29uZHMsIG9yIGtlZXBzIGl0IGFzIHNlY29uZC5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlVGltZXN0YW1wSW5TZWNvbmRzKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wID4gOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgLyAxMDAwIDogdGltZXN0YW1wO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzcGFuIHRvIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqL1xuLy8gTm90ZTogQmVjYXVzZSBvZiB0aGlzLCB3ZSBjdXJyZW50bHkgaGF2ZSBhIGNpcmN1bGFyIHR5cGUgZGVwZW5kZW5jeSAod2hpY2ggd2Ugb3B0ZWQgb3V0IG9mIGluIHBhY2thZ2UuanNvbikuXG4vLyBUaGlzIGlzIG5vdCBhdm9pZGFibGUgYXMgd2UgbmVlZCBgc3BhblRvSlNPTmAgaW4gYHNwYW5VdGlscy50c2AsIHdoaWNoIGluIHR1cm4gaXMgbmVlZGVkIGJ5IGBzcGFuLnRzYCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4vLyBBbmQgYHNwYW5Ub0pTT05gIG5lZWRzIHRoZSBTcGFuIGNsYXNzIGZyb20gYHNwYW4udHNgIHRvIGNoZWNrIGhlcmUuXG5mdW5jdGlvbiBzcGFuVG9KU09OKHNwYW4pIHtcbiAgaWYgKHNwYW5Jc1NlbnRyeVNwYW4oc3BhbikpIHtcbiAgICByZXR1cm4gc3Bhbi5nZXRTcGFuSlNPTigpO1xuICB9XG5cbiAgY29uc3QgeyBzcGFuSWQ6IHNwYW5faWQsIHRyYWNlSWQ6IHRyYWNlX2lkIH0gPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gSGFuZGxlIGEgc3BhbiBmcm9tIEBvcGVudGVsZW1ldHJ5L3Nkay1iYXNlLXRyYWNlJ3MgYFNwYW5gIGNsYXNzXG4gIGlmIChzcGFuSXNPcGVuVGVsZW1ldHJ5U2RrVHJhY2VCYXNlU3BhbihzcGFuKSkge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgc3RhcnRUaW1lLCBuYW1lLCBlbmRUaW1lLCBwYXJlbnRTcGFuSWQsIHN0YXR1cywgbGlua3MgfSA9IHNwYW47XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3Bhbl9pZCxcbiAgICAgIHRyYWNlX2lkLFxuICAgICAgZGF0YTogYXR0cmlidXRlcyxcbiAgICAgIGRlc2NyaXB0aW9uOiBuYW1lLFxuICAgICAgcGFyZW50X3NwYW5faWQ6IHBhcmVudFNwYW5JZCxcbiAgICAgIHN0YXJ0X3RpbWVzdGFtcDogc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzdGFydFRpbWUpLFxuICAgICAgLy8gVGhpcyBpcyBbMCwwXSBieSBkZWZhdWx0IGluIE9URUwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnRlcnByZXQgdGhpcyBhcyBubyBlbmQgdGltZVxuICAgICAgdGltZXN0YW1wOiBzcGFuVGltZUlucHV0VG9TZWNvbmRzKGVuZFRpbWUpIHx8IHVuZGVmaW5lZCxcbiAgICAgIHN0YXR1czogZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLFxuICAgICAgb3A6IGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0sXG4gICAgICBvcmlnaW46IGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dICxcbiAgICAgIGxpbmtzOiBjb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUobGlua3MpLFxuICAgIH07XG4gIH1cblxuICAvLyBGaW5hbGx5LCBhdCBsZWFzdCB3ZSBoYXZlIGBzcGFuQ29udGV4dCgpYC4uLi5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGFjdHVhbGx5IGhhcHBlbiBpbiByZWFsaXR5LCBidXQgd2UgbmVlZCB0byBoYW5kbGUgaXQgZm9yIHR5cGUgc2FmZXR5LlxuICByZXR1cm4ge1xuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgc3RhcnRfdGltZXN0YW1wOiAwLFxuICAgIGRhdGE6IHt9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBzcGFuSXNPcGVuVGVsZW1ldHJ5U2RrVHJhY2VCYXNlU3BhbihzcGFuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLmF0dHJpYnV0ZXMgJiYgISFjYXN0U3Bhbi5zdGFydFRpbWUgJiYgISFjYXN0U3Bhbi5uYW1lICYmICEhY2FzdFNwYW4uZW5kVGltZSAmJiAhIWNhc3RTcGFuLnN0YXR1cztcbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuXG4vKipcbiAqIFNhZGx5LCBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jeSBjaGVja3Mgd2UgY2Fubm90IGFjdHVhbGx5IGltcG9ydCB0aGUgU3BhbiBjbGFzcyBoZXJlIGFuZCBjaGVjayBmb3IgaW5zdGFuY2VvZi5cbiAqIDooIFNvIGluc3RlYWQgd2UgYXBwcm94aW1hdGUgdGhpcyBieSBjaGVja2luZyBpZiBpdCBoYXMgdGhlIGBnZXRTcGFuSlNPTmAgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBzcGFuSXNTZW50cnlTcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHR5cGVvZiAoc3BhbiApLmdldFNwYW5KU09OID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHNwYW4gaXMgc2FtcGxlZC5cbiAqIEluIG1vc3QgY2FzZXMsIHlvdSBzaG91bGQganVzdCB1c2UgYHNwYW4uaXNSZWNvcmRpbmcoKWAgaW5zdGVhZC5cbiAqIEhvd2V2ZXIsIHRoaXMgaGFzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHNlbWFudGljLCBhcyBpdCBhbHNvIHJldHVybnMgZmFsc2UgaWYgdGhlIHNwYW4gaXMgZmluaXNoZWQuXG4gKiBTbyBpbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgdXNlIHRoaXMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBzcGFuSXNTYW1wbGVkKHNwYW4pIHtcbiAgLy8gV2UgYWxpZ24gb3VyIHRyYWNlIGZsYWdzIHdpdGggdGhlIG9uZXMgT3BlblRlbGVtZXRyeSB1c2VcbiAgLy8gU28gd2UgYWxzbyBjaGVjayBmb3Igc2FtcGxlZCB0aGUgc2FtZSB3YXkgdGhleSBkby5cbiAgY29uc3QgeyB0cmFjZUZsYWdzIH0gPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gIHJldHVybiB0cmFjZUZsYWdzID09PSBUUkFDRV9GTEFHX1NBTVBMRUQ7XG59XG5cbi8qKiBHZXQgdGhlIHN0YXR1cyBtZXNzYWdlIHRvIHVzZSBmb3IgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3Bhbi4gKi9cbmZ1bmN0aW9uIGdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSB7XG4gIGlmICghc3RhdHVzIHx8IHN0YXR1cy5jb2RlID09PSBTUEFOX1NUQVRVU19VTlNFVCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoc3RhdHVzLmNvZGUgPT09IFNQQU5fU1RBVFVTX09LKSB7XG4gICAgcmV0dXJuICdvayc7XG4gIH1cblxuICByZXR1cm4gc3RhdHVzLm1lc3NhZ2UgfHwgJ3Vua25vd25fZXJyb3InO1xufVxuXG5jb25zdCBDSElMRF9TUEFOU19GSUVMRCA9ICdfc2VudHJ5Q2hpbGRTcGFucyc7XG5jb25zdCBST09UX1NQQU5fRklFTEQgPSAnX3NlbnRyeVJvb3RTcGFuJztcblxuLyoqXG4gKiBBZGRzIGFuIG9wYXF1ZSBjaGlsZCBzcGFuIHJlZmVyZW5jZSB0byBhIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkU3BhblRvU3BhbihzcGFuLCBjaGlsZFNwYW4pIHtcbiAgLy8gV2Ugc3RvcmUgdGhlIHJvb3Qgc3BhbiByZWZlcmVuY2Ugb24gdGhlIGNoaWxkIHNwYW5cbiAgLy8gV2UgbmVlZCB0aGlzIGZvciBgZ2V0Um9vdFNwYW4oKWAgdG8gd29ya1xuICBjb25zdCByb290U3BhbiA9IHNwYW5bUk9PVF9TUEFOX0ZJRUxEXSB8fCBzcGFuO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoY2hpbGRTcGFuICwgUk9PVF9TUEFOX0ZJRUxELCByb290U3Bhbik7XG5cbiAgLy8gV2Ugc3RvcmUgYSBsaXN0IG9mIGNoaWxkIHNwYW5zIG9uIHRoZSBwYXJlbnQgc3BhblxuICAvLyBXZSBuZWVkIHRoaXMgZm9yIGBnZXRTcGFuRGVzY2VuZGFudHMoKWAgdG8gd29ya1xuICBpZiAoc3BhbltDSElMRF9TUEFOU19GSUVMRF0pIHtcbiAgICBzcGFuW0NISUxEX1NQQU5TX0ZJRUxEXS5hZGQoY2hpbGRTcGFuKTtcbiAgfSBlbHNlIHtcbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc3BhbiwgQ0hJTERfU1BBTlNfRklFTEQsIG5ldyBTZXQoW2NoaWxkU3Bhbl0pKTtcbiAgfVxufVxuXG4vKiogVGhpcyBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseSBieSBJZGxlIFNwYW5zLiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRTcGFuRnJvbVNwYW4oc3BhbiwgY2hpbGRTcGFuKSB7XG4gIGlmIChzcGFuW0NISUxEX1NQQU5TX0ZJRUxEXSkge1xuICAgIHNwYW5bQ0hJTERfU1BBTlNfRklFTERdLmRlbGV0ZShjaGlsZFNwYW4pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZ2l2ZW4gc3BhbiBhbmQgYWxsIG9mIGl0cyBkZXNjZW5kYW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3BhbkRlc2NlbmRhbnRzKHNwYW4pIHtcbiAgY29uc3QgcmVzdWx0U2V0ID0gbmV3IFNldCgpO1xuXG4gIGZ1bmN0aW9uIGFkZFNwYW5DaGlsZHJlbihzcGFuKSB7XG4gICAgLy8gVGhpcyBleGl0IGNvbmRpdGlvbiBpcyByZXF1aXJlZCB0byBub3QgaW5maW5pdGVseSBsb29wIGluIGNhc2Ugb2YgYSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIGlmIChyZXN1bHRTZXQuaGFzKHNwYW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgICAvLyBXZSB3YW50IHRvIGlnbm9yZSB1bnNhbXBsZWQgc3BhbnMgKGUuZy4gbm9uIHJlY29yZGluZyBzcGFucylcbiAgICB9IGVsc2UgaWYgKHNwYW5Jc1NhbXBsZWQoc3BhbikpIHtcbiAgICAgIHJlc3VsdFNldC5hZGQoc3Bhbik7XG4gICAgICBjb25zdCBjaGlsZFNwYW5zID0gc3BhbltDSElMRF9TUEFOU19GSUVMRF0gPyBBcnJheS5mcm9tKHNwYW5bQ0hJTERfU1BBTlNfRklFTERdKSA6IFtdO1xuICAgICAgZm9yIChjb25zdCBjaGlsZFNwYW4gb2YgY2hpbGRTcGFucykge1xuICAgICAgICBhZGRTcGFuQ2hpbGRyZW4oY2hpbGRTcGFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRTcGFuQ2hpbGRyZW4oc3Bhbik7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0U2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByb290IHNwYW4gb2YgYSBnaXZlbiBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRSb290U3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuW1JPT1RfU1BBTl9GSUVMRF0gfHwgc3Bhbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW4oKSB7XG4gIGNvbnN0IGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBhY3MgPSBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKTtcbiAgaWYgKGFjcy5nZXRBY3RpdmVTcGFuKSB7XG4gICAgcmV0dXJuIGFjcy5nZXRBY3RpdmVTcGFuKCk7XG4gIH1cblxuICByZXR1cm4gX2dldFNwYW5Gb3JTY29wZShnZXRDdXJyZW50U2NvcGUoKSk7XG59XG5cbi8qKlxuICogTG9ncyBhIHdhcm5pbmcgb25jZSBpZiBgYmVmb3JlU2VuZFNwYW5gIGlzIHVzZWQgdG8gZHJvcCBzcGFucy5cbiAqL1xuZnVuY3Rpb24gc2hvd1NwYW5Ecm9wV2FybmluZygpIHtcbiAgaWYgKCFoYXNTaG93blNwYW5Ecm9wV2FybmluZykge1xuICAgIGNvbnNvbGVTYW5kYm94KCgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdbU2VudHJ5XSBSZXR1cm5pbmcgbnVsbCBmcm9tIGBiZWZvcmVTZW5kU3BhbmAgaXMgZGlzYWxsb3dlZC4gVG8gZHJvcCBjZXJ0YWluIHNwYW5zLCBjb25maWd1cmUgdGhlIHJlc3BlY3RpdmUgaW50ZWdyYXRpb25zIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH0pO1xuICAgIGhhc1Nob3duU3BhbkRyb3BXYXJuaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIHNwYW4gYW5kIGVuc3VyZXMgdGhhdCB0aGUgc3BhbiBuYW1lIGlzIG5vdFxuICogb3ZlcndyaXR0ZW4gYnkgdGhlIFNlbnRyeSBTREsuXG4gKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgc3Bhbi51cGRhdGVOYW1lKClgIGlmIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gKiB5b3VyIG5hbWUgaXMga2VwdC4gRm9yIHNvbWUgc3BhbnMsIGZvciBleGFtcGxlIHJvb3QgYGh0dHAuc2VydmVyYCBzcGFucyB0aGVcbiAqIFNlbnRyeSBTREsgd291bGQgb3RoZXJ3aXNlIG92ZXJ3cml0ZSB0aGUgc3BhbiBuYW1lIHdpdGggYSBoaWdoLXF1YWxpdHkgbmFtZVxuICogaXQgaW5mZXJzIHdoZW4gdGhlIHNwYW4gZW5kcy5cbiAqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpbiBzZXJ2ZXIgY29kZSBvciB3aGVuIHlvdXIgc3BhbiBpcyBzdGFydGVkIG9uIHRoZSBzZXJ2ZXJcbiAqIGFuZCBvbiB0aGUgY2xpZW50IChicm93c2VyKS4gSWYgeW91IG9ubHkgdXBkYXRlIGEgc3BhbiBuYW1lIG9uIHRoZSBjbGllbnQsXG4gKiB5b3UgY2FuIGFsc28gdXNlIGBzcGFuLnVwZGF0ZU5hbWUoKWAgdGhlIFNESyBkb2VzIG5vdCBvdmVyd3JpdGUgdGhlIG5hbWUuXG4gKlxuICogQHBhcmFtIHNwYW4gLSBUaGUgc3BhbiB0byB1cGRhdGUgdGhlIG5hbWUgb2YuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIHRvIHNldCBvbiB0aGUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlU3Bhbk5hbWUoc3BhbiwgbmFtZSkge1xuICBzcGFuLnVwZGF0ZU5hbWUobmFtZSk7XG4gIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogJ2N1c3RvbScsXG4gICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfQ1VTVE9NX1NQQU5fTkFNRV06IG5hbWUsXG4gIH0pO1xufVxuXG5leHBvcnQgeyBUUkFDRV9GTEFHX05PTkUsIFRSQUNFX0ZMQUdfU0FNUExFRCwgYWRkQ2hpbGRTcGFuVG9TcGFuLCBjb252ZXJ0U3BhbkxpbmtzRm9yRW52ZWxvcGUsIGdldEFjdGl2ZVNwYW4sIGdldFJvb3RTcGFuLCBnZXRTcGFuRGVzY2VuZGFudHMsIGdldFN0YXR1c01lc3NhZ2UsIHJlbW92ZUNoaWxkU3BhbkZyb21TcGFuLCBzaG93U3BhbkRyb3BXYXJuaW5nLCBzcGFuSXNTYW1wbGVkLCBzcGFuVGltZUlucHV0VG9TZWNvbmRzLCBzcGFuVG9KU09OLCBzcGFuVG9UcmFjZUNvbnRleHQsIHNwYW5Ub1RyYWNlSGVhZGVyLCBzcGFuVG9UcmFuc2FjdGlvblRyYWNlQ29udGV4dCwgdXBkYXRlU3Bhbk5hbWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwYW5VdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@sentry/core/build/esm/utils/spanUtils.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cnbeha%5CDesktop%5CPortfolio%5Capp%5Cglobal-error.jsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);